<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>IndProp: 归纳定义的命题</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 1: Logical Foundations</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>目录</li></a>
   <a href='coqindex.html'><li class='section_name'>索引</li></a>
   <a href='deps.html'><li class='section_name'>路线</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">IndProp<span class="subtitle">归纳定义的命题</span></h1>


<div class="code code-tight">

<span class="id" type="keyword">Set</span> <span class="id" type="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Logic.html#"><span class="id" type="library">Logic</span></a>.<br/>
<span class="id" type="keyword">Require</span> <a class="idref" href="http://coq.inria.fr/library/Coq.omega.Omega.html#"><span class="id" type="library">Coq.omega.Omega</span></a>.<br/>
</div>

<div class="doc">
<a name="lab199"></a><h1 class="section">归纳定义的命题</h1>

<div class="paragraph"> </div>

 在 <a href="Logic.html"><span class="inlineref">Logic</span></a> 一章中，我们学习了多种方法来编写命题，包括合取、析取和量词。
    在本章中，我们引入新的方式：<b>归纳定义的命题（Inductive Definitions）</b>。 
<div class="paragraph"> </div>

 请回想一下我们已经学过的两种方法来表达数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 是偶数：
    (1) <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>，以及 (2) <span class="inlinecode"><span style='font-size:120%;'>&exist;</span></span><span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span> 。
    然而另一种可能是通过如下规则来建立数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 的偶数性质：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 规则 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>:  数字 <span class="inlinecode">0</span> 是偶数。

</li>
<li> 规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>: 如果 <span class="inlinecode"><span class="id" type="var">n</span></span> 是偶数, 那么 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 是偶数。 
</li>
</ul>

<div class="paragraph"> </div>

 为了理解这样的偶数性质定义如何工作，我们可想象如何证明 <span class="inlinecode">4</span> 是偶数。
    根据规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>，需要证明 <span class="inlinecode">2</span> 是偶数。这时，只要证明 <span class="inlinecode">0</span> 是偶数，
    我们可继续通过规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 确保它成立。而规则 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 可直接证明 <span class="inlinecode">0</span> 是偶数。 
<div class="paragraph"> </div>

 接下来的课程中，我们会看到很多类似方式定义的命题。
    在非形式化的讨论中，使用轻量化的记法有助于阅读和书写。
    <b>推断规则（Inference Rules）</b> 是其中一种： 
<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;0</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;n</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_SS) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;(S&nbsp;(S&nbsp;n))</td>
  <td></td>
</td>
</table></center>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    若将前文所述的规则重新排版成推断规则，我们可以这样阅读它，如果线上方的 
    <b>前提（Premises）</b> 成立，那么线下方的 <b>结论（Conclusion）</b> 成立。
    比如，规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 是如果 <span class="inlinecode"><span class="id" type="var">n</span></span> 满足 <span class="inlinecode"><span class="id" type="var">ev</span></span>，那么 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 也满足。
    如果一条规则在线上方没有前提，则结论直接成立。

<div class="paragraph"> </div>

    我们可以通过组合推断规则来展示证明。下面展示如何转译 <span class="inlinecode">4</span> 是偶数的证明： 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;&nbsp;(<span class="id" type="var">ev_0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;(<span class="id" type="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;(<span class="id" type="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;4
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    为什么我们把这样的证明称之为「树」（而非其他，比如「栈」）？
    因为一般来说推断规则可以有多个前提。我们会在后面看到一些例子。 
<div class="paragraph"> </div>

 基于上述，可将偶数性质的定义翻译为Coq中使用 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明的定义，
    声明中每一个构造子对应一个推断规则： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="ev"><span class="id" type="inductive">ev</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ev_0"><span class="id" type="constructor">ev_0</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 0<br/>
| <a name="ev_SS"><span class="id" type="constructor">ev_SS</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
</div>

<div class="doc">
这个定义同之前其他 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 的使用有一个重要的区别：
    它的结果并不是一个 <span class="inlinecode"><span class="id" type="keyword">Type</span></span> ，而是一个将 <span class="inlinecode"><span class="id" type="var">nat</span></span> 映射到 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 的函数
    —— 即关于数的性质。
    注意我们曾见过其他的归纳定义结果为函数，比如 <span class="inlinecode"><span class="id" type="var">list</span></span> ，其类型是 <span class="inlinecode"><span class="id" type="keyword">Type</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> 。
    值得注意的是，由于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 中出现在冒号 <b>右侧</b> 的 <span class="inlinecode"><span class="id" type="var">nat</span></span> 参数是 <b>未命名</b> 的，
    这允许在不同的构造子类型中使用不同的值：
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 类型中的 <span class="inlinecode">0</span> 以及 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 类型中的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>。

<div class="paragraph"> </div>

    相反， <span class="inlinecode"><span class="id" type="var">list</span></span> 的定义以 <b>全局方式</b> 命名了冒号 <b>左侧</b> 的参数 <span class="inlinecode"><span class="id" type="var">X</span></span> ，
    强迫 <span class="inlinecode"><span class="id" type="var">nil</span></span> 和 <span class="inlinecode"><span class="id" type="var">cons</span></span> 的结果为同一个类型（ <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> ）。
    如果在定义 <span class="inlinecode"><span class="id" type="var">ev</span></span> 时我们将 <span class="inlinecode"><span class="id" type="var">nat</span></span> 置于冒号左侧，会得到如下错误： 
</div>
<div class="code code-tight">

<span class="id" type="var">Fail</span> <span class="id" type="keyword">Inductive</span> <a name="wrong_ev"><span class="id" type="inductive">wrong_ev</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="wrong_ev_0"><span class="id" type="constructor">wrong_ev_0</span></a> : <a class="idref" href="IndProp.html#wrong_ev"><span class="id" type="inductive">wrong_ev</span></a> 0<br/>
| <a name="wrong_ev_SS"><span class="id" type="constructor">wrong_ev_SS</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <span class="id" type="var">wrong_ev</span> <span class="id" type="var">n</span> → <span class="id" type="var">wrong_ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Error:&nbsp;A&nbsp;parameter&nbsp;of&nbsp;an&nbsp;inductive&nbsp;type&nbsp;n&nbsp;is&nbsp;not<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowed&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;bound&nbsp;variable&nbsp;in&nbsp;the&nbsp;type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;its&nbsp;constructor.&nbsp;*)</span><br/>
</div>

<div class="doc">
(「Parameter」 是 Coq 中的一个术语来表示 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 定义中冒号左侧的参数；
    「index」 则指冒号右侧的参数。) 
<div class="paragraph"> </div>

 在 Coq 中，我们可以认为 <span class="inlinecode"><span class="id" type="var">ev</span></span> 定义了一个性质 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，其包括原始定理
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>。  
<div class="paragraph"> </div>

 这些 「定理构造子」 等同于被证明过的定理。
    特别的，我们可以使用 Coq 中的 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略和规则名称来证明某个
    数字的 <span class="inlinecode"><span class="id" type="var">ev</span></span> 性质…… 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4"><span class="id" type="lemma">ev_4</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
…… 或使用函数应用的语法： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4'"><span class="id" type="lemma">ev_4'</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)). <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们同样可以对前提中使用到 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的定理进行证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_plus4"><span class="id" type="lemma">ev_plus4</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hn</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
更一般地，我们可以证明以任意数字乘2是偶数： 
<div class="paragraph"> </div>

<a name="lab200"></a><h4 class="section">Exercise: 1 star (ev_double)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="ev_double"><span class="id" type="lemma">ev_double</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab201"></a><h1 class="section">在证明中使用证据</h1>

<div class="paragraph"> </div>

 除了 <b>构造</b> 证据（evidence）来表示某个数字是偶数，我们还可以对这些证据进行 <b>推理</b>。

<div class="paragraph"> </div>

    使用 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明来引入 <span class="inlinecode"><span class="id" type="var">ev</span></span> 不仅仅表示在 Coq 中 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 和 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 
    这样的构造子是合法的方式来构造偶数证明的证据，他们也是 <b>仅有的</b> 方式 
    （对 <span class="inlinecode"><span class="id" type="var">ev</span></span> 而言）。 
<div class="paragraph"> </div>

 换句话说，如果某人展示了对于 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 的证据 <span class="inlinecode"><span class="id" type="var">E</span></span>，那么我们知道 <span class="inlinecode"><span class="id" type="var">E</span></span> 
    必是二者其一：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">E</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> （且 <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">O</span></span>）, 或

</li>
<li> <span class="inlinecode"><span class="id" type="var">E</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span> （且 <span class="inlinecode"><span class="id" type="var">n</span></span> 是 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>, <span class="inlinecode"><span class="id" type="var">E'</span></span> 是
        <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据）. 
</li>
</ul>

<div class="paragraph"> </div>

 这样的形式暗示着，我们可以像分析归纳定义的数据结构一样分析他们；
    特别的，对于这类证据使用 <b>归纳</b> 和 <b>分类讨论</b> 来进行论证也是可行的。
    让我们通过一些例子来看看在实践中这意味着什么。 
<div class="paragraph"> </div>

<a name="lab202"></a><h2 class="section">对证据进行反演</h2>

<div class="paragraph"> </div>

 假设我们正在证明涉及数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 的某个性质，且给定 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 作为前提。
    我们已经知道对 <span class="inlinecode"><span class="id" type="var">n</span></span> 使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略可对 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>
    进行分类讨论，同时 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会生成子目标。但对于一些证明，我们想
    <b>直接</b> 对证据 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 进行分析：

<div class="paragraph"> </div>

    根据 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的定义，有两种情况需要考虑：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果证据形如 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>，那么可得 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。

<div class="paragraph"> </div>


</li>
<li> 否则，证据必然形如 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>，其中 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> 且
      <span class="inlinecode"><span class="id" type="var">E'</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据。 
</li>
</ul>

<div class="paragraph"> </div>

 在 Coq 中进行此类推理，我们也可以使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略。
    除了可对涉及到构造子的等式进行推理，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 对归纳定义的命题
    提供了分类讨论的原则。当以此种方式使用它时，语法与 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 类似：
    我们需提供一个由 <span class="inlinecode">|</span> 分隔的标识符列表来命名构造子中的参数。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_minus2"><span class="id" type="lemma">ev_minus2</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在这个证明中反演推理的工作方式如下：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果证据形如 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>，那么我们可得 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。
      因此，需要证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">0))</span> 成立。
      根据 <span class="inlinecode"><span class="id" type="var">pred</span></span> 的定义，这等同于证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span>，即可从 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 直接得证。

<div class="paragraph"> </div>


</li>
<li> 否则，证据必然形如 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>，其中 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> 且 <span class="inlinecode"><span class="id" type="var">E'</span></span> 是
      <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据。我们需要证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>))))</span> 成立，
      在简化后，可从 <span class="inlinecode"><span class="id" type="var">E'</span></span> 得证。 
</li>
</ul>

<div class="paragraph"> </div>

 如果我们把 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 替换为 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>，这个证明同样工作： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_minus2'"><span class="id" type="lemma">ev_minus2'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
将一个由归纳性质（inductive property）构成的假设作用于复杂的表达式
    （而非一个变量）时， 使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会比 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 更加方便。
    这里有一个具体的例子。假设我们想要证明 <span class="inlinecode"><span class="id" type="var">ev_minus2</span></span> 的变种： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="evSS_ev"><span class="id" type="lemma">evSS_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
</div>

<div class="doc">
直观来说，我们知道支撑前提的证据不会由 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 组成，因为 <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">S</span></span> 是
    <span class="inlinecode"><span class="id" type="var">nat</span></span> 类型不同的构造子；由此 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 是唯一需要应对的情况（译注：<span class="inlinecode"><span class="id" type="var">ev_0</span></span> 无条件成立）。
    不幸的是，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 并没有如此智能，它仍然为我们生成两个子目标。
    更甚至，于此同时最终目标没有改变，也无法为完成证明提供任何有用的信息。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;我们须证明&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;是偶数，但没有任何有用的假设信息可以使用！&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
究竟发生了什么？ 应用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 把性质的参数替换为对应于构造子的值。
    这对于证明 <span class="inlinecode"><span class="id" type="var">ev_minus2'</span></span> 是有帮助的，因为在最终目标中直接使用到了参数 <span class="inlinecode"><span class="id" type="var">n</span></span>。
    然而，这对于 <span class="inlinecode"><span class="id" type="var">evSS_ev</span></span> 并没有帮助，因为被替换掉的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 并没有在其他地方被使用。
<div class="paragraph"> </div>

 另一方面，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略可以检测到（1）第一个分类是不适用的（译注：<span class="inlinecode"><span class="id" type="var">ev_0</span></span>），
    以及（2）出现在 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 中的 <span class="inlinecode"><span class="id" type="var">n'</span></span> 必等同于 <span class="inlinecode"><span class="id" type="var">n</span></span>。
    这帮助我们完成了证明： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="evSS_ev"><span class="id" type="lemma">evSS_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>&nbsp;case&nbsp;now.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
通过 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，我们可以对「显然矛盾的」归纳性质假设应用爆炸原理（principle of explosion）。
    比如： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="one_not_even"><span class="id" type="lemma">one_not_even</span></a> : ¬ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab203"></a><h4 class="section">Exercise: 1 star (SSSSev__even)</h4>
 请使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略证明以下结果。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="SSSSev__even"><span class="id" type="lemma">SSSSev__even</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)))) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab204"></a><h4 class="section">Exercise: 1 star (even5_nonsense)</h4>
 请使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略证明以下结果。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="even5_nonsense"><span class="id" type="lemma">even5_nonsense</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 5 → 2 + 2 = 9.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 初看我们使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 的方式似乎有点难以理解。 
    目前为止，我们只对相等性命题使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，以此来利用构造子的单射性
    或区分不同的构造子（TODO：injectivity翻译） 。
    但我们将要看到 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 也可以用于分析归纳定义命题的证据。

<div class="paragraph"> </div>

    一般来说 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 以这样的方式工作。设想在当前上下文中名称 <span class="inlinecode"><span class="id" type="var">I</span></span> 指向
    假设 <span class="inlinecode"><span class="id" type="var">P</span></span>，而<span class="inlinecode"><span class="id" type="var">P</span></span> 由一个 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明所定义。
    接下来，使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> 会对 <span class="inlinecode"><span class="id" type="var">P</span></span> 中的每一个构造子生成子目标，
    其中 <span class="inlinecode"><span class="id" type="var">I</span></span> 会被替换为在这个构造子中为了证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 所需要满足的精确条件。
    有些子目标是自相矛盾的，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会直接抛弃这些子目标。
    而为了证明最初的目标，剩下的情形必须被证明。对于这些，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会添加
    <span class="inlinecode"><span class="id" type="var">P</span></span> 成立所需要的等式到证明的上下文中。（比如 <span class="inlinecode"><span class="id" type="var">evSS_ev</span></span> 证明中的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span>。） 
<div class="paragraph"> </div>

 上面的 <span class="inlinecode"><span class="id" type="var">ev_double</span></span> 练习展示了偶数性质的一种新记法，其被之前的两种记法所蕴含。
    （因为，由  <a href="Logic.html"><span class="inlineref">Logic</span></a> 一章中的 <span class="inlinecode"><span class="id" type="var">even_bool_prop</span></span>，我们已经知道
    他们是互相等价的。）
    为了展示这三种方式的一致性，我们需要下面的引理： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="ev_even_firsttry"><span class="id" type="lemma">ev_even_firsttry</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
</div>

<div class="doc">
我们可以尝试使用分类讨论或对 <span class="inlinecode"><span class="id" type="var">n</span></span> 进行归纳。
    但由于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 在前提中出现，如同之前章节的一些例子，这种策略或许无法行得通。
    如此我们似乎可以首先尝试对 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的证据进行反演。
    确实，第一个分类可以被平凡地证明。 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> 0. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>.<br/>
</div>

<div class="doc">
不幸地是，第二个分类要困难一些。我们需要证明 <span class="inlinecode"><span style='font-size:120%;'>&exist;</span></span><span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>，
    但唯一可用的假设是 <span class="inlinecode"><span class="id" type="var">E'</span></span>，也即 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 成立。由于这并不直接有用，
    我们似乎被卡住了，而对 <span class="inlinecode"><span class="id" type="var">E</span></span> 进行分类讨论是徒劳的。

<div class="paragraph"> </div>

    如果仔细观察第二个（子）目标，我们可以看到一些有意思的事情：
    对 <span class="inlinecode"><span class="id" type="var">E</span></span> 进行分类讨论，我们可以把要证明的原始结果归约到另一个上，
    其涉及到一个不同 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的证据： <span class="inlinecode"><span class="id" type="var">E'</span></span>。
    形式化地说，我们可以完成证明通过展示：

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span>&nbsp;<span class="id" type="var">k'</span>,&nbsp;<span class="id" type="var">n'</span>&nbsp;=&nbsp;<span class="id" type="var">double</span>&nbsp;<span class="id" type="var">k'</span>,
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

    这同原始的命题是一致的，只是 <span class="inlinecode"><span class="id" type="var">n'</span></span> 被替换为 n。确实，通过这个中间结果完成证明
    并不困难。  
</div>
<div class="code code-tight">

&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">I</span> : (<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k'</span>, <span class="id" type="var">n'</span> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k'"><span class="id" type="variable">k'</span></a>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span>) = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">intros</span> [<span class="id" type="var">k'</span> <span class="id" type="var">Hk'</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk'</span>. <span style='font-size:120%;'>&exist;</span> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">k'</span>). <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">I</span>. <span class="comment">(*&nbsp;将原始目标归约到新目标上&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a name="lab205"></a><h2 class="section">对证据进行归纳</h2>

<div class="paragraph"> </div>

 看起来很类似，但这并不是巧合：我们遇到了类似 <a href="Induction.html"><span class="inlineref">Induction</span></a> 章节中的问题，
    对于需要使用归纳来证明的命题我们使用了分类讨论。
    再一次地，解决方法是使用……归纳！

<div class="paragraph"> </div>

    对证据和对数据使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 的行为是相同的：它导致 Coq 对每个可用于构造证据的
    构造子生成一个子目标，同时对递归出现的问题命题提供了归纳假设。 
<div class="paragraph"> </div>

 让我们再次尝试证明这个引理： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="ev_even"><span class="id" type="lemma">ev_even</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n'</span> <span class="id" type="var">E'</span> <span class="id" type="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> 0. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时&nbsp;IH&nbsp;:&nbsp;exists&nbsp;k',&nbsp;n'&nbsp;=&nbsp;double&nbsp;k'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">IH</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">k'</span> <span class="id" type="var">Hk'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk'</span>. <span style='font-size:120%;'>&exist;</span> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">k'</span>). <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这里我们看到 Coq 对 <span class="inlinecode"><span class="id" type="var">E'</span></span> 产生了 <span class="inlinecode"><span class="id" type="var">IH</span></span>，而 <span class="inlinecode"><span class="id" type="var">E'</span></span> 是唯一递归出现的
    <span class="inlinecode"><span class="id" type="var">ev</span></span> 命题。 由于 <span class="inlinecode"><span class="id" type="var">E'</span></span> 中涉及到 <span class="inlinecode"><span class="id" type="var">n'</span></span>，这个归纳假设是关于 <span class="inlinecode"><span class="id" type="var">n'</span></span> 的，
    而非关于 <span class="inlinecode"><span class="id" type="var">n</span></span> 或其他数字的。  
<div class="paragraph"> </div>

 关于偶数性质的第二个和第三个定义的等价性如下： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_even_iff"><span class="id" type="lemma">ev_even_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ↔ <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_even"><span class="id" type="lemma">ev_even</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span> <span class="id" type="tactic">intros</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_double"><span class="id" type="axiom">ev_double</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们会在后面的章节中看到，对证据进行归纳在很多领域里是一种常用的技术，
    特别是在形式化程序语言的语义时，由于其中很多有趣的性质都是归纳定义的。 
<div class="paragraph"> </div>

 下面的练习提供了一些简单的例子，来帮助你熟悉这项技术。 
<div class="paragraph"> </div>

<a name="lab206"></a><h4 class="section">Exercise: 2 stars (ev_sum)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="ev_sum"><span class="id" type="lemma">ev_sum</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab207"></a><h4 class="section">Exercise: 4 stars, advanced, optional (ev</b>ev)</h4>
 一般来说，有很多种方式来归纳地定义一个性质。比如说，下面是关于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的另一种（蹩脚的）定义：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="ev'"><span class="id" type="inductive">ev'</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ev'_0"><span class="id" type="constructor">ev'_0</span></a> : <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> 0<br/>
| <a name="ev'_2"><span class="id" type="constructor">ev'_2</span></a> : <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> 2<br/>
| <a name="ev'_sum"><span class="id" type="constructor">ev'_sum</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
</div>

<div class="doc">
请证明这个定义在逻辑上等同于前述定义。（当进入到归纳环节时，你可能会想参考一下上一个定理。）
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev'_ev"><span class="id" type="lemma">ev'_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ↔ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab208"></a><h4 class="section">Exercise: 3 stars, advanced, recommended (ev_ev__ev)</h4>
 在本题中找到合适的项进行归纳需要一点技巧： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_ev__ev"><span class="id" type="lemma">ev_ev__ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab209"></a><h4 class="section">Exercise: 3 stars, optional (ev_plus_plus)</h4>
 这个练习仅仅需要使用前述引理。不需要使用归纳和分类讨论，尽管一些重写可能会比较乏味。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_plus_plus"><span class="id" type="lemma">ev_plus_plus</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#p"><span class="id" type="variable">p</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>+<a class="idref" href="IndProp.html#p"><span class="id" type="variable">p</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab210"></a><h1 class="section">归纳关系</h1>

<div class="paragraph"> </div>

 我们可以认为由数字参数化的命题（比如 <span class="inlinecode"><span class="id" type="var">ev</span></span>）是一个<b>性质</b>，也即，
    它定义了 <span class="inlinecode"><span class="id" type="var">nat</span></span>　的一个子集，其中的数字可以被证明满足此命题。
    以同样的方式，我们可认为有两个参数的命题是一个<b>关系</b>，也即，它定义了一个
    序对的集合可满足此命题。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Playground"><span class="id" type="module">Playground</span></a>.<br/>
</div>

<div class="doc">
一个很有用的例子是数字的「小于等于」关系。
<div class="paragraph"> </div>

　下面的定义应当是比较直观的。它提供了两种方法来描述一个数字小于等于另一个数字的证据：
    要么可观察到两个数字相等，或提供证据显示第一个数字小于等于第二个数字的前继。　
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="Playground.le"><span class="id" type="inductive">le</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Playground.le_n"><span class="id" type="constructor">le_n</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="Playground.le_S"><span class="id" type="constructor">le_S</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, (<a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → (<a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>)).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "m ≤ n" := (<a class="idref" href="IndProp.html#Playground.le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>
</div>

<div class="doc">
类似于证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> 这样的性质，使用 <span class="inlinecode"><span class="id" type="var">le_n</span></span> 和 <span class="inlinecode"><span class="id" type="var">le_S</span></span>　构造子来证明关于 <span class="inlinecode">≤</span>
    的事实遵循了同样的模式。我们可以对构造子使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略来证明 <span class="inlinecode">≤</span> 目标
    （比如证明 <span class="inlinecode">3≤3</span> 或 <span class="inlinecode">3≤6</span>），也可以使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略来从上下文中 <span class="inlinecode">≤</span> 的
    假设里抽取信息（比如证明 <span class="inlinecode">(2≤1)</span> <span class="inlinecode">→</span> <span class="inlinecode">2+2=5</span>）。 
<div class="paragraph"> </div>

 这里提供一些完备性检查。（请注意，尽管这同我们在开始课程时编写的
    函数「单元测试」类似，但我们在这里必须明确地写下他们的证明—— <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 和
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 并不会有效果，因为这些证明不仅仅是对表达式进行简化。）  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>1</sub>"><span class="id" type="lemma">test_le<sub>1</sub></span></a> :<br/>
&nbsp;&nbsp;3 ≤ 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>2</sub>"><span class="id" type="lemma">test_le<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;3 ≤ 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>3</sub>"><span class="id" type="lemma">test_le<sub>3</sub></span></a> :<br/>
&nbsp;&nbsp;(2 ≤ 1) → 2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
现在「严格小于」关系 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">m</span></span> 可以使用 <span class="inlinecode"><span class="id" type="var">le</span></span> 来定义。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#Playground"><span class="id" type="module">Playground</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="lt"><span class="id" type="definition">lt</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#le"><span class="id" type="inductive">le</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "m &lt; n" := (<a class="idref" href="IndProp.html#lt"><span class="id" type="definition">lt</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>
</div>

<div class="doc">
这里展示了一些定义于数字上的关系：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="square_of"><span class="id" type="inductive">square_of</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="sq"><span class="id" type="constructor">sq</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#square_of"><span class="id" type="inductive">square_of</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="next_nat"><span class="id" type="inductive">next_nat</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="nn"><span class="id" type="constructor">nn</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#next_nat"><span class="id" type="inductive">next_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="next_even"><span class="id" type="inductive">next_even</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="ne_1"><span class="id" type="constructor">ne_1</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) → <a class="idref" href="IndProp.html#next_even"><span class="id" type="inductive">next_even</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)<br/>
&nbsp;&nbsp;| <a name="ne_2"><span class="id" type="constructor">ne_2</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#next_even"><span class="id" type="inductive">next_even</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
</div>

<div class="doc">
<a name="lab211"></a><h4 class="section">Exercise: 2 stars, optional (total_relation)</h4>
 请定一个二元归纳关系 <span class="inlinecode"><span class="id" type="var">total_relation</span></span> 对每一个自然数序对成立。 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab212"></a><h4 class="section">Exercise: 2 stars, optional (empty_relation)</h4>
 请定一个二元归纳关系 <span class="inlinecode"><span class="id" type="var">empty_relation</span></span> 对自然数永远为假。 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab213"></a><h4 class="section">Exercise: 3 stars, optional (le_exercises)</h4>
 这里展示一些关于 <span class="inlinecode">≤</span> 和 <span class="inlinecode">&lt;</span> 关系的事实，我们在接下来的课程中将会用到他们。
    证明他们将会是非常有益的练习。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="le_trans"><span class="id" type="lemma">le_trans</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ≤ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ≤ <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="O_le_n"><span class="id" type="lemma">O_le_n</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;0 ≤ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="n_le_m__Sn_le_Sm"><span class="id" type="lemma">n_le_m__Sn_le_Sm</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Sn_le_Sm__n_le_m"><span class="id" type="lemma">Sn_le_Sm__n_le_m</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="le_plus_l"><span class="id" type="lemma">le_plus_l</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ≤ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> + <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="plus_lt"><span class="id" type="lemma">plus_lt</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> + <a class="idref" href="IndProp.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ∧ <a class="idref" href="IndProp.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="IndProp.html#lt"><span class="id" type="definition">lt</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="lt_S"><span class="id" type="lemma">lt_S</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> &lt; <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="leb_complete"><span class="id" type="lemma">leb_complete</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
提示：在下面的问题中，对 <span class="inlinecode"><span class="id" type="var">m</span></span> 进行归纳会使证明容易一些。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="leb_correct"><span class="id" type="lemma">leb_correct</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
提示：这个定理可以不通过使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 来证明。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="leb_true_trans"><span class="id" type="lemma">leb_true_trans</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab214"></a><h4 class="section">Exercise: 2 stars, optional (leb_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="leb_iff"><span class="id" type="lemma">leb_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> ↔ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="R"><span class="id" type="module">R</span></a>.<br/>
</div>

<div class="doc">
<a name="lab215"></a><h4 class="section">Exercise: 3 stars, recommended (R_provability)</h4>
 通过同样的方式，我们可以定义三元关系、四元关系等。例如，考虑以下定义在数字上的三元关系： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="R.R"><span class="id" type="inductive">R</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c1"><span class="id" type="constructor">c<sub>1</sub></span></a> : <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> 0 0 0<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c2"><span class="id" type="constructor">c<sub>2</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c3"><span class="id" type="constructor">c<sub>3</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c4"><span class="id" type="constructor">c<sub>4</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)) → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a><br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c5"><span class="id" type="constructor">c<sub>5</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> 下列哪个命题是可以被证明的？
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1</span> <span class="inlinecode">2</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">2</span> <span class="inlinecode">6</span>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> 如果在 <span class="inlinecode"><span class="id" type="var">R</span></span> 的定义中我们丢弃 <span class="inlinecode"><span class="id" type="var">c<sub>5</sub></span></span> 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。

<div class="paragraph"> </div>


</li>
<li> 如果在 <span class="inlinecode"><span class="id" type="var">R</span></span> 的定义中我们丢弃 <span class="inlinecode"><span class="id" type="var">c<sub>4</sub></span></span> 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。

</li>
</ul>

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
 <span class="proofbox">&#9744;</span> 
<div class="paragraph"> </div>

<a name="lab216"></a><h4 class="section">Exercise: 3 stars, optional (R_fact)</h4>
 关系 <span class="inlinecode"><span class="id" type="var">R</span></span> 其实编码了一个熟悉的函数。请找出这个函数，定义它并在 Coq 中证明他们等价。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="R.fR"><span class="id" type="definition">fR</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="R.R_equiv_fR"><span class="id" type="lemma">R_equiv_fR</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R.R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> ↔ <a class="idref" href="IndProp.html#R.fR"><span class="id" type="axiom">fR</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#R"><span class="id" type="module">R</span></a>.<br/>
</div>

<div class="doc">
<a name="lab217"></a><h4 class="section">Exercise: 4 stars, advanced (subsequence)</h4>
 如果一个列表的所有元素以相同的顺序出现在另一个列表之中（但允许其中出现其他额外的元素），
    我们把第一个列表称作第二个列表的<b>子序列</b>。 例如：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]
<div class="paragraph"> </div>

</div>
    是以下所有列表的子序列

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;1;1;2;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;7;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5;6;1;9;9;2;7;3;8]
<div class="paragraph"> </div>

</div>
    但<b>不是</b>以下列表的子序列

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5;6;2;1;7;3;8].
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<ul class="doclist">
<li> 在 <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> 上定一个归纳命题 <span class="inlinecode"><span class="id" type="var">subseq</span></span>，其表达了子序列的涵义。
      （提示：你需要三个分类。）

<div class="paragraph"> </div>


</li>
<li> 证明子序列的自反关系 <span class="inlinecode"><span class="id" type="var">subseq_refl</span></span>，也即任何列表是它自身的子序列。

<div class="paragraph"> </div>


</li>
<li> 证明关系 <span class="inlinecode"><span class="id" type="var">subseq_app</span></span> 对任意列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>，<span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span>，如果 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>
      的子序列，那么 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 也是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列。

<div class="paragraph"> </div>


</li>
<li> （可选的，困难）证明子序列的传递关系 <span class="inlinecode"><span class="id" type="var">subseq_trans</span></span>——也即，如果 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>
      的子序列，且 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列，那么 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列。
      （提示：仔细选择进行归纳的项！） 
</li>
</ul>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab218"></a><h4 class="section">Exercise: 2 stars, optional (R_provability2)</h4>
 假设我们在 Coq 中有如下定义：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">R</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;→&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;→&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>1</sub></span>&nbsp;:&nbsp;<span class="id" type="var">R</span>&nbsp;0&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>2</sub></span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>3</sub></span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>
    下列命题哪个是可被证明的？

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;2;1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">6</span> <span class="inlinecode">[3;2;1;0]</span>  
</li>
</ul>

<div class="paragraph"> </div>

 <span class="proofbox">&#9744;</span> 
</div>

<div class="doc">
<a name="lab219"></a><h1 class="section">Case Study: Regular Expressions</h1>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">ev</span></span> property provides a simple example for illustrating
    inductive definitions and the basic techniques for reasoning about
    them, but it is not terribly exciting &mdash; after all, it is
    equivalent to the two non-inductive definitions of evenness that
    we had already seen, and does not seem to offer any concrete
    benefit over them.  To give a better sense of the power of
    inductive definitions, we now show how to use them to model a
    classic concept in computer science: _regular expressions_. 
<div class="paragraph"> </div>

 Regular expressions are a simple language for describing strings,
    defined as follows: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="reg_exp"><span class="id" type="inductive">reg_exp</span></a> {<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>} : <span class="id" type="keyword">Type</span> :=<br/>
| <a name="EmptySet"><span class="id" type="constructor">EmptySet</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Char"><span class="id" type="constructor">Char</span></a> : <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="App"><span class="id" type="constructor">App</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Union"><span class="id" type="constructor">Union</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Star"><span class="id" type="constructor">Star</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>.<br/>
</div>

<div class="doc">
Note that this definition is _polymorphic_: Regular
    expressions in <span class="inlinecode"><span class="id" type="var">reg_exp</span></span> <span class="inlinecode"><span class="id" type="var">T</span></span> describe strings with characters drawn
    from <span class="inlinecode"><span class="id" type="var">T</span></span> &mdash; that is, lists of elements of <span class="inlinecode"><span class="id" type="var">T</span></span>.

<div class="paragraph"> </div>

    (We depart slightly from standard practice in that we do not
    require the type <span class="inlinecode"><span class="id" type="var">T</span></span> to be finite.  This results in a somewhat
    different theory of regular expressions, but the difference is not
    significant for our purposes.) 
<div class="paragraph"> </div>

 We connect regular expressions and strings via the following
    rules, which define when a regular expression _matches_ some
    string:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The expression <span class="inlinecode"><span class="id" type="var">EmptySet</span></span> does not match any string.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> matches the empty string <span class="inlinecode">[]</span>.

<div class="paragraph"> </div>


</li>
<li> The expression <span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> matches the one-character string <span class="inlinecode">[<span class="id" type="var">x</span>]</span>.

<div class="paragraph"> </div>


</li>
<li> If <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>, and <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>, then <span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>
        <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>.

<div class="paragraph"> </div>


</li>
<li> If at least one of <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">s</span></span>, then <span class="inlinecode"><span class="id" type="var">Union</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>
        <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">s</span></span>.

<div class="paragraph"> </div>


</li>
<li> Finally, if we can write some string <span class="inlinecode"><span class="id" type="var">s</span></span> as the concatenation of
        a sequence of strings <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s_1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">...</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s_k</span></span>, and the
        expression <span class="inlinecode"><span class="id" type="var">re</span></span> matches each one of the strings <span class="inlinecode"><span class="id" type="var">s_i</span></span>, then
        <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> matches <span class="inlinecode"><span class="id" type="var">s</span></span>.

<div class="paragraph"> </div>

        As a special case, the sequence of strings may be empty, so
        <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> always matches the empty string <span class="inlinecode">[]</span> no matter what
        <span class="inlinecode"><span class="id" type="var">re</span></span> is. 
</li>
</ul>

<div class="paragraph"> </div>

 We can easily translate this informal definition into an
    <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> one as follows: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="exp_match"><span class="id" type="inductive">exp_match</span></a> {<span class="id" type="var">T</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">T</span> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="MEmpty"><span class="id" type="constructor">MEmpty</span></a> : <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [] <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a><br/>
| <a name="MChar"><span class="id" type="constructor">MChar</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [<a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a>] (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a>)<br/>
| <a name="MApp"><span class="id" type="constructor">MApp</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> (<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>) (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MUnionL"><span class="id" type="constructor">MUnionL</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> (<a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MUnionR"><span class="id" type="constructor">MUnionR</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> (<a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MStar0"><span class="id" type="constructor">MStar0</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [] (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>)<br/>
| <a name="MStarApp"><span class="id" type="constructor">MStarApp</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> (<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>) (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
Again, for readability, we can also display this definition using
    inference-rule notation.  At the same time, let's introduce a more
    readable infix notation. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "s =~ re" := (<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <span class="id" type="var">s</span> <span class="id" type="var">re</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 80).<br/>
</div>

<div class="doc">
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MEmpty) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[]&nbsp;=~&nbsp;EmptyStr</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MChar) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[x]&nbsp;=~&nbsp;Char&nbsp;x</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re<sub>1</sub>&nbsp;&nbsp;&nbsp;&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;re<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MApp) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;++&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;App&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MUnionL) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;Union&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>2</sub>&nbsp;=~&nbsp;re<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MUnionR) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>2</sub>&nbsp;=~&nbsp;Union&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MStar0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[]&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re&nbsp;&nbsp;&nbsp;&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td class="infrulenamecol" rowspan="3">
    (MStarApp) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;++&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td></td>
</td>
</table></center>
<div class="paragraph"> </div>

 Notice that these rules are not _quite_ the same as the informal
    ones that we gave at the beginning of the section.  First, we
    don't need to include a rule explicitly stating that no string
    matches <span class="inlinecode"><span class="id" type="var">EmptySet</span></span>; we just don't happen to include any rule that
    would have the effect of some string matching <span class="inlinecode"><span class="id" type="var">EmptySet</span></span>.  (Indeed,
    the syntax of inductive definitions doesn't even _allow_ us to
    give such a "negative rule.")

<div class="paragraph"> </div>

    Second, the informal rules for <span class="inlinecode"><span class="id" type="var">Union</span></span> and <span class="inlinecode"><span class="id" type="var">Star</span></span> correspond
    to two constructors each: <span class="inlinecode"><span class="id" type="var">MUnionL</span></span> / <span class="inlinecode"><span class="id" type="var">MUnionR</span></span>, and <span class="inlinecode"><span class="id" type="var">MStar0</span></span> /
    <span class="inlinecode"><span class="id" type="var">MStarApp</span></span>.  The result is logically equivalent to the original
    rules but more convenient to use in Coq, since the recursive
    occurrences of <span class="inlinecode"><span class="id" type="var">exp_match</span></span> are given as direct arguments to the
    constructors, making it easier to perform induction on evidence.
    (The <span class="inlinecode"><span class="id" type="var">exp_match_ex<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">exp_match_ex<sub>2</sub></span></span> exercises below ask you
    to prove that the constructors given in the inductive declaration
    and the ones that would arise from a more literal transcription of
    the informal rules are indeed equivalent.)

<div class="paragraph"> </div>

    Let's illustrate these rules with a few examples. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>1</sub>"><span class="id" type="definition">reg_exp_ex<sub>1</sub></span></a> : [1] =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>2</sub>"><span class="id" type="definition">reg_exp_ex<sub>2</sub></span></a> : [1; 2] =~ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 2).<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [1] <span class="id" type="var">_</span> [2]).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
(Notice how the last example applies <span class="inlinecode"><span class="id" type="var">MApp</span></span> to the strings <span class="inlinecode">[1]</span>
    and <span class="inlinecode">[2]</span> directly.  Since the goal mentions <span class="inlinecode">[1;</span> <span class="inlinecode">2]</span> instead of
    <span class="inlinecode">[1]</span> <span class="inlinecode">++</span> <span class="inlinecode">[2]</span>, Coq wouldn't be able to figure out how to split the
    string on its own.)

<div class="paragraph"> </div>

    Using <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>, we can also show that certain strings do _not_
    match a regular expression: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>3</sub>"><span class="id" type="definition">reg_exp_ex<sub>3</sub></span></a> : ¬ ([1; 2] =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1).<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
We can define helper functions for writing down regular
    expressions. The <span class="inlinecode"><span class="id" type="var">reg_exp_of_list</span></span> function constructs a regular
    expression that matches exactly the list that it receives as an
    argument: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l'</span> ⇒ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">x</span>) (<a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>4</sub>"><span class="id" type="definition">reg_exp_ex<sub>4</sub></span></a> : [1; 2; 3] =~ <a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> [1; 2; 3].<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [1]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [2]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [3]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MEmpty"><span class="id" type="constructor">MEmpty</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
We can also prove general facts about <span class="inlinecode"><span class="id" type="var">exp_match</span></span>.  For instance,
    the following lemma shows that every string <span class="inlinecode"><span class="id" type="var">s</span></span> that matches <span class="inlinecode"><span class="id" type="var">re</span></span>
    also matches <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar1"><span class="id" type="lemma">MStar1</span></a> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> <span class="id" type="var">re</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Poly.html#app_nil_r"><span class="id" type="axiom">app_nil_r</span></a> <span class="id" type="var">_</span> <span class="id" type="var">s</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MStarApp"><span class="id" type="constructor">MStarApp</span></a> <span class="id" type="var">s</span> [] <span class="id" type="var">re</span>).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MStar0"><span class="id" type="constructor">MStar0</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
(Note the use of <span class="inlinecode"><span class="id" type="var">app_nil_r</span></span> to change the goal of the theorem to
    exactly the same shape expected by <span class="inlinecode"><span class="id" type="var">MStarApp</span></span>.) 
<div class="paragraph"> </div>

<a name="lab220"></a><h4 class="section">Exercise: 3 stars (exp_match_ex<sub>1</sub>)</h4>
 The following lemmas show that the informal matching rules given
    at the beginning of the chapter can be obtained from the formal
    inductive definition. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="empty_is_empty"><span class="id" type="lemma">empty_is_empty</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;¬ (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="MUnion'"><span class="id" type="lemma">MUnion'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ∨ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
The next lemma is stated in terms of the <span class="inlinecode"><span class="id" type="var">fold</span></span> function from the
    <a href="Poly.html"><span class="inlineref">Poly</span></a> chapter: If <span class="inlinecode"><span class="id" type="var">ss</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode">(<span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">T</span>)</span> represents a sequence of
    strings <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" type="var">sn</span></span>, then <span class="inlinecode"><span class="id" type="var">fold</span></span> <span class="inlinecode"><span class="id" type="var">app</span></span> <span class="inlinecode"><span class="id" type="var">ss</span></span> <span class="inlinecode">[]</span> is the result of
    concatenating them all together. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar'"><span class="id" type="lemma">MStar'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">ss</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>)) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;(<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> → <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> [] =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab221"></a><h4 class="section">Exercise: 4 stars, optional (reg_exp_of_list_spec)</h4>
 Prove that <span class="inlinecode"><span class="id" type="var">reg_exp_of_list</span></span> satisfies the following
    specification: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="reg_exp_of_list_spec"><span class="id" type="lemma">reg_exp_of_list_spec</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ↔ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> = <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 Since the definition of <span class="inlinecode"><span class="id" type="var">exp_match</span></span> has a recursive
    structure, we might expect that proofs involving regular
    expressions will often require induction on evidence. 
<div class="paragraph"> </div>

 For example, suppose that we wanted to prove the following
    intuitive result: If a regular expression <span class="inlinecode"><span class="id" type="var">re</span></span> matches some string
    <span class="inlinecode"><span class="id" type="var">s</span></span>, then all elements of <span class="inlinecode"><span class="id" type="var">s</span></span> must occur as character literals
    somewhere in <span class="inlinecode"><span class="id" type="var">re</span></span>.

<div class="paragraph"> </div>

    To state this theorem, we first define a function <span class="inlinecode"><span class="id" type="var">re_chars</span></span> that
    lists all characters that occur in a regular expression: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="re_chars"><span class="id" type="definition">re_chars</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a> ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">x</span> ⇒ [<span class="id" type="var">x</span>]<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>1</sub></span> ++ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>1</sub></span> ++ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">re</span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We can then phrase our theorem as follows: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="in_re_match"><span class="id" type="lemma">in_re_match</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> <span class="id" type="var">re</span> <span class="id" type="var">x</span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hmatch</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [| <span class="id" type="var">x'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span> | <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">re</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a> <span class="id" type="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hin</span> | <span class="id" type="var">Hin</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>1</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>2</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>2</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH</span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH</span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span>.<br/>
</div>

<div class="doc">
Something interesting happens in the <span class="inlinecode"><span class="id" type="var">MStarApp</span></span> case.  We obtain
    _two_ induction hypotheses: One that applies when <span class="inlinecode"><span class="id" type="var">x</span></span> occurs in
    <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> (which matches <span class="inlinecode"><span class="id" type="var">re</span></span>), and a second one that applies when <span class="inlinecode"><span class="id" type="var">x</span></span>
    occurs in <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> (which matches <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>).  This is a good
    illustration of why we need induction on evidence for <span class="inlinecode"><span class="id" type="var">exp_match</span></span>,
    as opposed to <span class="inlinecode"><span class="id" type="var">re</span></span>: The latter would only provide an induction
    hypothesis for strings that match <span class="inlinecode"><span class="id" type="var">re</span></span>, which would not allow us
    to reason about the case <span class="inlinecode"><span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hin</span> | <span class="id" type="var">Hin</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>1</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>2</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>2</sub></span> <span class="id" type="var">Hin</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab222"></a><h4 class="section">Exercise: 4 stars (re_not_empty)</h4>
 Write a recursive function <span class="inlinecode"><span class="id" type="var">re_not_empty</span></span> that tests whether a
    regular expression matches some string. Prove that your function
    is correct. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="re_not_empty"><span class="id" type="definition">re_not_empty</span></a> {<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="re_not_empty_correct"><span class="id" type="lemma">re_not_empty_correct</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;(<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) ↔ <a class="idref" href="IndProp.html#re_not_empty"><span class="id" type="axiom">re_not_empty</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab223"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="var">remember</span></span> Tactic</h2>

<div class="paragraph"> </div>

 One potentially confusing feature of the <span class="inlinecode"><span class="id" type="tactic">induction</span></span> tactic is
    that it happily lets you try to set up an induction over a term
    that isn't sufficiently general.  The effect of this is to lose
    information (much as <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> can do), and leave you unable to
    complete the proof.  Here's an example: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
</div>

<div class="doc">
Just doing an <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> on <span class="inlinecode"><span class="id" type="var">H<sub>1</sub></span></span> won't get us very far in
    the recursive cases. (Try it!). So we need induction (on
    evidence!). Here is a naive first attempt: 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span>|<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">re''</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re''</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
But now, although we get seven cases (as we would expect from the
    definition of <span class="inlinecode"><span class="id" type="var">exp_match</span></span>), we have lost a very important bit of
    information from <span class="inlinecode"><span class="id" type="var">H<sub>1</sub></span></span>: the fact that <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> matched something of the
    form <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>.  This means that we have to give proofs for _all_
    seven constructors of this definition, even though all but two of
    them (<span class="inlinecode"><span class="id" type="var">MStar0</span></span> and <span class="inlinecode"><span class="id" type="var">MStarApp</span></span>) are contradictory.  We can still
    get the proof to go through for a few constructors, such as
    <span class="inlinecode"><span class="id" type="var">MEmpty</span></span>... 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
</div>

<div class="doc">
... but most cases get stuck.  For <span class="inlinecode"><span class="id" type="var">MChar</span></span>, for instance, we
    must show that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">s<sub>2</sub></span>&nbsp;=~&nbsp;<span class="id" type="var">Char</span>&nbsp;<span class="id" type="var">x'</span>&nbsp;→&nbsp;<span class="id" type="var">x'</span>&nbsp;::&nbsp;<span class="id" type="var">s<sub>2</sub></span>&nbsp;=~&nbsp;<span class="id" type="var">Char</span>&nbsp;<span class="id" type="var">x'</span>,
<div class="paragraph"> </div>

</div>
    which is clearly impossible. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar.&nbsp;Stuck...&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
The problem is that <span class="inlinecode"><span class="id" type="tactic">induction</span></span> over a Prop hypothesis only works
    properly with hypotheses that are completely general, i.e., ones
    in which all the arguments are variables, as opposed to more
    complex expressions, such as <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>.

<div class="paragraph"> </div>

    (In this respect, <span class="inlinecode"><span class="id" type="tactic">induction</span></span> on evidence behaves more like
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> than like <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>.)

<div class="paragraph"> </div>

    We can solve this problem by generalizing over the problematic
    expressions with an explicit equality: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> <span class="id" type="var">re'</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a> = <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
</div>

<div class="doc">
We can now proceed by performing induction over evidence directly,
    because the argument to the first hypothesis is sufficiently
    general, which means that we can discharge most cases by inverting
    the <span class="inlinecode"><span class="id" type="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> equality in the context.

<div class="paragraph"> </div>

    This idiom is so common that Coq provides a tactic to
    automatically generate such equations for us, avoiding thus the
    need for changing the statements of our theorems. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
Invoking the tactic <span class="inlinecode"><span class="id" type="var">remember</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> causes Coq to (1) replace
    all occurrences of the expression <span class="inlinecode"><span class="id" type="var">e</span></span> by the variable <span class="inlinecode"><span class="id" type="var">x</span></span>, and (2)
    add an equation <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e</span></span> to the context.  Here's how we can use it
    to show the above result: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">re</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">re'</span>.<br/>
</div>

<div class="doc">
We now have <span class="inlinecode"><span class="id" type="var">Heqre'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span>|<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">re''</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re''</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">Heqre'</span></span> is contradictory in most cases, which allows us to
    conclude immediately. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span>  <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span>   <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MApp&nbsp;*)</span>    <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
</div>

<div class="doc">
The interesting cases are those that correspond to <span class="inlinecode"><span class="id" type="var">Star</span></span>.  Note
    that the induction hypothesis <span class="inlinecode"><span class="id" type="var">IH<sub>2</sub></span></span> on the <span class="inlinecode"><span class="id" type="var">MStarApp</span></span> case
    mentions an additional premise <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re''</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re'</span></span>, which
    results from the equality generated by <span class="inlinecode"><span class="id" type="var">remember</span></span>. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H<sub>0</sub></span> <span class="id" type="keyword">in</span> <span class="id" type="var">IH<sub>2</sub></span>, <span class="id" type="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">H<sub>1</sub></span>. <span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="Poly.html#app_assoc"><span class="id" type="axiom">app_assoc</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MStarApp"><span class="id" type="constructor">MStarApp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">IH<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab224"></a><h4 class="section">Exercise: 4 stars, optional (exp_match_ex<sub>2</sub>)</h4>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">MStar''</span></span> lemma below (combined with its converse, the
    <span class="inlinecode"><span class="id" type="var">MStar'</span></span> exercise above), shows that our definition of <span class="inlinecode"><span class="id" type="var">exp_match</span></span>
    for <span class="inlinecode"><span class="id" type="var">Star</span></span> is equivalent to the informal one given previously. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar''"><span class="id" type="lemma">MStar''</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">ss</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s'</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#s'"><span class="id" type="variable">s'</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> → <a class="idref" href="IndProp.html#s'"><span class="id" type="variable">s'</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab225"></a><h4 class="section">Exercise: 5 stars, advanced (pumping)</h4>
 One of the first really interesting theorems in the theory of
    regular expressions is the so-called _pumping lemma_, which
    states, informally, that any sufficiently long string <span class="inlinecode"><span class="id" type="var">s</span></span> matching
    a regular expression <span class="inlinecode"><span class="id" type="var">re</span></span> can be "pumped" by repeating some middle
    section of <span class="inlinecode"><span class="id" type="var">s</span></span> an arbitrary number of times to produce a new
    string also matching <span class="inlinecode"><span class="id" type="var">re</span></span>.

<div class="paragraph"> </div>

    To begin, we need to define "sufficiently long."  Since we are
    working in a constructive logic, we actually need to be able to
    calculate, for each regular expression <span class="inlinecode"><span class="id" type="var">re</span></span>, the minimum length
    for strings <span class="inlinecode"><span class="id" type="var">s</span></span> to guarantee "pumpability." 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Pumping"><span class="id" type="module">Pumping</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Fixpoint</span> <a name="Pumping.pumping_constant"><span class="id" type="definition">pumping_constant</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a> ⇒ 0<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ⇒ 1<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">_</span> ⇒ 2<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>1</sub></span> + <a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>1</sub></span> + <a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">_</span> ⇒ 1<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Next, it is useful to define an auxiliary function that repeats a
    string (appends it to itself) some number of times. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="Pumping.napp"><span class="id" type="definition">napp</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> ⇒ <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ++ <a class="idref" href="IndProp.html#napp"><span class="id" type="definition">napp</span></a> <span class="id" type="var">n'</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="Pumping.napp_plus"><span class="id" type="lemma">napp_plus</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ++ <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">l</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n</span> <span class="id" type="var">IHn</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHn</span>, <a class="idref" href="Poly.html#app_assoc"><span class="id" type="axiom">app_assoc</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Now, the pumping lemma itself says that, if <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re</span></span> and if the
    length of <span class="inlinecode"><span class="id" type="var">s</span></span> is at least the pumping constant of <span class="inlinecode"><span class="id" type="var">re</span></span>, then <span class="inlinecode"><span class="id" type="var">s</span></span>
    can be split into three substrings <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>3</sub></span></span> in such a way
    that <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> can be repeated any number of times and the result, when
    combined with <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">s<sub>3</sub></span></span> will still match <span class="inlinecode"><span class="id" type="var">re</span></span>.  Since <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> is
    also guaranteed not to be the empty string, this gives us
    a (constructive!) way to generate strings matching <span class="inlinecode"><span class="id" type="var">re</span></span> that are
    as long as we like. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="Pumping.pumping"><span class="id" type="lemma">pumping</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#Pumping.pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ≤ <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">s<sub>3</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>3</sub>"><span class="id" type="variable">s<sub>3</sub></span></a> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ≠ [] ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>3</sub>"><span class="id" type="variable">s<sub>3</sub></span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
</div>

<div class="doc">
To streamline the proof (which you are to fill in), the <span class="inlinecode"><span class="id" type="tactic">omega</span></span>
    tactic, which is enabled by the following <span class="inlinecode"><span class="id" type="keyword">Require</span></span>, is helpful in
    several places for automatically completing tedious low-level
    arguments involving equalities or inequalities over natural
    numbers.  We'll return to <span class="inlinecode"><span class="id" type="tactic">omega</span></span> in a later chapter, but feel
    free to experiment with it now if you like.  The first case of the
    induction gives an example of how it is used. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.omega.Omega</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">re</span> <span class="id" type="var">s</span> <span class="id" type="var">Hmatch</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hmatch</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [ | <span class="id" type="var">x</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span> | <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">re</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span> ].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#Pumping"><span class="id" type="module">Pumping</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab226"></a><h1 class="section">Case Study: Improving Reflection</h1>

<div class="paragraph"> </div>

 We've seen in the <a href="Logic.html"><span class="inlineref">Logic</span></a> chapter that we often need to
    relate boolean computations to statements in <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>.  But
    performing this conversion as we did it there can result in
    tedious proof scripts.  Consider the proof of the following
    theorem: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="filter_not_empty_In"><span class="id" type="lemma">filter_not_empty_In</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ≠ [] →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">m</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span class="id" type="var">eqn</span>:<span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;beq_nat&nbsp;n&nbsp;m&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;beq_nat&nbsp;n&nbsp;m&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
In the first branch after <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>, we explicitly apply
    the <span class="inlinecode"><span class="id" type="var">beq_nat_true_iff</span></span> lemma to the equation generated by
    destructing <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>, to convert the assumption <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>
    <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span> into the assumption <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>; then we had to <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>
    using this assumption to complete the case. 
<div class="paragraph"> </div>

 We can streamline this by defining an inductive proposition that
    yields a better case-analysis principle for <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>.
    Instead of generating an equation such as <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>,
    which is generally not directly useful, this principle gives us
    right away the assumption we really need: <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="reflect"><span class="id" type="inductive">reflect</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ReflectT"><span class="id" type="constructor">ReflectT</span></a> : <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
| <a name="ReflectF"><span class="id" type="constructor">ReflectF</span></a> : ¬ <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">reflect</span></span> property takes two arguments: a proposition
    <span class="inlinecode"><span class="id" type="var">P</span></span> and a boolean <span class="inlinecode"><span class="id" type="var">b</span></span>.  Intuitively, it states that the property
    <span class="inlinecode"><span class="id" type="var">P</span></span> is _reflected_ in (i.e., equivalent to) the boolean <span class="inlinecode"><span class="id" type="var">b</span></span>: that
    is, <span class="inlinecode"><span class="id" type="var">P</span></span> holds if and only if <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>.  To see this, notice
    that, by definition, the only way we can produce evidence that
    <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> holds is by showing that <span class="inlinecode"><span class="id" type="var">P</span></span> is true and using
    the <span class="inlinecode"><span class="id" type="var">ReflectT</span></span> constructor.  If we invert this statement, this
    means that it should be possible to extract evidence for <span class="inlinecode"><span class="id" type="var">P</span></span> from
    a proof of <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span>.  Conversely, the only way to show
    <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span> is by combining evidence for <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> with the
    <span class="inlinecode"><span class="id" type="var">ReflectF</span></span> constructor.

<div class="paragraph"> </div>

    It is easy to formalize this intuition and show that the two
    statements are indeed equivalent: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="iff_reflect"><span class="id" type="lemma">iff_reflect</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span>, (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ReflectT"><span class="id" type="constructor">ReflectT</span></a>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ReflectF"><span class="id" type="constructor">ReflectF</span></a>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab227"></a><h4 class="section">Exercise: 2 stars, recommended (reflect_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="reflect_iff"><span class="id" type="lemma">reflect_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 The advantage of <span class="inlinecode"><span class="id" type="var">reflect</span></span> over the normal "if and only if"
    connective is that, by destructing a hypothesis or lemma of the
    form <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span>, we can perform case analysis on <span class="inlinecode"><span class="id" type="var">b</span></span> while at
    the same time generating appropriate hypothesis in the two
    branches (<span class="inlinecode"><span class="id" type="var">P</span></span> in the first subgoal and <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> in the second). 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="beq_natP"><span class="id" type="lemma">beq_natP</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#iff_reflect"><span class="id" type="lemma">iff_reflect</span></a>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The new proof of <span class="inlinecode"><span class="id" type="var">filter_not_empty_In</span></span> now goes as follows.
    Notice how the calls to <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> and <span class="inlinecode"><span class="id" type="tactic">apply</span></span> are combined into a
    single call to <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. 
<div class="paragraph"> </div>

 (To see this clearly, look at the two proofs of
    <span class="inlinecode"><span class="id" type="var">filter_not_empty_In</span></span> with Coq and observe the differences in
    proof state at the beginning of the first case of the
    <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>.) 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="filter_not_empty_In'"><span class="id" type="lemma">filter_not_empty_In'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ≠ [] →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">m</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="IndProp.html#beq_natP"><span class="id" type="lemma">beq_natP</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab228"></a><h4 class="section">Exercise: 3 stars, recommended (beq_natP_practice)</h4>
 Use <span class="inlinecode"><span class="id" type="var">beq_natP</span></span> as above to prove the following: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="count"><span class="id" type="definition">count</span></a> <span class="id" type="var">n</span> <span class="id" type="var">l</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" type="var">m</span> :: <span class="id" type="var">l'</span> ⇒ (<span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="var">m</span> <span class="id" type="keyword">then</span> 1 <span class="id" type="keyword">else</span> 0) + <a class="idref" href="IndProp.html#count"><span class="id" type="definition">count</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="beq_natP_practice"><span class="id" type="lemma">beq_natP_practice</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#count"><span class="id" type="definition">count</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = 0 → ~(<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 In this small example, this technique gives us only a rather small
    gain in convenience for the proofs we've seen; however, using
    <span class="inlinecode"><span class="id" type="var">reflect</span></span> consistently often leads to noticeably shorter and
    clearer scripts as proofs get larger.  We'll see many more
    examples in later chapters and in _Programming Language
    Foundations_.

<div class="paragraph"> </div>

    The use of the <span class="inlinecode"><span class="id" type="var">reflect</span></span> property was popularized by _SSReflect_,
    a Coq library that has been used to formalize important results in
    mathematics, including as the 4-color theorem and the
    Feit-Thompson theorem.  The name SSReflect stands for _small-scale
    reflection_, i.e., the pervasive use of reflection to simplify
    small proof steps with boolean computations. 
</div>

<div class="doc">
<a name="lab229"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a name="lab230"></a><h4 class="section">Exercise: 3 stars, recommended (nostutter_defn)</h4>
 Formulating inductive definitions of properties is an important
    skill you'll need in this course.  Try to solve this exercise
    without any help at all.

<div class="paragraph"> </div>

    We say that a list "stutters" if it repeats the same element
    consecutively.  (This is different from the <span class="inlinecode"><span class="id" type="var">NoDup</span></span> property in 
    the exercise above: the sequence <span class="inlinecode">1;4;1</span> repeats but does not
    stutter.)  The property "<span class="inlinecode"><span class="id" type="var">nostutter</span></span> <span class="inlinecode"><span class="id" type="var">mylist</span></span>" means that
    <span class="inlinecode"><span class="id" type="var">mylist</span></span> does not stutter.  Formulate an inductive definition for
    <span class="inlinecode"><span class="id" type="var">nostutter</span></span>. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="nostutter"><span class="id" type="inductive">nostutter</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
.<br/>
</div>

<div class="doc">
Make sure each of these tests succeeds, but feel free to change
    the suggested proof (in comments) if the given one doesn't work
    for you.  Your definition might be different from ours and still
    be correct, in which case the examples might need a different
    proof.  (You'll notice that the suggested proofs use a number of
    tactics we haven't talked about, to make them more robust to
    different possible ways of defining <span class="inlinecode"><span class="id" type="var">nostutter</span></span>.  You can probably
    just uncomment and use them as-is, but you can also prove each
    example with more basic tactics.)  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="test_nostutter_1"><span class="id" type="definition">test_nostutter_1</span></a>: <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3;1;4;1;5;6].<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false_iff;&nbsp;auto.<br/>
&nbsp;&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_2"><span class="id" type="definition">test_nostutter_2</span></a>:  <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> (@<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false_iff;&nbsp;auto.<br/>
&nbsp;&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_3"><span class="id" type="definition">test_nostutter_3</span></a>:  <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [5].<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_4"><span class="id" type="definition">test_nostutter_4</span></a>:      <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> (<a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3;1;1;4]).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;intro.<br/>
&nbsp;&nbsp;repeat&nbsp;match&nbsp;goal&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;h:&nbsp;nostutter&nbsp;_&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;inversion&nbsp;h;&nbsp;clear&nbsp;h;&nbsp;subst<br/>
&nbsp;&nbsp;end.<br/>
&nbsp;&nbsp;contradiction&nbsp;H<sub>1</sub>;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab231"></a><h4 class="section">Exercise: 4 stars, advanced (filter_challenge)</h4>
 Let's prove that our definition of <span class="inlinecode"><span class="id" type="var">filter</span></span> from the <span class="inlinecode"><span class="id" type="var">Poly</span></span>
    chapter matches an abstract specification.  Here is the
    specification, written out informally in English:

<div class="paragraph"> </div>

    A list <span class="inlinecode"><span class="id" type="var">l</span></span> is an "in-order merge" of <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> if it contains
    all the same elements as <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>, in the same order as <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>
    and <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>, but possibly interleaved.  For example,

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;4;6;2;3]
<div class="paragraph"> </div>

</div>
    is an in-order merge of

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;6;2]
<div class="paragraph"> </div>

</div>
    and

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[4;3].
<div class="paragraph"> </div>

</div>
    Now, suppose we have a set <span class="inlinecode"><span class="id" type="var">X</span></span>, a function <span class="inlinecode"><span class="id" type="var">test</span>:</span> <span class="inlinecode"><span class="id" type="var">X</span>→<span class="id" type="var">bool</span></span>, and a
    list <span class="inlinecode"><span class="id" type="var">l</span></span> of type <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>.  Suppose further that <span class="inlinecode"><span class="id" type="var">l</span></span> is an
    in-order merge of two lists, <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>, such that every item
    in <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> satisfies <span class="inlinecode"><span class="id" type="var">test</span></span> and no item in <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> satisfies test.  Then
    <span class="inlinecode"><span class="id" type="var">filter</span></span> <span class="inlinecode"><span class="id" type="var">test</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>.

<div class="paragraph"> </div>

    Translate this specification into a Coq theorem and prove
    it.  (You'll need to begin by defining what it means for one list
    to be a merge of two others.  Do this with an inductive relation,
    not a <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>.)  
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab232"></a><h4 class="section">Exercise: 5 stars, advanced, optional (filter_challenge_2)</h4>
 A different way to characterize the behavior of <span class="inlinecode"><span class="id" type="var">filter</span></span> goes like
    this: Among all subsequences of <span class="inlinecode"><span class="id" type="var">l</span></span> with the property that <span class="inlinecode"><span class="id" type="var">test</span></span>
    evaluates to <span class="inlinecode"><span class="id" type="var">true</span></span> on all their members, <span class="inlinecode"><span class="id" type="var">filter</span></span> <span class="inlinecode"><span class="id" type="var">test</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> is the
    longest.  Formalize this claim and prove it. 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab233"></a><h4 class="section">Exercise: 4 stars, optional (palindromes)</h4>
 A palindrome is a sequence that reads the same backwards as
    forwards.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Define an inductive proposition <span class="inlinecode"><span class="id" type="var">pal</span></span> on <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> that
      captures what it means to be a palindrome. (Hint: You'll need
      three cases.  Your definition should be based on the structure
      of the list; just having a single constructor like

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">c</span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>
<div class="paragraph"> </div>

</div>
      may seem obvious, but will not work very well.)

<div class="paragraph"> </div>


</li>
<li> Prove (<span class="inlinecode"><span class="id" type="var">pal_app_rev</span></span>) that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;++&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>).
<div class="paragraph"> </div>

</div>

</li>
<li> Prove (<span class="inlinecode"><span class="id" type="var">pal_rev</span></span> that)

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</li>
</ul>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab234"></a><h4 class="section">Exercise: 5 stars, optional (palindrome_converse)</h4>
 Again, the converse direction is significantly more difficult, due
    to the lack of evidence.  Using your definition of <span class="inlinecode"><span class="id" type="var">pal</span></span> from the
    previous exercise, prove that

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab235"></a><h4 class="section">Exercise: 4 stars, advanced, optional (NoDup)</h4>
 Recall the definition of the <span class="inlinecode"><span class="id" type="var">In</span></span> property from the <span class="inlinecode"><span class="id" type="var">Logic</span></span>
    chapter, which asserts that a value <span class="inlinecode"><span class="id" type="var">x</span></span> appears at least once in a
    list <span class="inlinecode"><span class="id" type="var">l</span></span>: 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;Fixpoint&nbsp;In&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;match&nbsp;l&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;<span class="inlinecode"></span>&nbsp;=&gt;&nbsp;False<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;x'&nbsp;::&nbsp;l'&nbsp;=&gt;&nbsp;x'&nbsp;=&nbsp;x&nbsp;\/&nbsp;In&nbsp;A&nbsp;x&nbsp;l'<br/>
&nbsp;&nbsp;&nbsp;end&nbsp;*)</span><br/>
</div>

<div class="doc">
Your first task is to use <span class="inlinecode"><span class="id" type="var">In</span></span> to define a proposition <span class="inlinecode"><span class="id" type="var">disjoint</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>
    <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>, which should be provable exactly when <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> and <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> are
    lists (with elements of type X) that have no elements in
    common. 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<div class="doc">
Next, use <span class="inlinecode"><span class="id" type="var">In</span></span> to define an inductive proposition <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span>
    <span class="inlinecode"><span class="id" type="var">l</span></span>, which should be provable exactly when <span class="inlinecode"><span class="id" type="var">l</span></span> is a list (with
    elements of type <span class="inlinecode"><span class="id" type="var">X</span></span>) where every member is different from every
    other.  For example, <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">[1;2;3;4]</span> and <span class="inlinecode"><span class="id" type="var">NoDup</span></span>
    <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[]</span> should be provable, while <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">[1;2;1]</span> and
    <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[<span class="id" type="var">true</span>;<span class="id" type="var">true</span>]</span> should not be.  
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<div class="doc">
Finally, state and prove one or more interesting theorems relating
    <span class="inlinecode"><span class="id" type="var">disjoint</span></span>, <span class="inlinecode"><span class="id" type="var">NoDup</span></span> and <span class="inlinecode">++</span> (list append).  
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab236"></a><h4 class="section">Exercise: 4 stars, advanced, optional (pigeonhole_principle)</h4>
 The _pigeonhole principle_ states a basic fact about counting: if
    we distribute more than <span class="inlinecode"><span class="id" type="var">n</span></span> items into <span class="inlinecode"><span class="id" type="var">n</span></span> pigeonholes, some
    pigeonhole must contain at least two items.  As often happens, this
    apparently trivial fact about numbers requires non-trivial
    machinery to prove, but we now have enough... 
<div class="paragraph"> </div>

 First prove an easy useful lemma. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="in_split"><span class="id" type="lemma">in_split</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span>:<a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>, <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> :: <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
Now define a property <span class="inlinecode"><span class="id" type="var">repeats</span></span> such that <span class="inlinecode"><span class="id" type="var">repeats</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> asserts
    that <span class="inlinecode"><span class="id" type="var">l</span></span> contains at least one repeated element (of type <span class="inlinecode"><span class="id" type="var">X</span></span>).  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="repeats"><span class="id" type="inductive">repeats</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
.<br/>
</div>

<div class="doc">
Now, here's a way to formalize the pigeonhole principle.  Suppose
    list <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> represents a list of pigeonhole labels, and list <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>
    represents the labels assigned to a list of items.  If there are
    more items than labels, at least two items must have the same
    label &mdash; i.e., list <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> must contain repeats.

<div class="paragraph"> </div>

    This proof is much easier if you use the <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>
    hypothesis to show that <span class="inlinecode"><span class="id" type="var">In</span></span> is decidable, i.e., <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">l</span>,</span> <span class="inlinecode">(<span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>
    <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">∨</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span>.  However, it is also possible to make the proof
    go through _without_ assuming that <span class="inlinecode"><span class="id" type="var">In</span></span> is decidable; if you
    manage to do this, you will not need the <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span>
    hypothesis. 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="pigeonhole_principle"><span class="id" type="lemma">pigeonhole_principle</span></a>: <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l<sub>1</sub></span>  <span class="id" type="var">l<sub>2</sub></span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a> →<br/>
&nbsp;&nbsp;&nbsp;(<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> → <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>) →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a> &lt; <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#repeats"><span class="id" type="inductive">repeats</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">l<sub>1</sub></span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">x</span> <span class="id" type="var">l<sub>1</sub>'</span> <span class="id" type="var">IHl1'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab237"></a><h2 class="section">Extended Exercise: A Verified Regular-Expression Matcher</h2>

<div class="paragraph"> </div>

 We have now defined a match relation over regular expressions and
    polymorphic lists. We can use such a definition to manually prove that
    a given regex matches a given string, but it does not give us a
    program that we can run to determine a match autmatically.

<div class="paragraph"> </div>

    It would be reasonable to hope that we can translate the definitions
    of the inductive rules for constructing evidence of the match relation
    into cases of a recursive function reflects the relation by recursing
    on a given regex. However, it does not seem straightforward to define
    such a function in which the given regex is a recursion variable
    recognized by Coq. As a result, Coq will not accept that the function
    always terminates.

<div class="paragraph"> </div>

    Heavily-optimized regex matchers match a regex by translating a given
    regex into a state machine and determining if the state machine
    accepts a given string. However, regex matching can also be
    implemented using an algorithm that operates purely on strings and
    regexes without defining and maintaining additional datatypes, such as
    state machines. We'll implemement such an algorithm, and verify that
    its value reflects the match relation. 
<div class="paragraph"> </div>

 We will implement a regex matcher that matches strings represeneted
    as lists of ASCII characters: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#"><span class="id" type="library">Coq.Strings.Ascii</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="string"><span class="id" type="definition">string</span></a> := <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>.<br/>
</div>

<div class="doc">
The Coq standard library contains a distinct inductive definition
    of strings of ASCII characters. However, we will use the above
    definition of strings as lists as ASCII characters in order to apply
    the existing definition of the match relation.

<div class="paragraph"> </div>

    We could also define a regex matcher over polymorphic lists, not lists
    of ASCII characters specifically. The matching algorithm that we will
    implement needs to be able to test equality of elements in a given
    list, and thus needs to be given an equality-testing
    function. Generalizing the definitions, theorems, and proofs that we
    define for such a setting is a bit tedious, but workable. 
<div class="paragraph"> </div>

 The proof of correctness of the regex matcher will combine
    properties of the regex-matching function with properties of the
    <span class="inlinecode"><span class="id" type="keyword">match</span></span> relation that do not depend on the matching function. We'll go
    ahead and prove the latter class of properties now. Most of them have
    straightforward proofs, which have been given to you, although there
    are a few key lemmas that are left for you to prove. 
</div>

<div class="doc">
Each provable <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> is equivalent to <span class="inlinecode"><span class="id" type="var">True</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="provable_equiv_true"><span class="id" type="lemma">provable_equiv_true</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>), <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="var">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
Each <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> whose negation is provable is equivalent to <span class="inlinecode"><span class="id" type="var">False</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>), ¬<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>0</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptySet</span></span> matches no string. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="null_matches_none"><span class="id" type="lemma">null_matches_none</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>), (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>) ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> only matches the empty string. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="empty_matches_eps"><span class="id" type="lemma">empty_matches_eps</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>), <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = [ ].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MEmpty"><span class="id" type="constructor">MEmpty</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> matches no non-empty string. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="empty_nomatch_ne"><span class="id" type="lemma">empty_nomatch_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, (<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a>) ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> matches no string that starts with a non-<span class="inlinecode"><span class="id" type="var">a</span></span> character. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="char_nomatch_char"><span class="id" type="lemma">char_nomatch_char</span></a> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> <span class="id" type="var">b</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> ≠ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> → (<a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
If <span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> matches a non-empty string, then the string's tail is empty. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="char_eps_suffix"><span class="id" type="lemma">char_eps_suffix</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = [ ].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> matches string <span class="inlinecode"><span class="id" type="var">s</span></span> iff <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>, where <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span>
    matches <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> and <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="app_exists"><span class="id" type="lemma">app_exists</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>1</sub></span>, <span class="id" type="var">s<sub>2</sub></span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>3</sub></span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>4</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [ <span class="id" type="var">s<sub>0</sub></span> [ <span class="id" type="var">s<sub>1</sub></span> [ <span class="id" type="var">Happ</span> [ <span class="id" type="var">Hmat0</span> <span class="id" type="var">Hmat1</span> ] ] ] ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Happ</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">_</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">_</span> <span class="id" type="var">Hmat0</span> <span class="id" type="var">Hmat1</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab238"></a><h4 class="section">Exercise: 3 stars, optional (app_ne)</h4>
 <span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> iff <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> matches the empty string
    and <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> or <span class="inlinecode"><span class="id" type="var">s</span>=<span class="id" type="var">s<sub>0</sub></span>++<span class="id" type="var">s<sub>1</sub></span></span>, where <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s<sub>0</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span>
    and <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>.

<div class="paragraph"> </div>

    Even though this is a property of purely the match relation, it is a
    critical observation behind the design of our regex matcher. So (1)
    take time to understand it, (2) prove it, and (3) look for how you'll
    use it later. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="app_ne"><span class="id" type="lemma">app_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span> <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>) ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;([ ] =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>) ∨<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">s</span></span> matches <span class="inlinecode"><span class="id" type="var">Union</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> iff <span class="inlinecode"><span class="id" type="var">s</span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> or <span class="inlinecode"><span class="id" type="var">s</span></span> matches <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="union_disj"><span class="id" type="lemma">union_disj</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∨ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [ <span class="id" type="var">H</span> | <span class="id" type="var">H</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MUnionL"><span class="id" type="constructor">MUnionL</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MUnionR"><span class="id" type="constructor">MUnionR</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab239"></a><h4 class="section">Exercise: 3 stars, optional (star_ne)</h4>
 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> matches <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> iff <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>, where <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s<sub>0</sub></span></span> matches
    <span class="inlinecode"><span class="id" type="var">re</span></span> and <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> matches <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>. Like <span class="inlinecode"><span class="id" type="var">app_ne</span></span>, this observation is
    critical, so understand it, prove it, and keep it in mind.

<div class="paragraph"> </div>

    Hint: you'll need to perform induction. There are quite a few
    reasonable candidates for <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>'s to prove by induction. The only one
    that will work is splitting the <span class="inlinecode"><span class="id" type="var">iff</span></span> into two implications and
    proving one by induction on the evidence for <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>. The
    other implication can be proved without induction.

<div class="paragraph"> </div>

    In order to prove the right property by induction, you'll need to
    rephrase <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> to be a <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> over general variables,
    using the <span class="inlinecode"><span class="id" type="var">remember</span></span> tactic.  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_ne"><span class="id" type="lemma">star_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span> <span class="id" type="var">re</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 The definition of our regex matcher will include two fixpoint
    functions. The first function, given regex <span class="inlinecode"><span class="id" type="var">re</span></span>, will evaluate to a
    value that reflects whether <span class="inlinecode"><span class="id" type="var">re</span></span> matches the empty string. The
    function will satisfy the following property: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="refl_matches_eps"><span class="id" type="definition">refl_matches_eps</span></a> <span class="id" type="var">m</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> ([ ] =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab240"></a><h4 class="section">Exercise: 2 stars, optional (match_eps)</h4>
 Complete the definition of <span class="inlinecode"><span class="id" type="var">match_eps</span></span> so that it tests if a given
    regex matches the empty string: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="match_eps"><span class="id" type="definition">match_eps</span></a> (<span class="id" type="var">re</span>: @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab241"></a><h4 class="section">Exercise: 3 stars, optional (match_eps_refl)</h4>
 Now, prove that <span class="inlinecode"><span class="id" type="var">match_eps</span></span> indeed tests if a given regex matches
    the empty string.  (Hint: You'll want to use the reflection lemmas
    <span class="inlinecode"><span class="id" type="var">ReflectT</span></span> and <span class="inlinecode"><span class="id" type="var">ReflectF</span></span>.) 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="match_eps_refl"><span class="id" type="lemma">match_eps_refl</span></a> : <a class="idref" href="IndProp.html#refl_matches_eps"><span class="id" type="definition">refl_matches_eps</span></a> <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 We'll define other functions that use <span class="inlinecode"><span class="id" type="var">match_eps</span></span>. However, the
    only property of <span class="inlinecode"><span class="id" type="var">match_eps</span></span> that you'll need to use in all proofs
    over these functions is <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span>. 
</div>

<div class="doc">
The key operation that will be performed by our regex matcher will
    be to iteratively construct a sequence of regex derivatives. For each
    character <span class="inlinecode"><span class="id" type="var">a</span></span> and regex <span class="inlinecode"><span class="id" type="var">re</span></span>, the derivative of <span class="inlinecode"><span class="id" type="var">re</span></span> on <span class="inlinecode"><span class="id" type="var">a</span></span> is a regex
    that matches all suffixes of strings matched by <span class="inlinecode"><span class="id" type="var">re</span></span> that start with
    <span class="inlinecode"><span class="id" type="var">a</span></span>. I.e., <span class="inlinecode"><span class="id" type="var">re'</span></span> is a derivative of <span class="inlinecode"><span class="id" type="var">re</span></span> on <span class="inlinecode"><span class="id" type="var">a</span></span> if they satisfy the
    following relation: 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="is_der"><span class="id" type="definition">is_der</span></a> <span class="id" type="var">re</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">re'</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a>.<br/>
</div>

<div class="doc">
A function <span class="inlinecode"><span class="id" type="var">d</span></span> derives strings if, given character <span class="inlinecode"><span class="id" type="var">a</span></span> and regex
    <span class="inlinecode"><span class="id" type="var">re</span></span>, it evaluates to the derivative of <span class="inlinecode"><span class="id" type="var">re</span></span> on <span class="inlinecode"><span class="id" type="var">a</span></span>. I.e., <span class="inlinecode"><span class="id" type="var">d</span></span>
    satisfies the following property: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="derives"><span class="id" type="definition">derives</span></a> <span class="id" type="var">d</span> := <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">a</span> <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#is_der"><span class="id" type="definition">is_der</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="IndProp.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab242"></a><h4 class="section">Exercise: 3 stars, optional (derive)</h4>
 Define <span class="inlinecode"><span class="id" type="var">derive</span></span> so that it derives strings. One natural
    implementation uses <span class="inlinecode"><span class="id" type="var">match_eps</span></span> in some cases to determine if key
    regex's match the empty string. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="derive"><span class="id" type="definition">derive</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">derive</span></span> function should pass the following tests. Each test
    establishes an equality between an expression that will be
    evaluated by our regex matcher and the final value that must be
    returned by the regex matcher. Each test is annotated with the
    match fact that it reflects. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="c"><span class="id" type="definition">c</span></a> := <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii_of_nat"><span class="id" type="definition">ascii_of_nat</span></a> 99.<br/>
<span class="id" type="keyword">Example</span> <a name="d"><span class="id" type="definition">d</span></a> := <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii_of_nat"><span class="id" type="definition">ascii_of_nat</span></a> 100.<br/>
</div>

<div class="doc">
"c" =~ EmptySet: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der0"><span class="id" type="definition">test_der0</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>)) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Char c: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der1"><span class="id" type="definition">test_der1</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>)) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Char d: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der2"><span class="id" type="definition">test_der2</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>)) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ App (Char c) EmptyStr: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der3"><span class="id" type="definition">test_der3</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>) <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a>)) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ App EmptyStr (Char c): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der4"><span class="id" type="definition">test_der4</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Star c: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der5"><span class="id" type="definition">test_der5</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"cd" =~ App (Char c) (Char d): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der6"><span class="id" type="definition">test_der6</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>)))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"cd" =~ App (Char d) (Char c): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der7"><span class="id" type="definition">test_der7</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>)))) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a name="lab243"></a><h4 class="section">Exercise: 4 stars, optional (derive_corr)</h4>
 Prove that <span class="inlinecode"><span class="id" type="var">derive</span></span> in fact always derives strings.

<div class="paragraph"> </div>

    Hint: one proof performs induction on <span class="inlinecode"><span class="id" type="var">re</span></span>, although you'll need
    to carefully choose the property that you prove by induction by
    generalizing the appropriate terms.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" type="var">derive</span></span> applies <span class="inlinecode"><span class="id" type="var">match_eps</span></span> to a
    particular regex <span class="inlinecode"><span class="id" type="var">re</span></span>, then a natural proof will apply
    <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span> to <span class="inlinecode"><span class="id" type="var">re</span></span> and destruct the result to generate cases
    with assumptions that the <span class="inlinecode"><span class="id" type="var">re</span></span> does or does not match the empty
    string.

<div class="paragraph"> </div>

    Hint: You can save quite a bit of work by using lemmas proved
    above. In particular, to prove many cases of the induction, you
    can rewrite a <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> over a complicated regex (e.g., <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Union</span></span>
    <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>) to a Boolean combination of <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>'s over simple
    regex's (e.g., <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>) using lemmas given above
    that are logical equivalences. You can then reason about these
    <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>'s naturally using <span class="inlinecode"><span class="id" type="tactic">intro</span></span> and <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="derive_corr"><span class="id" type="lemma">derive_corr</span></a> : <a class="idref" href="IndProp.html#derives"><span class="id" type="definition">derives</span></a> <a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 We'll define the regex matcher using <span class="inlinecode"><span class="id" type="var">derive</span></span>. However, the only
    property of <span class="inlinecode"><span class="id" type="var">derive</span></span> that you'll need to use in all proofs of
    properties of the matcher is <span class="inlinecode"><span class="id" type="var">derive_corr</span></span>. 
</div>

<div class="doc">
A function <span class="inlinecode"><span class="id" type="var">m</span></span> matches regexes if, given string <span class="inlinecode"><span class="id" type="var">s</span></span> and regex <span class="inlinecode"><span class="id" type="var">re</span></span>,
    it evaluates to a value that reflects whether <span class="inlinecode"><span class="id" type="var">s</span></span> is matched by
    <span class="inlinecode"><span class="id" type="var">re</span></span>. I.e., <span class="inlinecode"><span class="id" type="var">m</span></span> holds the following property: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="matches_regex"><span class="id" type="definition">matches_regex</span></a> <span class="id" type="var">m</span> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab244"></a><h4 class="section">Exercise: 2 stars, optional (regex_match)</h4>
 Complete the definition of <span class="inlinecode"><span class="id" type="var">regex_match</span></span> so that it matches
    regexes. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="regex_match"><span class="id" type="definition">regex_match</span></a> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab245"></a><h4 class="section">Exercise: 3 stars, optional (regex_refl)</h4>
 Finally, prove that <span class="inlinecode"><span class="id" type="var">regex_match</span></span> in fact matches regexes.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" type="var">regex_match</span></span> applies <span class="inlinecode"><span class="id" type="var">match_eps</span></span> to
    regex <span class="inlinecode"><span class="id" type="var">re</span></span>, then a natural proof applies <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span> to <span class="inlinecode"><span class="id" type="var">re</span></span>
    and destructs the result to generate cases in which you may assume
    that <span class="inlinecode"><span class="id" type="var">re</span></span> does or does not match the empty string.

<div class="paragraph"> </div>

    Hint: if your definition of <span class="inlinecode"><span class="id" type="var">regex_match</span></span> applies <span class="inlinecode"><span class="id" type="var">derive</span></span> to
    character <span class="inlinecode"><span class="id" type="var">x</span></span> and regex <span class="inlinecode"><span class="id" type="var">re</span></span>, then a natural proof applies
    <span class="inlinecode"><span class="id" type="var">derive_corr</span></span> to <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">re</span></span> to prove that <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re</span></span> given
    <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">derive</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>, and vice versa. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <a name="regex_refl"><span class="id" type="lemma">regex_refl</span></a> : <a class="idref" href="IndProp.html#matches_regex"><span class="id" type="definition">matches_regex</span></a> <a class="idref" href="IndProp.html#regex_match"><span class="id" type="axiom">regex_match</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
</div>



</div>

</body>
</html>