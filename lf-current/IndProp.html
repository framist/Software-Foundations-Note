<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>IndProp: 归纳定义的命题</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 1: 逻辑基础</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>目录</li></a>
   <a href='coqindex.html'><li class='section_name'>索引</li></a>
   <a href='deps.html'><li class='section_name'>路线</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">IndProp<span class="subtitle">归纳定义的命题</span></h1>


<div class="code code-tight">

<span class="id" type="keyword">Set</span> <span class="id" type="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="Logic.html#"><span class="id" type="library">Logic</span></a>.<br/>
<span class="id" type="keyword">Require</span> <a class="idref" href="http://coq.inria.fr/library/Coq.omega.Omega.html#"><span class="id" type="library">Coq.omega.Omega</span></a>.<br/>
</div>

<div class="doc">
<a name="lab199"></a><h1 class="section">归纳定义的命题</h1>

<div class="paragraph"> </div>

 在 <a href="Logic.html"><span class="inlineref">Logic</span></a> 一章中，我们学习了多种方法来编写命题，包括合取、析取和量词。
    在本章中，我们引入新的方式：<b>归纳定义的命题（Inductive Definitions）</b>。 
<div class="paragraph"> </div>

 请回想一下我们已经学过的两种方法来表达数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 是偶数：
    (1) <span class="inlinecode"><span class="id" type="var">evenb</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>，以及 (2) <span class="inlinecode"><span style='font-size:120%;'>&exist;</span></span><span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span> 。
    然而另一种可能是通过如下规则来建立数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 的偶数性质：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 规则 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>:  数字 <span class="inlinecode">0</span> 是偶数。

</li>
<li> 规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>: 如果 <span class="inlinecode"><span class="id" type="var">n</span></span> 是偶数, 那么 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 是偶数。 
</li>
</ul>

<div class="paragraph"> </div>

 为了理解这样的偶数性质定义如何工作，我们可想象如何证明 <span class="inlinecode">4</span> 是偶数。
    根据规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>，需要证明 <span class="inlinecode">2</span> 是偶数。这时，只要证明 <span class="inlinecode">0</span> 是偶数，
    我们可继续通过规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 确保它成立。而规则 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 可直接证明 <span class="inlinecode">0</span> 是偶数。 
<div class="paragraph"> </div>

 接下来的课程中，我们会看到很多类似方式定义的命题。
    在非形式化的讨论中，使用轻量化的记法有助于阅读和书写。
    <b>推断规则（Inference Rules）</b> 是其中一种： 
<div class="paragraph"> </div>

<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;0</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;n</td>
  <td class="infrulenamecol" rowspan="3">
    (ev_SS) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">ev&nbsp;(S&nbsp;(S&nbsp;n))</td>
  <td></td>
</td>
</table></center>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    若将前文所述的规则重新排版成推断规则，我们可以这样阅读它，如果线上方的
    <b>前提（Premises）</b> 成立，那么线下方的 <b>结论（Conclusion）</b> 成立。
    比如，规则 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 是如果 <span class="inlinecode"><span class="id" type="var">n</span></span> 满足 <span class="inlinecode"><span class="id" type="var">ev</span></span>，那么 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 也满足。
    如果一条规则在线上方没有前提，则结论直接成立。

<div class="paragraph"> </div>

    我们可以通过组合推断规则来展示证明。下面展示如何转译 <span class="inlinecode">4</span> 是偶数的证明： 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;&nbsp;(<span class="id" type="var">ev_0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;(<span class="id" type="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;------&nbsp;(<span class="id" type="var">ev_SS</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ev</span>&nbsp;4
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

    为什么我们把这样的证明称之为“树”（而非其他，比如“栈”）？
    因为一般来说推断规则可以有多个前提。我们会在后面看到一些例子。 
<div class="paragraph"> </div>

 基于上述，可将偶数性质的定义翻译为Coq中使用 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明的定义，
    声明中每一个构造子对应一个推断规则： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="ev"><span class="id" type="inductive">ev</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ev_0"><span class="id" type="constructor">ev_0</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 0<br/>
| <a name="ev_SS"><span class="id" type="constructor">ev_SS</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
</div>

<div class="doc">
这个定义同之前其他 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 的使用有一个重要的区别：
    它的结果并不是一个 <span class="inlinecode"><span class="id" type="keyword">Type</span></span> ，而是一个将 <span class="inlinecode"><span class="id" type="var">nat</span></span> 映射到 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 的函数
    —— 即关于数的性质。
    注意我们曾见过其他的归纳定义结果为函数，比如 <span class="inlinecode"><span class="id" type="var">list</span></span> ，其类型是 <span class="inlinecode"><span class="id" type="keyword">Type</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span> 。
    值得注意的是，由于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 中出现在冒号 <b>右侧</b> 的 <span class="inlinecode"><span class="id" type="var">nat</span></span> 参数是 <b>未命名</b> 的，
    这允许在不同的构造子类型中使用不同的值：
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 类型中的 <span class="inlinecode">0</span> 以及 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 类型中的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span>。

<div class="paragraph"> </div>

    相反， <span class="inlinecode"><span class="id" type="var">list</span></span> 的定义以 <b>全局方式</b> 命名了冒号 <b>左侧</b> 的参数 <span class="inlinecode"><span class="id" type="var">X</span></span> ，
    强迫 <span class="inlinecode"><span class="id" type="var">nil</span></span> 和 <span class="inlinecode"><span class="id" type="var">cons</span></span> 的结果为同一个类型（ <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> ）。
    如果在定义 <span class="inlinecode"><span class="id" type="var">ev</span></span> 时我们将 <span class="inlinecode"><span class="id" type="var">nat</span></span> 置于冒号左侧，会得到如下错误： 
</div>
<div class="code code-tight">

<span class="id" type="var">Fail</span> <span class="id" type="keyword">Inductive</span> <a name="wrong_ev"><span class="id" type="inductive">wrong_ev</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) : <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="wrong_ev_0"><span class="id" type="constructor">wrong_ev_0</span></a> : <a class="idref" href="IndProp.html#wrong_ev"><span class="id" type="inductive">wrong_ev</span></a> 0<br/>
| <a name="wrong_ev_SS"><span class="id" type="constructor">wrong_ev_SS</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <span class="id" type="var">wrong_ev</span> <span class="id" type="var">n</span> → <span class="id" type="var">wrong_ev</span> (<span class="id" type="var">S</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;Error:&nbsp;A&nbsp;parameter&nbsp;of&nbsp;an&nbsp;inductive&nbsp;type&nbsp;n&nbsp;is&nbsp;not<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allowed&nbsp;to&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;bound&nbsp;variable&nbsp;in&nbsp;the&nbsp;type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;its&nbsp;constructor.&nbsp;*)</span><br/>
</div>

<div class="doc">
(“Parameter” 是 Coq 中的一个术语来表示 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 定义中冒号左侧的参数；
    “index” 则指冒号右侧的参数。) 
<div class="paragraph"> </div>

 在 Coq 中，我们可以认为 <span class="inlinecode"><span class="id" type="var">ev</span></span> 定义了一个性质 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>，其包括原始定理
    <span class="inlinecode"><span class="id" type="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span>。  
<div class="paragraph"> </div>

 这些 “定理构造子” 等同于被证明过的定理。
    特别的，我们可以使用 Coq 中的 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略和规则名称来证明某个
    数字的 <span class="inlinecode"><span class="id" type="var">ev</span></span> 性质…… 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4"><span class="id" type="lemma">ev_4</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
…… 或使用函数应用的语法： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4'"><span class="id" type="lemma">ev_4'</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)). <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们同样可以对前提中使用到 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的定理进行证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_plus4"><span class="id" type="lemma">ev_plus4</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">Hn</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">Hn</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
更一般地，我们可以证明以任意数字乘2是偶数： 
<div class="paragraph"> </div>

<a name="lab200"></a><h4 class="section">练习：1 星 (ev_double)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="ev_double"><span class="id" type="lemma">ev_double</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab201"></a><h1 class="section">在证明中使用证据</h1>

<div class="paragraph"> </div>

 除了 <b>构造</b> 证据（evidence）来表示某个数字是偶数，我们还可以对这些证据进行 <b>推理</b>。

<div class="paragraph"> </div>

    使用 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明来引入 <span class="inlinecode"><span class="id" type="var">ev</span></span> 不仅仅表示在 Coq 中 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 和 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span>
    这样的构造子是合法的方式来构造偶数证明的证据，他们也是 <b>仅有的</b> 方式
    （对 <span class="inlinecode"><span class="id" type="var">ev</span></span> 而言）。 
<div class="paragraph"> </div>

 换句话说，如果某人展示了对于 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 的证据 <span class="inlinecode"><span class="id" type="var">E</span></span>，那么我们知道 <span class="inlinecode"><span class="id" type="var">E</span></span>
    必是二者其一：

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">E</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> （且 <span class="inlinecode"><span class="id" type="var">n</span></span> is <span class="inlinecode"><span class="id" type="var">O</span></span>）, 或

</li>
<li> <span class="inlinecode"><span class="id" type="var">E</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span> （且 <span class="inlinecode"><span class="id" type="var">n</span></span> 是 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span>, <span class="inlinecode"><span class="id" type="var">E'</span></span> 是
        <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据）. 
</li>
</ul>

<div class="paragraph"> </div>

 这样的形式暗示着，我们可以像分析归纳定义的数据结构一样分析他们；
    特别的，对于这类证据使用 <b>归纳</b> 和 <b>分类讨论</b> 来进行论证也是可行的。
    让我们通过一些例子来看看在实践中这意味着什么。 
<div class="paragraph"> </div>

<a name="lab202"></a><h2 class="section">对证据进行反演</h2>

<div class="paragraph"> </div>

 假设我们正在证明涉及数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 的某个性质，且给定 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 作为前提。
    我们已经知道对 <span class="inlinecode"><span class="id" type="var">n</span></span> 使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略可对 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span>
    进行分类讨论，同时 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会生成子目标。但对于一些证明，我们想
    <b>直接</b> 对证据 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> 进行分析：

<div class="paragraph"> </div>

    根据 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的定义，有两种情况需要考虑：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果证据形如 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>，那么可得 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。

<div class="paragraph"> </div>


</li>
<li> 否则，证据必然形如 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>，其中 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> 且
      <span class="inlinecode"><span class="id" type="var">E'</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据。 
</li>
</ul>

<div class="paragraph"> </div>

 在 Coq 中进行此类推理，我们也可以使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略。
    除了可对涉及到构造子的等式进行推理，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 对归纳定义的命题
    提供了分类讨论的原则。当以此种方式使用它时，语法与 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 类似：
    我们需提供一个由 <span class="inlinecode">|</span> 分隔的标识符列表来命名构造子中的参数。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_minus2"><span class="id" type="lemma">ev_minus2</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在这个证明中反演推理的工作方式如下：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果证据形如 <span class="inlinecode"><span class="id" type="var">ev_0</span></span>，那么我们可得 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>。
      因此，需要证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">0))</span> 成立。
      根据 <span class="inlinecode"><span class="id" type="var">pred</span></span> 的定义，这等同于证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span>，即可从 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 直接得证。

<div class="paragraph"> </div>


</li>
<li> 否则，证据必然形如 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>，其中 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> 且 <span class="inlinecode"><span class="id" type="var">E'</span></span> 是
      <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 的证据。我们需要证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">pred</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>))))</span> 成立，
      在简化后，可从 <span class="inlinecode"><span class="id" type="var">E'</span></span> 得证。 
</li>
</ul>

<div class="paragraph"> </div>

 如果我们把 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 替换为 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>，这个证明同样工作： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_minus2'"><span class="id" type="lemma">ev_minus2'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#pred"><span class="id" type="abbreviation">pred</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
将一个由归纳性质（inductive property）构成的假设作用于复杂的表达式
    （而非一个变量）时， 使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会比 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 更加方便。
    这里有一个具体的例子。假设我们想要证明 <span class="inlinecode"><span class="id" type="var">ev_minus2</span></span> 的变种： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="evSS_ev"><span class="id" type="lemma">evSS_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
</div>

<div class="doc">
直观来说，我们知道支撑前提的证据不会由 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> 组成，因为 <span class="inlinecode">0</span> 和 <span class="inlinecode"><span class="id" type="var">S</span></span> 是
    <span class="inlinecode"><span class="id" type="var">nat</span></span> 类型不同的构造子；由此 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 是唯一需要应对的情况（译注：<span class="inlinecode"><span class="id" type="var">ev_0</span></span> 无条件成立）。
    不幸的是，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 并没有如此智能，它仍然为我们生成两个子目标。
    更甚至，于此同时最终目标没有改变，也无法为完成证明提供任何有用的信息。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;我们须证明&nbsp;<span class="inlinecode"><span class="id" type="var">n</span></span>&nbsp;是偶数，但没有任何有用的假设信息可以使用！&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
究竟发生了什么？ 应用 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 把性质的参数替换为对应于构造子的值。
    这对于证明 <span class="inlinecode"><span class="id" type="var">ev_minus2'</span></span> 是有帮助的，因为在最终目标中直接使用到了参数 <span class="inlinecode"><span class="id" type="var">n</span></span>。
    然而，这对于 <span class="inlinecode"><span class="id" type="var">evSS_ev</span></span> 并没有帮助，因为被替换掉的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 并没有在其他地方被使用。
<div class="paragraph"> </div>

 另一方面，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略可以检测到（1）第一个分类是不适用的（译注：<span class="inlinecode"><span class="id" type="var">ev_0</span></span>），
    以及（2）出现在 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 中的 <span class="inlinecode"><span class="id" type="var">n'</span></span> 必等同于 <span class="inlinecode"><span class="id" type="var">n</span></span>。
    这帮助我们完成了证明： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="evSS_ev"><span class="id" type="lemma">evSS_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;We&nbsp;are&nbsp;in&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="var">E</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> <span class="inlinecode"><span class="id" type="var">E'</span></span>&nbsp;case&nbsp;now.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">E'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
通过 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，我们可以对“显然矛盾的”归纳性质假设应用爆炸原理（principle of explosion）。
    比如： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="one_not_even"><span class="id" type="lemma">one_not_even</span></a> : ¬ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 1.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab203"></a><h4 class="section">练习：1 星 (SSSSev__even)</h4>
 请使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略证明以下结果。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="SSSSev__even"><span class="id" type="lemma">SSSSev__even</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)))) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab204"></a><h4 class="section">练习：1 星 (even5_nonsense)</h4>
 请使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略证明以下结果。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="even5_nonsense"><span class="id" type="lemma">even5_nonsense</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 5 → 2 + 2 = 9.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 初看我们使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 的方式似乎有点难以理解。
    目前为止，我们只对相等性命题使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，以此来利用构造子的单射性
    或区分不同的构造子（TODO：injectivity翻译） 。
    但我们将要看到 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 也可以用于分析归纳定义命题的证据。

<div class="paragraph"> </div>

    一般来说 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 以这样的方式工作。设想在当前上下文中名称 <span class="inlinecode"><span class="id" type="var">I</span></span> 指向
    假设 <span class="inlinecode"><span class="id" type="var">P</span></span>，而<span class="inlinecode"><span class="id" type="var">P</span></span> 由一个 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 声明所定义。
    接下来，使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> <span class="inlinecode"><span class="id" type="var">I</span></span> 会对 <span class="inlinecode"><span class="id" type="var">P</span></span> 中的每一个构造子生成子目标，
    其中 <span class="inlinecode"><span class="id" type="var">I</span></span> 会被替换为在这个构造子中为了证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 所需要满足的精确条件。
    有些子目标是自相矛盾的，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会直接抛弃这些子目标。
    而为了证明最初的目标，剩下的情形必须被证明。对于这些，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 会添加
    <span class="inlinecode"><span class="id" type="var">P</span></span> 成立所需要的等式到证明的上下文中。（比如 <span class="inlinecode"><span class="id" type="var">evSS_ev</span></span> 证明中的 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">n</span></span>。） 
<div class="paragraph"> </div>

 上面的 <span class="inlinecode"><span class="id" type="var">ev_double</span></span> 练习展示了偶数性质的一种新记法，其被之前的两种记法所蕴含。
    （因为，由  <a href="Logic.html"><span class="inlineref">Logic</span></a> 一章中的 <span class="inlinecode"><span class="id" type="var">even_bool_prop</span></span>，我们已经知道
    他们是互相等价的。）
    为了展示这三种方式的一致性，我们需要下面的引理： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="ev_even_firsttry"><span class="id" type="lemma">ev_even_firsttry</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
</div>

<div class="doc">
我们可以尝试使用分类讨论或对 <span class="inlinecode"><span class="id" type="var">n</span></span> 进行归纳。
    但由于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 在前提中出现，如同之前章节的一些例子，这种策略或许无法行得通。
    如此我们似乎可以首先尝试对 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的证据进行反演。
    确实，第一个分类可以被平凡地证明。 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [| <span class="id" type="var">n'</span> <span class="id" type="var">E'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> 0. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'&nbsp;*)</span> <span class="id" type="tactic">simpl</span>.<br/>
</div>

<div class="doc">
不幸地是，第二个分类要困难一些。我们需要证明 <span class="inlinecode"><span style='font-size:120%;'>&exist;</span></span><span class="inlinecode"><span class="id" type="var">k</span>,</span> <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n'</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">double</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>，
    但唯一可用的假设是 <span class="inlinecode"><span class="id" type="var">E'</span></span>，也即 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n'</span></span> 成立。由于这并不直接有用，
    我们似乎被卡住了，而对 <span class="inlinecode"><span class="id" type="var">E</span></span> 进行分类讨论是徒劳的。

<div class="paragraph"> </div>

    如果仔细观察第二个（子）目标，我们可以看到一些有意思的事情：
    对 <span class="inlinecode"><span class="id" type="var">E</span></span> 进行分类讨论，我们可以把要证明的原始结果归约到另一个上，
    其涉及到一个不同 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的证据： <span class="inlinecode"><span class="id" type="var">E'</span></span>。
    形式化地说，我们可以完成证明通过展示：

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span>&nbsp;<span class="id" type="var">k'</span>,&nbsp;<span class="id" type="var">n'</span>&nbsp;=&nbsp;<span class="id" type="var">double</span>&nbsp;<span class="id" type="var">k'</span>,
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

    这同原始的命题是一致的，只是 <span class="inlinecode"><span class="id" type="var">n'</span></span> 被替换为 n。确实，通过这个中间结果完成证明
    并不困难。  
</div>
<div class="code code-tight">

&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">I</span> : (<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k'</span>, <span class="id" type="var">n'</span> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k'"><span class="id" type="variable">k'</span></a>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span>) = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="tactic">intros</span> [<span class="id" type="var">k'</span> <span class="id" type="var">Hk'</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk'</span>. <span style='font-size:120%;'>&exist;</span> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">k'</span>). <span class="id" type="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">I</span>. <span class="comment">(*&nbsp;将原始目标归约到新目标上&nbsp;*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a name="lab205"></a><h2 class="section">对证据进行归纳</h2>

<div class="paragraph"> </div>

 看起来很类似，但这并不是巧合：我们遇到了类似 <a href="Induction.html"><span class="inlineref">Induction</span></a> 章节中的问题，
    对于需要使用归纳来证明的命题我们使用了分类讨论。
    再一次地，解决方法是使用……归纳！

<div class="paragraph"> </div>

    对证据和对数据使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 的行为是相同的：它导致 Coq 对每个可用于构造证据的
    构造子生成一个子目标，同时对递归出现的问题命题提供了归纳假设。 
<div class="paragraph"> </div>

 让我们再次尝试证明这个引理： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="ev_even"><span class="id" type="lemma">ev_even</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">E</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">E</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n'</span> <span class="id" type="var">E'</span> <span class="id" type="var">IH</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> 0. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;E&nbsp;=&nbsp;ev_SS&nbsp;n'&nbsp;E'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时&nbsp;IH&nbsp;:&nbsp;exists&nbsp;k',&nbsp;n'&nbsp;=&nbsp;double&nbsp;k'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">IH</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">k'</span> <span class="id" type="var">Hk'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk'</span>. <span style='font-size:120%;'>&exist;</span> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">k'</span>). <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这里我们看到 Coq 对 <span class="inlinecode"><span class="id" type="var">E'</span></span> 产生了 <span class="inlinecode"><span class="id" type="var">IH</span></span>，而 <span class="inlinecode"><span class="id" type="var">E'</span></span> 是唯一递归出现的
    <span class="inlinecode"><span class="id" type="var">ev</span></span> 命题。 由于 <span class="inlinecode"><span class="id" type="var">E'</span></span> 中涉及到 <span class="inlinecode"><span class="id" type="var">n'</span></span>，这个归纳假设是关于 <span class="inlinecode"><span class="id" type="var">n'</span></span> 的，
    而非关于 <span class="inlinecode"><span class="id" type="var">n</span></span> 或其他数字的。  
<div class="paragraph"> </div>

 关于偶数性质的第二个和第三个定义的等价性如下： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_even_iff"><span class="id" type="lemma">ev_even_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ↔ <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">k</span>, <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="Induction.html#double"><span class="id" type="definition">double</span></a> <a class="idref" href="IndProp.html#k"><span class="id" type="variable">k</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;-&gt;&nbsp;*)</span> <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_even"><span class="id" type="lemma">ev_even</span></a>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;&lt;-&nbsp;*)</span> <span class="id" type="tactic">intros</span> [<span class="id" type="var">k</span> <span class="id" type="var">Hk</span>]. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">Hk</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_double"><span class="id" type="axiom">ev_double</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
我们会在后面的章节中看到，对证据进行归纳在很多领域里是一种常用的技术，
    特别是在形式化程序语言的语义时，由于其中很多有趣的性质都是归纳定义的。 
<div class="paragraph"> </div>

 下面的练习提供了一些简单的例子，来帮助你熟悉这项技术。 
<div class="paragraph"> </div>

<a name="lab206"></a><h4 class="section">练习：2 星 (ev_sum)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="ev_sum"><span class="id" type="lemma">ev_sum</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab207"></a><h4 class="section">练习：4 星, advanced, optional (ev</b>ev)</h4>
 一般来说，有很多种方式来归纳地定义一个性质。比如说，下面是关于 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的另一种（蹩脚的）定义：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="ev'"><span class="id" type="inductive">ev'</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ev'_0"><span class="id" type="constructor">ev'_0</span></a> : <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> 0<br/>
| <a name="ev'_2"><span class="id" type="constructor">ev'_2</span></a> : <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> 2<br/>
| <a name="ev'_sum"><span class="id" type="constructor">ev'_sum</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
</div>

<div class="doc">
请证明这个定义在逻辑上等同于前述定义。（当进入到归纳环节时，你可能会想参考一下上一个定理。）
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev'_ev"><span class="id" type="lemma">ev'_ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev'"><span class="id" type="inductive">ev'</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ↔ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab208"></a><h4 class="section">练习：3 星, advanced, recommended (ev_ev__ev)</h4>
 在本题中找到合适的项进行归纳需要一点技巧： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_ev__ev"><span class="id" type="lemma">ev_ev__ev</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab209"></a><h4 class="section">练习：3 星, optional (ev_plus_plus)</h4>
 这个练习仅仅需要使用前述引理。不需要使用归纳和分类讨论，尽管一些重写可能会比较乏味。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_plus_plus"><span class="id" type="lemma">ev_plus_plus</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">p</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>+<a class="idref" href="IndProp.html#p"><span class="id" type="variable">p</span></a>) → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>+<a class="idref" href="IndProp.html#p"><span class="id" type="variable">p</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab210"></a><h1 class="section">归纳关系</h1>

<div class="paragraph"> </div>

 我们可以认为由数字参数化的命题（比如 <span class="inlinecode"><span class="id" type="var">ev</span></span>）是一个<b>性质</b>，也即，
    它定义了 <span class="inlinecode"><span class="id" type="var">nat</span></span>　的一个子集，其中的数字可以被证明满足此命题。
    以同样的方式，我们可认为有两个参数的命题是一个<b>关系</b>，也即，它定义了一个
    序对的集合可满足此命题。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Playground"><span class="id" type="module">Playground</span></a>.<br/>
</div>

<div class="doc">
一个很有用的例子是数字的“小于等于”关系。
<div class="paragraph"> </div>

　下面的定义应当是比较直观的。它提供了两种方法来描述一个数字小于等于另一个数字的证据：
    要么可观察到两个数字相等，或提供证据显示第一个数字小于等于第二个数字的前继。　
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="Playground.le"><span class="id" type="inductive">le</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Playground.le_n"><span class="id" type="constructor">le_n</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a><br/>
&nbsp;&nbsp;| <a name="Playground.le_S"><span class="id" type="constructor">le_S</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, (<a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) → (<a class="idref" href="IndProp.html#le"><span class="id" type="inductive">le</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>)).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "m ≤ n" := (<a class="idref" href="IndProp.html#Playground.le"><span class="id" type="inductive">le</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>
</div>

<div class="doc">
类似于证明 <span class="inlinecode"><span class="id" type="var">ev</span></span> 这样的性质，使用 <span class="inlinecode"><span class="id" type="var">le_n</span></span> 和 <span class="inlinecode"><span class="id" type="var">le_S</span></span>　构造子来证明关于 <span class="inlinecode">≤</span>
    的事实遵循了同样的模式。我们可以对构造子使用 <span class="inlinecode"><span class="id" type="tactic">apply</span></span> 策略来证明 <span class="inlinecode">≤</span> 目标
    （比如证明 <span class="inlinecode">3≤3</span> 或 <span class="inlinecode">3≤6</span>），也可以使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span> 策略来从上下文中 <span class="inlinecode">≤</span> 的
    假设里抽取信息（比如证明 <span class="inlinecode">(2≤1)</span> <span class="inlinecode">→</span> <span class="inlinecode">2+2=5</span>）。 
<div class="paragraph"> </div>

 这里提供一些完备性检查。（请注意，尽管这同我们在开始课程时编写的
    函数“单元测试”类似，但我们在这里必须明确地写下他们的证明—— <span class="inlinecode"><span class="id" type="tactic">simpl</span></span> 和
    <span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span> 并不会有效果，因为这些证明不仅仅是对表达式进行简化。）  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>1</sub>"><span class="id" type="lemma">test_le<sub>1</sub></span></a> :<br/>
&nbsp;&nbsp;3 ≤ 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>2</sub>"><span class="id" type="lemma">test_le<sub>2</sub></span></a> :<br/>
&nbsp;&nbsp;3 ≤ 6.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_S"><span class="id" type="constructor">le_S</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#Playground.le_n"><span class="id" type="constructor">le_n</span></a>. <span class="id" type="keyword">Qed</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Playground.test_le<sub>3</sub>"><span class="id" type="lemma">test_le<sub>3</sub></span></a> :<br/>
&nbsp;&nbsp;(2 ≤ 1) → 2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
现在“严格小于”关系 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" type="var">m</span></span> 可以使用 <span class="inlinecode"><span class="id" type="var">le</span></span> 来定义。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#Playground"><span class="id" type="module">Playground</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="lt"><span class="id" type="definition">lt</span></a> (<span class="id" type="var">n</span> <span class="id" type="var">m</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Peano.html#le"><span class="id" type="inductive">le</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "m &lt; n" := (<a class="idref" href="IndProp.html#lt"><span class="id" type="definition">lt</span></a> <span class="id" type="var">m</span> <span class="id" type="var">n</span>).<br/>
</div>

<div class="doc">
这里展示了一些定义于数字上的关系：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="square_of"><span class="id" type="inductive">square_of</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="sq"><span class="id" type="constructor">sq</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#square_of"><span class="id" type="inductive">square_of</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> * <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="next_nat"><span class="id" type="inductive">next_nat</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="nn"><span class="id" type="constructor">nn</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>:<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>, <a class="idref" href="IndProp.html#next_nat"><span class="id" type="inductive">next_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="next_even"><span class="id" type="inductive">next_even</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="ne_1"><span class="id" type="constructor">ne_1</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) → <a class="idref" href="IndProp.html#next_even"><span class="id" type="inductive">next_even</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)<br/>
&nbsp;&nbsp;| <a name="ne_2"><span class="id" type="constructor">ne_2</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)) → <a class="idref" href="IndProp.html#next_even"><span class="id" type="inductive">next_even</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>)).<br/>
</div>

<div class="doc">
<a name="lab211"></a><h4 class="section">练习：2 星, optional (total_relation)</h4>
 请定一个二元归纳关系 <span class="inlinecode"><span class="id" type="var">total_relation</span></span> 对每一个自然数序对成立。 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab212"></a><h4 class="section">练习：2 星, optional (empty_relation)</h4>
 请定一个二元归纳关系 <span class="inlinecode"><span class="id" type="var">empty_relation</span></span> 对自然数永远为假。 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab213"></a><h4 class="section">练习：3 星, optional (le_exercises)</h4>
 这里展示一些关于 <span class="inlinecode">≤</span> 和 <span class="inlinecode">&lt;</span> 关系的事实，我们在接下来的课程中将会用到他们。
    证明他们将会是非常有益的练习。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="le_trans"><span class="id" type="lemma">le_trans</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ≤ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ≤ <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="O_le_n"><span class="id" type="lemma">O_le_n</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>,<br/>
&nbsp;&nbsp;0 ≤ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="n_le_m__Sn_le_Sm"><span class="id" type="lemma">n_le_m__Sn_le_Sm</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="Sn_le_Sm__n_le_m"><span class="id" type="lemma">Sn_le_Sm__n_le_m</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="le_plus_l"><span class="id" type="lemma">le_plus_l</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">a</span> <span class="id" type="var">b</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ≤ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> + <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="plus_lt"><span class="id" type="lemma">plus_lt</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> + <a class="idref" href="IndProp.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n<sub>1</sub>"><span class="id" type="variable">n<sub>1</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> ∧ <a class="idref" href="IndProp.html#n<sub>2</sub>"><span class="id" type="variable">n<sub>2</sub></span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="IndProp.html#lt"><span class="id" type="definition">lt</span></a>.<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="lt_S"><span class="id" type="lemma">lt_S</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> &lt; <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> &lt; <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="leb_complete"><span class="id" type="lemma">leb_complete</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
提示：在下面的问题中，对 <span class="inlinecode"><span class="id" type="var">m</span></span> 进行归纳会使证明容易一些。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="leb_correct"><span class="id" type="lemma">leb_correct</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
提示：这个定理可以不通过使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 来证明。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="leb_true_trans"><span class="id" type="lemma">leb_true_trans</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">o</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> → <a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab214"></a><h4 class="section">练习：2 星, optional (leb_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="leb_iff"><span class="id" type="lemma">leb_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Basics.html#leb"><span class="id" type="definition">leb</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a> ↔ <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> ≤ <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="R"><span class="id" type="module">R</span></a>.<br/>
</div>

<div class="doc">
<a name="lab215"></a><h4 class="section">练习：3 星, recommended (R_provability)</h4>
 通过同样的方式，我们可以定义三元关系、四元关系等。例如，考虑以下定义在数字上的三元关系： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="R.R"><span class="id" type="inductive">R</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c1"><span class="id" type="constructor">c<sub>1</sub></span></a> : <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> 0 0 0<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c2"><span class="id" type="constructor">c<sub>2</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c3"><span class="id" type="constructor">c<sub>3</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)<br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c4"><span class="id" type="constructor">c<sub>4</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>)) → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a><br/>
&nbsp;&nbsp;&nbsp;| <a name="R.c5"><span class="id" type="constructor">c<sub>5</sub></span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> → <a class="idref" href="IndProp.html#R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<ul class="doclist">
<li> 下列哪个命题是可以被证明的？
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">1</span> <span class="inlinecode">2</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">2</span> <span class="inlinecode">6</span>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> 如果在 <span class="inlinecode"><span class="id" type="var">R</span></span> 的定义中我们丢弃 <span class="inlinecode"><span class="id" type="var">c<sub>5</sub></span></span> 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。

<div class="paragraph"> </div>


</li>
<li> 如果在 <span class="inlinecode"><span class="id" type="var">R</span></span> 的定义中我们丢弃 <span class="inlinecode"><span class="id" type="var">c<sub>4</sub></span></span> 构造子，可被证明的集合会发生变化吗？
      简要（一句话）解释你的答案。

</li>
</ul>

<div class="paragraph"> </div>

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>

</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="R.manual_grade_for_R_provability"><span class="id" type="definition">manual_grade_for_R_provability</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab216"></a><h4 class="section">练习：3 星, optional (R_fact)</h4>
 关系 <span class="inlinecode"><span class="id" type="var">R</span></span> 其实编码了一个熟悉的函数。请找出这个函数，定义它并在 Coq 中证明他们等价。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="R.fR"><span class="id" type="definition">fR</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="R.R_equiv_fR"><span class="id" type="lemma">R_equiv_fR</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span> <span class="id" type="var">n</span> <span class="id" type="var">o</span>, <a class="idref" href="IndProp.html#R.R"><span class="id" type="inductive">R</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a> ↔ <a class="idref" href="IndProp.html#R.fR"><span class="id" type="axiom">fR</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="IndProp.html#o"><span class="id" type="variable">o</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="code code-tight">

<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#R"><span class="id" type="module">R</span></a>.<br/>
</div>

<div class="doc">
<a name="lab217"></a><h4 class="section">练习：4 星, advanced (subsequence)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_subsequence"><span class="id" type="definition">manual_grade_for_subsequence</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<div class="doc">
如果一个列表的所有元素以相同的顺序出现在另一个列表之中（但允许其中出现其他额外的元素），
    我们把第一个列表称作第二个列表的<b>子序列</b>。 例如：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]
<div class="paragraph"> </div>

</div>
    是以下所有列表的子序列

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;1;1;2;2;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2;7;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5;6;1;9;9;2;7;3;8]
<div class="paragraph"> </div>

</div>
    但<b>不是</b>以下列表的子序列

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;2]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1;3]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5;6;2;1;7;3;8].
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

<ul class="doclist">
<li> 在 <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> 上定一个归纳命题 <span class="inlinecode"><span class="id" type="var">subseq</span></span>，其表达了子序列的涵义。
      （提示：你需要三个分类。）

<div class="paragraph"> </div>


</li>
<li> 证明子序列的自反关系 <span class="inlinecode"><span class="id" type="var">subseq_refl</span></span>，也即任何列表是它自身的子序列。

<div class="paragraph"> </div>


</li>
<li> 证明关系 <span class="inlinecode"><span class="id" type="var">subseq_app</span></span> 对任意列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>，<span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span>，如果 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>
      的子序列，那么 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 也是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列。

<div class="paragraph"> </div>


</li>
<li> （可选的，困难）证明子序列的传递关系 <span class="inlinecode"><span class="id" type="var">subseq_trans</span></span>——也即，如果 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>
      的子序列，且 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列，那么 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>3</sub></span></span> 的子序列。
      （提示：仔细选择进行归纳的项！） 
</li>
</ul>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab218"></a><h4 class="section">练习：2 星, optional (R_provability2)</h4>
 假设我们在 Coq 中有如下定义：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span>&nbsp;<span class="id" type="var">R</span>&nbsp;:&nbsp;<span class="id" type="var">nat</span>&nbsp;→&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">nat</span>&nbsp;→&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>1</sub></span>&nbsp;:&nbsp;<span class="id" type="var">R</span>&nbsp;0&nbsp;[]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>2</sub></span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;(<span class="id" type="var">n</span>&nbsp;::&nbsp;<span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">c<sub>3</sub></span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">R</span>&nbsp;(<span class="id" type="var">S</span>&nbsp;<span class="id" type="var">n</span>)&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">R</span>&nbsp;<span class="id" type="var">n</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>
    下列命题哪个是可被证明的？

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">2</span> <span class="inlinecode">[1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">1</span> <span class="inlinecode">[1;2;1;0]</span>

</li>
<li> <span class="inlinecode"><span class="id" type="var">R</span></span> <span class="inlinecode">6</span> <span class="inlinecode">[3;2;1;0]</span>  
</li>
</ul>

<div class="paragraph"> </div>

 <span class="proofbox">&#9744;</span> 
</div>

<div class="doc">
<a name="lab219"></a><h1 class="section">案例学习：正则表达式</h1>

<div class="paragraph"> </div>

 性质 <span class="inlinecode"><span class="id" type="var">ev</span></span> 提供了一个简单的例子来展示归纳定义和基础推理技巧，
    但这还不是什么激动人心的东西－－毕竟，<span class="inlinecode"><span class="id" type="var">ev</span></span> 等价于我们之前见过的两个非归纳的定义，
    而看起来归纳定义并没有提供什么好处。为了更好地展示归纳定义的表达能力，
    我们继续使用它来建模计算机科学中的一个经典概念－－正则表达式。 
<div class="paragraph"> </div>

 正则表达式是用来描述字符串的一种简单语言，定义如下： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="reg_exp"><span class="id" type="inductive">reg_exp</span></a> {<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>} : <span class="id" type="keyword">Type</span> :=<br/>
| <a name="EmptySet"><span class="id" type="constructor">EmptySet</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Char"><span class="id" type="constructor">Char</span></a> : <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="App"><span class="id" type="constructor">App</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Union"><span class="id" type="constructor">Union</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a><br/>
| <a name="Star"><span class="id" type="constructor">Star</span></a> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>.<br/>
</div>

<div class="doc">
请注意这个定义是<b>多态的</b>：<span class="inlinecode"><span class="id" type="var">reg_exp</span></span> <span class="inlinecode"><span class="id" type="var">T</span></span> 通过正则表达式描述了字符串，
    而其中的字符取自 <span class="inlinecode"><span class="id" type="var">T</span></span> －－也即，<span class="inlinecode"><span class="id" type="var">T</span></span> 的元素构成的列表。

<div class="paragraph"> </div>

    （同一般的实践略有不同，我们不要求类型 <span class="inlinecode"><span class="id" type="var">T</span></span> 是有限的。由此可形成一些关于正则表达式
    不同的理论，但对于我们在本章的目的而言并无不同。） 
<div class="paragraph"> </div>

 我们通过以下规则来构建正则表达式和字符串，这些规则定义了正则表达式何时匹配一个字符串：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 表达式 <span class="inlinecode"><span class="id" type="var">EmptySet</span></span> 不匹配任何字符串。

<div class="paragraph"> </div>


</li>
<li> 表达式 <span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> 匹配空字符串 <span class="inlinecode">[]</span>.

<div class="paragraph"> </div>


</li>
<li> 表达式 <span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> 匹配单个字符构成的字符串 <span class="inlinecode">[<span class="id" type="var">x</span>]</span>.

<div class="paragraph"> </div>


</li>
<li> 如果 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>, 且 <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>, 那么 <span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>
        <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span>.

<div class="paragraph"> </div>


</li>
<li> 如果 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> 中至少一个匹配 <span class="inlinecode"><span class="id" type="var">s</span></span>, 那么 <span class="inlinecode"><span class="id" type="var">Union</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>
        <span class="inlinecode"><span class="id" type="var">re<sub>2</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">s</span></span>.

<div class="paragraph"> </div>


</li>
<li> 最后，如果我们写下某个字符串 <span class="inlinecode"><span class="id" type="var">s</span></span> 作为一个字符串序列的连接
        <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s_1</span></span> <span class="inlinecode">++</span> <span class="inlinecode">...</span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s_k</span></span>，且表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配其中每一个字符串 <span class="inlinecode"><span class="id" type="var">s_i</span></span>，
        那么 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">s</span></span>。

<div class="paragraph"> </div>

        作为特殊情况，此字符串序列可能为空，因此无论 <span class="inlinecode"><span class="id" type="var">re</span></span> 是什么 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 总是匹配空字符串 <span class="inlinecode">[]</span>。
</li>
</ul>

<div class="paragraph"> </div>

 我们可以把非形式化的定义翻译为使用 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 的定义：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="exp_match"><span class="id" type="inductive">exp_match</span></a> {<span class="id" type="var">T</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">T</span> → <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="MEmpty"><span class="id" type="constructor">MEmpty</span></a> : <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [] <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a><br/>
| <a name="MChar"><span class="id" type="constructor">MChar</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [<a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a>] (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a>)<br/>
| <a name="MApp"><span class="id" type="constructor">MApp</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> (<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>) (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MUnionL"><span class="id" type="constructor">MUnionL</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> (<a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MUnionR"><span class="id" type="constructor">MUnionR</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> (<a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>)<br/>
| <a name="MStar0"><span class="id" type="constructor">MStar0</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> [] (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>)<br/>
| <a name="MStarApp"><span class="id" type="constructor">MStarApp</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> (<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>) (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
出于可读性的考虑，在此我们也展示使用推断规则表示的定义。
    于此同时，我们引入可读性更好的中缀表示法。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Notation</span> "s =~ re" := (<a class="idref" href="IndProp.html#exp_match"><span class="id" type="inductive">exp_match</span></a> <span class="id" type="var">s</span> <span class="id" type="var">re</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 80).<br/>
</div>

<div class="doc">
<center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MEmpty) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[]&nbsp;=~&nbsp;EmptyStr</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MChar) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[x]&nbsp;=~&nbsp;Char&nbsp;x</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re<sub>1</sub>&nbsp;&nbsp;&nbsp;&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;re<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MApp) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;++&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;App&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re<sub>1</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MUnionL) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;Union&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>2</sub>&nbsp;=~&nbsp;re<sub>2</sub></td>
  <td class="infrulenamecol" rowspan="3">
    (MUnionR) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>2</sub>&nbsp;=~&nbsp;Union&nbsp;re<sub>1</sub>&nbsp;re<sub>2</sub></td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">&nbsp;&nbsp;</td>
  <td class="infrulenamecol" rowspan="3">
    (MStar0) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">[]&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td></td>
</td>
</table></center><center><table class="infrule">
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;=~&nbsp;re&nbsp;&nbsp;&nbsp;&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td class="infrulenamecol" rowspan="3">
    (MStarApp) &nbsp;
  </td></tr>
<tr class="infrulemiddle">
  <td class="infrule"><hr /></td>
</tr>
<tr class="infruleassumption">
  <td class="infrule">s<sub>1</sub>&nbsp;++&nbsp;s<sub>2</sub>&nbsp;=~&nbsp;Star&nbsp;re</td>
  <td></td>
</td>
</table></center>
<div class="paragraph"> </div>

 请注意这些规则不<b>完全</b>等同于之前给出的非形式化定义。
    首先，我们并不需要一个规则来直接表述无字符串匹配 <span class="inlinecode"><span class="id" type="var">EmptySet</span></span>；
    我们做的仅仅是不囊括任何可能导致有字符串被 <span class="inlinecode"><span class="id" type="var">EmptySet</span></span> 所匹配的规则。
    （的确，归纳定义的语法并不<b>允许</b>我们表达类似的“否定规则”（negative rule））。

<div class="paragraph"> </div>

    其次，非形式化定义中的 <span class="inlinecode"><span class="id" type="var">Union</span></span> 和 <span class="inlinecode"><span class="id" type="var">Star</span></span> 各自对应了两个构造子：
    <span class="inlinecode"><span class="id" type="var">MUnionL</span></span> / <span class="inlinecode"><span class="id" type="var">MUnionR</span></span>，和 <span class="inlinecode"><span class="id" type="var">MStar0</span></span> / <span class="inlinecode"><span class="id" type="var">MStarApp</span></span>。这在逻辑上等价于
    原始的定义，但在 Coq 中这样更加方便，因为递归出现的 <span class="inlinecode"><span class="id" type="var">exp_match</span></span> 是作为构造子的
    直接参数给定的，这在对证据进行归纳时更简单。
    （练习 <span class="inlinecode"><span class="id" type="var">exp_match_ex<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">exp_match_ex<sub>2</sub></span></span> 会要求你证明归纳定义中给定的构造子
    和从非形式化规则的表述中提炼的规则确实是等价的。）

<div class="paragraph"> </div>

    接下来我们对一些例子使用这些规则： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>1</sub>"><span class="id" type="definition">reg_exp_ex<sub>1</sub></span></a> : [1] =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>2</sub>"><span class="id" type="definition">reg_exp_ex<sub>2</sub></span></a> : [1; 2] =~ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 2).<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [1] <span class="id" type="var">_</span> [2]).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
（请注意，后一个例子对字符串 <span class="inlinecode">[1]</span> 和 <span class="inlinecode">[2]</span> 直接应用了 <span class="inlinecode"><span class="id" type="var">MApp</span></span>。
    由于目标的形式是 <span class="inlinecode">[1;</span> <span class="inlinecode">2]</span> 而非 <span class="inlinecode">[1]</span> <span class="inlinecode">++</span> <span class="inlinecode">[2]</span>，Coq 并不知道如何分解这个字符串。）

<div class="paragraph"> </div>

    使用 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>，我们还可以证明某些字符串<b>不</b>匹配一个正则表达式： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>3</sub>"><span class="id" type="definition">reg_exp_ex<sub>3</sub></span></a> : ¬ ([1; 2] =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> 1).<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
我们可以定义一些辅助函数来简化正则表达式的书写。函数 <span class="inlinecode"><span class="id" type="var">reg_exp_of_list</span></span>
    接受一个列表做参数，并构造一个正则表达式来精确地匹配这个列表：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span> :: <span class="id" type="var">l'</span> ⇒ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">x</span>) (<a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> <span class="id" type="var">l'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="reg_exp_ex<sub>4</sub>"><span class="id" type="definition">reg_exp_ex<sub>4</sub></span></a> : [1; 2; 3] =~ <a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> [1; 2; 3].<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [1]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [2]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> [3]).<br/>
&nbsp;&nbsp;{ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>. }<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MEmpty"><span class="id" type="constructor">MEmpty</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
我们还可以证明一些关于 <span class="inlinecode"><span class="id" type="var">exp_match</span></span> 的性质。比如，下面的引理显示
    任意一个匹配 <span class="inlinecode"><span class="id" type="var">re</span></span> 的字符串 <span class="inlinecode"><span class="id" type="var">s</span></span> 也匹配 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar1"><span class="id" type="lemma">MStar1</span></a> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> <span class="id" type="var">re</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> &lt;- (<a class="idref" href="Poly.html#app_nil_r"><span class="id" type="axiom">app_nil_r</span></a> <span class="id" type="var">_</span> <span class="id" type="var">s</span>).<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MStarApp"><span class="id" type="constructor">MStarApp</span></a> <span class="id" type="var">s</span> [] <span class="id" type="var">re</span>).<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MStar0"><span class="id" type="constructor">MStar0</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>
</div>

<div class="doc">
（请注意对 <span class="inlinecode"><span class="id" type="var">app_nil_r</span></span> 的使用改变了目标，以此可匹配 <span class="inlinecode"><span class="id" type="var">MStarApp</span></span> 所需要的形式。）
<div class="paragraph"> </div>

<a name="lab220"></a><h4 class="section">练习：3 星 (exp_match_ex<sub>1</sub>)</h4>
 下面的引理显示从形式化的归纳定义中可以得到本章开始的非形式化匹配规则。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="empty_is_empty"><span class="id" type="lemma">empty_is_empty</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;¬ (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="MUnion'"><span class="id" type="lemma">MUnion'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ∨ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> <a class="idref" href="IndProp.html#re<sub>2</sub>"><span class="id" type="variable">re<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
接下来的引理使用了 <a href="Poly.html"><span class="inlineref">Poly</span></a> 一章中出现的 <span class="inlinecode"><span class="id" type="var">fold</span></span> 函数：
    如果 <span class="inlinecode"><span class="id" type="var">ss</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode">(<span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">T</span>)</span> 表示一个字符串序列 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span>,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" type="var">sn</span></span>，那么
    <span class="inlinecode"><span class="id" type="var">fold</span></span> <span class="inlinecode"><span class="id" type="var">app</span></span> <span class="inlinecode"><span class="id" type="var">ss</span></span> <span class="inlinecode">[]</span> 是将所有字符串连接的结果。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar'"><span class="id" type="lemma">MStar'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">ss</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>)) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;(<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> → <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) →<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> [] =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab221"></a><h4 class="section">练习：4 星, optional (reg_exp_of_list_spec)</h4>
 请证明 <span class="inlinecode"><span class="id" type="var">reg_exp_of_list</span></span> 满足以下规范： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="reg_exp_of_list_spec"><span class="id" type="lemma">reg_exp_of_list_spec</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#reg_exp_of_list"><span class="id" type="definition">reg_exp_of_list</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ↔ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> = <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 由于 <span class="inlinecode"><span class="id" type="var">exp_match</span></span> 以递归方式定义，我们可能会发现
    关于正则表达式的证明常常需要对证据进行归纳。
<div class="paragraph"> </div>

 比如，假设我们想要证明以下显然的结果：如果正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配某个字符串 <span class="inlinecode"><span class="id" type="var">s</span></span>，
    那么 <span class="inlinecode"><span class="id" type="var">s</span></span> 中的所有元素必在 <span class="inlinecode"><span class="id" type="var">re</span></span> 中某处以字符字面量的形式出现。

<div class="paragraph"> </div>

    为了表达这个定理，我们首先定义函数 <span class="inlinecode"><span class="id" type="var">re_chars</span></span> 来列举一个正则表达式中出现的
    所有字符：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="re_chars"><span class="id" type="definition">re_chars</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a> ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">x</span> ⇒ [<span class="id" type="var">x</span>]<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>1</sub></span> ++ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>1</sub></span> ++ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">re</span> ⇒ <a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
接下来我们这样陈述此定理： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="in_re_match"><span class="id" type="lemma">in_re_match</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>) (<span class="id" type="var">x</span> : <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> (<a class="idref" href="IndProp.html#re_chars"><span class="id" type="definition">re_chars</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s</span> <span class="id" type="var">re</span> <span class="id" type="var">x</span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hmatch</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [| <span class="id" type="var">x'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span> | <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">re</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a> <span class="id" type="keyword">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hin</span> | <span class="id" type="var">Hin</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>1</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>2</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>2</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH</span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> (<span class="id" type="var">IH</span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span>.<br/>
</div>

<div class="doc">
特别关注一下对 <span class="inlinecode"><span class="id" type="var">MStarApp</span></span> 分类的证明。我们得到了<b>两个</b>归纳假设：
    一个适用于 <span class="inlinecode"><span class="id" type="var">x</span></span> 出现在 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 中（当匹配 <span class="inlinecode"><span class="id" type="var">re</span></span> 时），另一个则适用于
    <span class="inlinecode"><span class="id" type="var">x</span></span> 出现在 <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> 中（当匹配 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 时）。
    这是一个很好的例子来表明为什么我们需要对 <span class="inlinecode"><span class="id" type="var">exp_match</span></span> 的证据而非 <span class="inlinecode"><span class="id" type="var">re</span></span>
    进行归纳：对后者的归纳仅仅提供匹配 <span class="inlinecode"><span class="id" type="var">re</span></span> 的字符串的归纳假设，却无法允许我们
    对 <span class="inlinecode"><span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> 分类进行推理。 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#In_app_iff"><span class="id" type="axiom">In_app_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">Hin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">Hin</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">Hin</span> | <span class="id" type="var">Hin</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>1</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;In&nbsp;x&nbsp;s<sub>2</sub>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<span class="id" type="var">IH<sub>2</sub></span> <span class="id" type="var">Hin</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab222"></a><h4 class="section">练习：4 星 (re_not_empty)</h4>
 请编写一个递归函数 <span class="inlinecode"><span class="id" type="var">re_not_empty</span></span> 用来测试某个正则表达式是否会匹配一些字符串。
    并证明你的函数是正确的。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="re_not_empty"><span class="id" type="definition">re_not_empty</span></a> {<span class="id" type="var">T</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="re_not_empty_correct"><span class="id" type="lemma">re_not_empty_correct</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;(<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) ↔ <a class="idref" href="IndProp.html#re_not_empty"><span class="id" type="axiom">re_not_empty</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab223"></a><h2 class="section"><span class="inlinecode"><span class="id" type="var">remember</span></span> 策略</h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 策略让人困惑的一个特点是它会欣然接受任意一个项并尝试归纳，
    即使这个项不够一般（general）。其副作用是会丢失掉一些信息（类似 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span>），
    并且使你无法完成证明。比如： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
</div>

<div class="doc">
仅仅对 <span class="inlinecode"><span class="id" type="var">H<sub>1</sub></span></span> 反演并不会对处理含有递归的分类有太多帮助。
    （尝试一下！）
    因此我们需要对证据进行归纳！下面是一个朴素的尝试：
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span>|<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">re''</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re''</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
但是现在，尽管我们得到了七个分类（正由我们从 <span class="inlinecode"><span class="id" type="var">exp_match</span></span> 的定义中期待的那样），
     <span class="inlinecode"><span class="id" type="var">H<sub>1</sub></span></span> 还是丢失了一个非常重要的信息： <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 匹配了某种形式的 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 的事实。
    这意味着对于<b>全部</b>的七个构造子分类我们都需要给出证明，尽管其中两个（<span class="inlinecode"><span class="id" type="var">MStar0</span></span>
    和 <span class="inlinecode"><span class="id" type="var">MStarApp</span></span>）是自相矛盾的。
    我们仍然可以在一些构造子上继续证明，比如 <span class="inlinecode"><span class="id" type="var">MEmpty</span></span> …… 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
</div>

<div class="doc">
…… 但有一些分类我们却卡住了。比如，对于 <span class="inlinecode"><span class="id" type="var">MChar</span></span>，我们需要证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">s<sub>2</sub></span>&nbsp;=~&nbsp;<span class="id" type="var">Char</span>&nbsp;<span class="id" type="var">x'</span>&nbsp;→&nbsp;<span class="id" type="var">x'</span>&nbsp;::&nbsp;<span class="id" type="var">s<sub>2</sub></span>&nbsp;=~&nbsp;<span class="id" type="var">Char</span>&nbsp;<span class="id" type="var">x'</span>,
<div class="paragraph"> </div>

</div>
    这显然是不可能完成的。 
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar.&nbsp;卡住了……&nbsp;*)</span><br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
问题是，只有当 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 的假设是完全一般的时候，对其使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 的才会起作用，
    也即，其所有的参数都是变量，而非更复杂的表达式，比如 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>。

<div class="paragraph"> </div>

    （由此，对证据使用 <span class="inlinecode"><span class="id" type="tactic">induction</span></span> 的行为更像是 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 而非 <span class="inlinecode"><span class="id" type="tactic">inversion</span></span>。）

<div class="paragraph"> </div>

    通过显式地添加一个等式来一般化这个有问题的表达式，我们便可以解决这个问题： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> <span class="id" type="var">re'</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a> = <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
</div>

<div class="doc">
我们现在可以直接对证据进行归纳，因为第一个假设的参数已经足够一般，
    这意味着我们通过反演当前上下文中的 <span class="inlinecode"><span class="id" type="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 来消解掉多数分类。

<div class="paragraph"> </div>

    这在 Coq 中是一种常用的技巧，因此 Coq 提供了策略来自动生成这种等式，
    并且我们也不必改写定理的陈述。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
在 Coq 中使用 <span class="inlinecode"><span class="id" type="var">remember</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="keyword">as</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> 策略会（1）替换所有表达式 <span class="inlinecode"><span class="id" type="var">e</span></span> 为变量 <span class="inlinecode"><span class="id" type="var">x</span></span>，
    （2）在当前上下文中添加一个等式 <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e</span></span>。我们可以这样使用它来证明上面的结果： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_app"><span class="id" type="lemma">star_app</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="var">remember</span> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">re</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">re'</span>.<br/>
</div>

<div class="doc">
我们现在有 <span class="inlinecode"><span class="id" type="var">Heqre'</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">re'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>. 
</div>
<div class="code code-tight">

&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">s<sub>2</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">H<sub>1</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [|<span class="id" type="var">x'</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span>|<span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<span class="id" type="var">re''</span>|<span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub>'</span> <span class="id" type="var">re''</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span>].<br/>
</div>

<div class="doc">
 <span class="inlinecode"><span class="id" type="var">Heqre'</span></span> 与多数分类相互矛盾，因此我们可以直接结束这些分类。
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span>  <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MChar&nbsp;*)</span>   <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MApp&nbsp;*)</span>    <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionL&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MUnionR&nbsp;*)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>.<br/>
</div>

<div class="doc">
值得注意的分类是关于 <span class="inlinecode"><span class="id" type="var">Star</span></span> 的。请注意 <span class="inlinecode"><span class="id" type="var">MStarApp</span></span> 分类的归纳假设 <span class="inlinecode"><span class="id" type="var">IH<sub>2</sub></span></span>
    涉及到一个额外的前提 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re''</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re'</span></span>，这是由 <span class="inlinecode"><span class="id" type="var">remember</span></span> 添加的
    等式所产生的。
</div>
<div class="code code-tight">

&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStar0&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">s</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/><hr class='doublespaceincode'/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MStarApp&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">Heqre'</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H<sub>0</sub></span> <span class="id" type="keyword">in</span> <span class="id" type="var">IH<sub>2</sub></span>, <span class="id" type="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">H<sub>1</sub></span>. <span class="id" type="tactic">rewrite</span> &lt;- <a class="idref" href="Poly.html#app_assoc"><span class="id" type="axiom">app_assoc</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MStarApp"><span class="id" type="constructor">MStarApp</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">Hmatch1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">IH<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>1</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab224"></a><h4 class="section">练习：4 星, optional (exp_match_ex<sub>2</sub>)</h4>

<div class="paragraph"> </div>

 下面的引理 <span class="inlinecode"><span class="id" type="var">MStar''</span></span>(以及它的逆，之前的练习题中的 <span class="inlinecode"><span class="id" type="var">MStar'</span></span>）显示 <span class="inlinecode"><span class="id" type="var">exp_match</span></span>
    定义中的 <span class="inlinecode"><span class="id" type="var">Star</span></span> 等价于前面给出的非形式化定义。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MStar''"><span class="id" type="lemma">MStar''</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">s</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) (<span class="id" type="var">re</span> : <a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">ss</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> (<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="Poly.html#fold"><span class="id" type="definition">fold</span></a> <a class="idref" href="Poly.html#app"><span class="id" type="definition">app</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;∧ <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s'</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#s'"><span class="id" type="variable">s'</span></a> <a class="idref" href="IndProp.html#ss"><span class="id" type="variable">ss</span></a> → <a class="idref" href="IndProp.html#s'"><span class="id" type="variable">s'</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab225"></a><h4 class="section">练习：5 星, advanced (pumping)</h4>
 正则表达式中一个非常有趣的定理叫做<b>泵引理（Pumping Lemma）</b>，
    非形式化地来讲，它陈述了任意某个足够长的字符串 <span class="inlinecode"><span class="id" type="var">s</span></span> 若匹配一个正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span>，
    则可以被抽取（pumped）——将 <span class="inlinecode"><span class="id" type="var">s</span></span> 的某个中间部分重复任意次产生的新字符串
    仍然匹配 <span class="inlinecode"><span class="id" type="var">re</span></span>。

<div class="paragraph"> </div>

    我们首先定义什么是“足够长”。由于使用的是构造性逻辑，我们事实上需要计算
    对于任何一个正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 其最小的“可被抽取（pumpability）”长度。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Pumping"><span class="id" type="module">Pumping</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Fixpoint</span> <a name="Pumping.pumping_constant"><span class="id" type="definition">pumping_constant</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a> ⇒ 0<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ⇒ 1<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <span class="id" type="var">_</span> ⇒ 2<br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>1</sub></span> + <a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>1</sub></span> + <a class="idref" href="IndProp.html#pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <span class="id" type="var">re<sub>2</sub></span><br/>
&nbsp;&nbsp;| <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <span class="id" type="var">_</span> ⇒ 1<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
接下来，定义一个辅助函数来重复一个字符串（连接到它自己）特定次数。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="Pumping.napp"><span class="id" type="definition">napp</span></a> {<span class="id" type="var">T</span>} (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ []<br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <span class="id" type="var">n'</span> ⇒ <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ++ <a class="idref" href="IndProp.html#napp"><span class="id" type="definition">napp</span></a> <span class="id" type="var">n'</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Lemma</span> <a name="Pumping.napp_plus"><span class="id" type="lemma">napp_plus</span></a>: <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">n</span> <span class="id" type="var">m</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">l</span> : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> + <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ++ <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> <span class="id" type="var">l</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">n</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">n</span> <span class="id" type="var">IHn</span>].<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">IHn</span>, <a class="idref" href="Poly.html#app_assoc"><span class="id" type="axiom">app_assoc</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
现在，泵引理是说，如果 <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re</span></span> 且 <span class="inlinecode"><span class="id" type="var">s</span></span> 的长度最小是 <span class="inlinecode"><span class="id" type="var">re</span></span> 的抽取常数（pumping constant），
    那么 <span class="inlinecode"><span class="id" type="var">s</span></span> 可分割成三个子字符串 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>3</sub></span></span>，其中 <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> 可被重复任意次，
    其结果同 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">s<sub>3</sub></span></span> 合并后仍然匹配 <span class="inlinecode"><span class="id" type="var">re</span></span>。由于 <span class="inlinecode"><span class="id" type="var">s<sub>2</sub></span></span> 必须为非空字符串，
    这是一种（构造性的）方式来以我们想要的长度生成匹配 <span class="inlinecode"><span class="id" type="var">re</span></span> 的字符串。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="Pumping.pumping"><span class="id" type="lemma">pumping</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">T</span> (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="IndProp.html#T"><span class="id" type="variable">T</span></a>) <span class="id" type="var">s</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> →<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#Pumping.pumping_constant"><span class="id" type="definition">pumping_constant</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ≤ <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">s<sub>3</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>3</sub>"><span class="id" type="variable">s<sub>3</sub></span></a> ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ≠ [] ∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#Pumping.napp"><span class="id" type="definition">napp</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#s<sub>2</sub>"><span class="id" type="variable">s<sub>2</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>3</sub>"><span class="id" type="variable">s<sub>3</sub></span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
</div>

<div class="doc">
为了简化证明（也就是接下来你需要填写的），我们使用 <span class="inlinecode"><span class="id" type="keyword">Require</span></span> 来引入 <span class="inlinecode"><span class="id" type="tactic">omega</span></span> 策略，
    其可用于自动化地完成一些涉及到自然数上的等式和不等式的枯燥证明。
    我们在后面的章节中会详细解释 <span class="inlinecode"><span class="id" type="tactic">omega</span></span>，不过请尝试做一些实验。
    下面的第一个归纳分类中展示了如何使用它。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Import</span> <span class="id" type="var">Coq.omega.Omega</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">re</span> <span class="id" type="var">s</span> <span class="id" type="var">Hmatch</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">Hmatch</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">as</span> [ | <span class="id" type="var">x</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span> | <span class="id" type="var">re<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re<sub>2</sub></span> <span class="id" type="var">Hmatch</span> <span class="id" type="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">re</span> | <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">s<sub>2</sub></span> <span class="id" type="var">re</span> <span class="id" type="var">Hmatch1</span> <span class="id" type="var">IH<sub>1</sub></span> <span class="id" type="var">Hmatch2</span> <span class="id" type="var">IH<sub>2</sub></span> ].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;MEmpty&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="IndProp.html#Pumping"><span class="id" type="module">Pumping</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab226"></a><h1 class="section">案例学习：改进互映</h1>

<div class="paragraph"> </div>

 在 <a href="Logic.html"><span class="inlineref">Logic</span></a> 一章中，我们经常需要关联起对布尔值的计算和 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>
    中的陈述。然而进行这样的关联往往会导致冗长的证明。请考虑以下定理的证明：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="filter_not_empty_In"><span class="id" type="lemma">filter_not_empty_In</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ≠ [] →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">m</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span class="id" type="var">eqn</span>:<span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;beq_nat&nbsp;n&nbsp;m&nbsp;=&nbsp;true&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;beq_nat&nbsp;n&nbsp;m&nbsp;=&nbsp;false&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 后的第一个分支中，我们解构 <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>
    后生成的等式显式地使用了 <span class="inlinecode"><span class="id" type="var">beq_nat_true_iff</span></span> 引理，以此将假设
    <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> 转换为假设 <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>；接着使用 <span class="inlinecode"><span class="id" type="tactic">rewrite</span></span> 和这个假设
    来完成此分支的证明。
<div class="paragraph"> </div>

 为了简化这样的证明，我们可定义一个归纳命题，其对 <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span>
    可产生更好的分类讨论原理。
    它不会生成类似 <span class="inlinecode"><span class="id" type="var">beq_nat</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span> 这样的等式，因为一般来说这并不直接有用，
    其生成的分类讨论原理正是我们所需要的假设: <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m</span></span>。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="reflect"><span class="id" type="inductive">reflect</span></a> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="ReflectT"><span class="id" type="constructor">ReflectT</span></a> : <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a><br/>
| <a name="ReflectF"><span class="id" type="constructor">ReflectF</span></a> : ¬ <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
</div>

<div class="doc">
性质 <span class="inlinecode"><span class="id" type="var">reflect</span></span> 接受两个参数：一个命题 <span class="inlinecode"><span class="id" type="var">P</span></span> 和一个布尔值 <span class="inlinecode"><span class="id" type="var">b</span></span>。
    直观地讲，它陈述了性质 <span class="inlinecode"><span class="id" type="var">P</span></span> 在布尔值 <span class="inlinecode"><span class="id" type="var">b</span></span> 中所<b>映现</b>（也即，等价）：
    换句话说，<span class="inlinecode"><span class="id" type="var">P</span></span> 成立当且进当 <span class="inlinecode"><span class="id" type="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>。为了理解这一点，请注意，根据定义，
    我们能够产生 <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> 的证据的唯一方式是证明 <span class="inlinecode"><span class="id" type="var">P</span></span> 为真且使用
    <span class="inlinecode"><span class="id" type="var">ReflectT</span></span> 构造子。如果我们反转这个陈述，意味着从 <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span>
    的证明中抽取出 <span class="inlinecode"><span class="id" type="var">P</span></span> 的证据也是可能的。相反地，显示 <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">false</span></span>
    的唯一方式是合并 <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span> 的证据和 <span class="inlinecode"><span class="id" type="var">ReflectF</span></span> 构造子。

<div class="paragraph"> </div>

    形式化这种直觉并证明两个表述确实等价是十分容易的：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="iff_reflect"><span class="id" type="lemma">iff_reflect</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span>, (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>) → <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;课上已完成&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ReflectT"><span class="id" type="constructor">ReflectT</span></a>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ReflectF"><span class="id" type="constructor">ReflectF</span></a>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab227"></a><h4 class="section">练习：2 星, recommended (reflect_iff)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <a name="reflect_iff"><span class="id" type="lemma">reflect_iff</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">b</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 使用 <span class="inlinecode"><span class="id" type="var">reflect</span></span> 而非“当且仅当”连词的好处是，通过解构一个具有
    <span class="inlinecode"><span class="id" type="var">reflect</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">b</span></span> 形式的假设或引理，我们可以对 <span class="inlinecode"><span class="id" type="var">b</span></span>
    进行分类讨论，同时为两个分支生成适当的假设（第一个子目标中的 <span class="inlinecode"><span class="id" type="var">P</span></span> 和
    第二个中的 <span class="inlinecode">¬</span> <span class="inlinecode"><span class="id" type="var">P</span></span>）。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="beq_natP"><span class="id" type="lemma">beq_natP</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> = <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>) (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#iff_reflect"><span class="id" type="lemma">iff_reflect</span></a>. <span class="id" type="tactic">rewrite</span> <a class="idref" href="Logic.html#beq_nat_true_iff"><span class="id" type="lemma">beq_nat_true_iff</span></a>. <span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">filter_not_empty_In</span></span> 的新证明如下所示。请注意对 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 和 <span class="inlinecode"><span class="id" type="tactic">apply</span></span>
    的使用是如何合并成一个 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 的使用。 
<div class="paragraph"> </div>

 （为了更清晰地看到这点，使用 Coq 查看 <span class="inlinecode"><span class="id" type="var">filter_not_empty_In</span></span>
    的两个证明，并观察在 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 的第一个分类开始时证明状态的区别。） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="filter_not_empty_In'"><span class="id" type="lemma">filter_not_empty_In'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Poly.html#filter"><span class="id" type="definition">filter</span></a> (<a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a>) <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> ≠ [] →<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l</span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">m</span> <span class="id" type="var">l'</span> <span class="id" type="var">IHl'</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;l&nbsp;=&nbsp;m&nbsp;::&nbsp;l'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">simpl</span>. <span class="id" type="tactic">destruct</span> (<a class="idref" href="IndProp.html#beq_natP"><span class="id" type="lemma">beq_natP</span></a> <span class="id" type="var">n</span> <span class="id" type="var">m</span>) <span class="id" type="keyword">as</span> [<span class="id" type="var">H</span> | <span class="id" type="var">H</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;=&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="var">left</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n&nbsp;&lt;&gt;&nbsp;m&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">H'</span>. <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">IHl'</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H'</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab228"></a><h4 class="section">练习：3 星, recommended (beq_natP_practice)</h4>
 使用上面的 <span class="inlinecode"><span class="id" type="var">beq_natP</span></span> 证明以下定理：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Fixpoint</span> <a name="count"><span class="id" type="definition">count</span></a> <span class="id" type="var">n</span> <span class="id" type="var">l</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ 0<br/>
&nbsp;&nbsp;| <span class="id" type="var">m</span> :: <span class="id" type="var">l'</span> ⇒ (<span class="id" type="keyword">if</span> <a class="idref" href="Basics.html#beq_nat"><span class="id" type="definition">beq_nat</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="var">m</span> <span class="id" type="keyword">then</span> 1 <span class="id" type="keyword">else</span> 0) + <a class="idref" href="IndProp.html#count"><span class="id" type="definition">count</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <span class="id" type="var">l'</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Theorem</span> <a name="beq_natP_practice"><span class="id" type="lemma">beq_natP_practice</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#count"><span class="id" type="definition">count</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = 0 → ~(<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 在这个小例子中，这种技术仅仅在证明时提升了一点方便；然而，当证明变得庞大时，
    使用 <span class="inlinecode"><span class="id" type="var">reflect</span></span> 往往更容易写出清晰和简短的证明脚本。我们将会在后面的章节
    和<b>编程语言基础</b>一卷中看到更多的例子。

<div class="paragraph"> </div>

    对 <span class="inlinecode"><span class="id" type="var">reflect</span></span> 性质的使用是随着 <b>SSReflect</b> 而流行开来的，这是一个
    Coq 程序库，用于形式化一些数学上的重要结果，包括四色定理和法伊特－汤普森定理。
    SSReflect 的名字代表着 <b>small-scale reflection</b>，也即，普遍性地使用
    互映来简化与布尔值计算有关的证明。
</div>

<div class="doc">
<a name="lab229"></a><h1 class="section">额外练习</h1>

<div class="paragraph"> </div>

<a name="lab230"></a><h4 class="section">练习：3 星, recommended (nostutter_defn)</h4>
 写出一个性质的归纳定义是本课程中你需要的重要技能。请尝试去独立解决
    以下的练习。

<div class="paragraph"> </div>

    如果一个列表连续地重复一个元素，那么我们说这个列表是百叶窗式的（stutters）。
    （这和上面练习中的 <span class="inlinecode"><span class="id" type="var">NoDup</span></span> 性质是不同的：列表 <span class="inlinecode">1;4;1</span> 虽然有重复但并不是
    百叶窗式的。） <span class="inlinecode"><span class="id" type="var">nostutter</span></span> <span class="inlinecode"><span class="id" type="var">mylist</span></span> 表示 <span class="inlinecode"><span class="id" type="var">mylist</span></span> 不是百叶窗式的。
    请尝试写出 <span class="inlinecode"><span class="id" type="var">nostutter</span></span> 的归纳定义。
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="nostutter"><span class="id" type="inductive">nostutter</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
.<br/>
</div>

<div class="doc">
请确保以下测试成功，但如果你觉得建议的证明（在注释中）并不工作，也可随意更改他们。
    你的定义若与我们的不同，但可能仍然是正确的，在这种情况下可能需要不同的证明。
    （你会注意到建议的证明中使用了一些我们尚未讨论过的策略，这可以让证明对可能不同的 <span class="inlinecode"><span class="id" type="var">nostutter</span></span>
    定义方式更加健壮。你可以取消注释并直接使用他们，但也可以用基础的策略证明这些例子。） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Example</span> <a name="test_nostutter_1"><span class="id" type="definition">test_nostutter_1</span></a>: <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3;1;4;1;5;6].<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false_iff;&nbsp;auto.<br/>
&nbsp;&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_2"><span class="id" type="definition">test_nostutter_2</span></a>:  <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> (@<a class="idref" href="Poly.html#nil"><span class="id" type="constructor">nil</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false_iff;&nbsp;auto.<br/>
&nbsp;&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_3"><span class="id" type="definition">test_nostutter_3</span></a>:  <a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [5].<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;repeat&nbsp;constructor;&nbsp;apply&nbsp;beq_nat_false;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Example</span> <a name="test_nostutter_4"><span class="id" type="definition">test_nostutter_4</span></a>:      <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a> (<a class="idref" href="IndProp.html#nostutter"><span class="id" type="inductive">nostutter</span></a> [3;1;1;4]).<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
<span class="comment">(*&nbsp;<br/>
&nbsp;&nbsp;Proof.&nbsp;intro.<br/>
&nbsp;&nbsp;repeat&nbsp;match&nbsp;goal&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;&nbsp;h:&nbsp;nostutter&nbsp;_&nbsp;|-&nbsp;_&nbsp;=&gt;&nbsp;inversion&nbsp;h;&nbsp;clear&nbsp;h;&nbsp;subst<br/>
&nbsp;&nbsp;end.<br/>
&nbsp;&nbsp;contradiction&nbsp;H<sub>1</sub>;&nbsp;auto.&nbsp;Qed.<br/>
*)</span><br/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_nostutter"><span class="id" type="definition">manual_grade_for_nostutter</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab231"></a><h4 class="section">练习：4 星, advanced (filter_challenge)</h4>
 让我们证明在 <span class="inlinecode"><span class="id" type="var">Poly</span></span> 一章中 <span class="inlinecode"><span class="id" type="var">filter</span></span> 的定义匹配某个抽象的规范。
    可以这样非形式化地描述这个规范：

<div class="paragraph"> </div>

    列表 <span class="inlinecode"><span class="id" type="var">l</span></span> 是一个 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 的“顺序合并”（in-order merge），如果它以
    <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 中元素的顺序包含 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 中的所有元素，尽管可能是交替的。比如：

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;4;6;2;3]
<div class="paragraph"> </div>

</div>
    是

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[1;6;2]
<div class="paragraph"> </div>

</div>
    和

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;[4;3].
<div class="paragraph"> </div>

</div>
    的顺序合并。

<div class="paragraph"> </div>

    现在，假设我们有集合 <span class="inlinecode"><span class="id" type="var">X</span></span>，函数 <span class="inlinecode"><span class="id" type="var">test</span>:</span> <span class="inlinecode"><span class="id" type="var">X</span>→<span class="id" type="var">bool</span></span>，和一个类型为 <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 的列表
    <span class="inlinecode"><span class="id" type="var">l</span></span>。接着接设如果 <span class="inlinecode"><span class="id" type="var">l</span></span> 是 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 的顺序合并，且 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 中的每个元素满足 <span class="inlinecode"><span class="id" type="var">test</span></span>，
    而 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 中没有元素满足 <span class="inlinecode"><span class="id" type="var">test</span></span>，那么 <span class="inlinecode"><span class="id" type="var">filter</span></span> <span class="inlinecode"><span class="id" type="var">test</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>。

<div class="paragraph"> </div>

    请将这段规范翻译为 Coq 中的定理并证明它。（你首先需要定义合并两个列表的含义是什么。
    请使用归纳关系而非 <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span> 来完成。）
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_filter_challenge"><span class="id" type="definition">manual_grade_for_filter_challenge</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab232"></a><h4 class="section">练习：5 星, advanced, optional (filter_challenge_2)</h4>
 另一种刻画 <span class="inlinecode"><span class="id" type="var">filter</span></span> 行为的方式是：在 <span class="inlinecode"><span class="id" type="var">l</span></span> 的所有其元素满足 <span class="inlinecode"><span class="id" type="var">test</span></span> 的子序列中，
    <span class="inlinecode"><span class="id" type="var">filter</span></span> <span class="inlinecode"><span class="id" type="var">test</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> 是最长的那个。请形式化这个命题并证明它。
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab233"></a><h4 class="section">练习：4 星, optional (palindromes)</h4>
 回文是倒序排列与正序排列相同的序列。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 在 <span class="inlinecode"><span class="id" type="var">listX</span></span> 上定义一个归纳命题 <span class="inlinecode"><span class="id" type="var">pal</span></span> 来表达回文的含义。
      （提示：你需要三个分类。定义应当基于列表的结构；仅仅使用一个构造子，例如

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;<span class="id" type="var">c</span>&nbsp;:&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>
<div class="paragraph"> </div>

</div>
      看起来十分显而易见，但并不会很好的工作。)

<div class="paragraph"> </div>


</li>
<li> 证明（<span class="inlinecode"><span class="id" type="var">pal_app_rev</span></span>）

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;(<span class="id" type="var">l</span>&nbsp;++&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>).
<div class="paragraph"> </div>

</div>

</li>
<li> 证明（<span class="inlinecode"><span class="id" type="var">pal_rev</span></span> that）

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</li>
</ul>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_pal_pal_app_rev_pal_rev"><span class="id" type="definition">manual_grade_for_pal_pal_app_rev_pal_rev</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab234"></a><h4 class="section">练习：5 星, optional (palindrome_converse)</h4>
 由于缺乏证据，反方向的证明要困难许多。请之前练习中你定义的 <span class="inlinecode"><span class="id" type="var">pal</span></span> 证明

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span>&nbsp;<span class="id" type="var">l</span>,&nbsp;<span class="id" type="var">l</span>&nbsp;=&nbsp;<span class="id" type="var">rev</span>&nbsp;<span class="id" type="var">l</span>&nbsp;→&nbsp;<span class="id" type="var">pal</span>&nbsp;<span class="id" type="var">l</span>.
<div class="paragraph"> </div>

</div>

</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab235"></a><h4 class="section">练习：4 星, advanced, optional (NoDup)</h4>
 请回忆一下 <span class="inlinecode"><span class="id" type="var">Logic</span></span> 章节中性质 <span class="inlinecode"><span class="id" type="var">In</span></span> 的定义，其断言值 <span class="inlinecode"><span class="id" type="var">x</span></span> 在列表 <span class="inlinecode"><span class="id" type="var">l</span></span> 中至少出现一次：
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;Fixpoint&nbsp;In&nbsp;(A&nbsp;:&nbsp;Type)&nbsp;(x&nbsp;:&nbsp;A)&nbsp;(l&nbsp;:&nbsp;list&nbsp;A)&nbsp;:&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;match&nbsp;l&nbsp;with<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;<span class="inlinecode"></span>&nbsp;=&gt;&nbsp;False<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;x'&nbsp;::&nbsp;l'&nbsp;=&gt;&nbsp;x'&nbsp;=&nbsp;x&nbsp;\/&nbsp;In&nbsp;A&nbsp;x&nbsp;l'<br/>
&nbsp;&nbsp;&nbsp;end&nbsp;*)</span><br/>
</div>

<div class="doc">
你的第一个任务是使用 <span class="inlinecode"><span class="id" type="var">In</span></span> 来定义命题 <span class="inlinecode"><span class="id" type="var">disjoint</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span>，其可被证明仅当列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>
    和 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> （元素的类型为 <span class="inlinecode"><span class="id" type="var">X</span></span>）不含有相同的元素。
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<div class="doc">
接下来，使用 <span class="inlinecode"><span class="id" type="var">In</span></span>　定义归纳命题 <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span>，其可被证明仅当列表 <span class="inlinecode"><span class="id" type="var">l</span></span>
    （元素类型为 <span class="inlinecode"><span class="id" type="var">X</span></span>）的每个元素都不相同。比如，<span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">[1;2;3;4]</span>
    和 <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[]</span> 是可被证明的，然而 <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">[1;2;1]</span>
    和 <span class="inlinecode"><span class="id" type="var">NoDup</span></span> <span class="inlinecode"><span class="id" type="var">bool</span></span> <span class="inlinecode">[<span class="id" type="var">true</span>;<span class="id" type="var">true</span>]</span> 是不行的。
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
</div>

<div class="doc">
最后，使用 <span class="inlinecode"><span class="id" type="var">disjoint</span></span>，<span class="inlinecode"><span class="id" type="var">NoDup</span></span> 和 <span class="inlinecode">++</span> （列表连接）陈述并证明一个或多个有趣的定理。 
</div>
<div class="code code-tight">

<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_NoDup_disjoint_etc"><span class="id" type="definition">manual_grade_for_NoDup_disjoint_etc</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab236"></a><h4 class="section">练习：4 星, advanced, optional (pigeonhole_principle)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;请勿修改下面这一行：&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <a name="manual_grade_for_check_repeats"><span class="id" type="definition">manual_grade_for_check_repeats</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#option"><span class="id" type="inductive">option</span></a> (<a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.String.html#string"><span class="id" type="inductive">string</span></a>) := <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#None"><span class="id" type="constructor">None</span></a>.<br/>
</div>

<div class="doc">
<b>鸽笼原理（Pigeonhole Principle）</b>陈述了一个关于计数的基本事实：
    如果我们将超过 <span class="inlinecode"><span class="id" type="var">n</span></span> 个项分布于 <span class="inlinecode"><span class="id" type="var">n</span></span> 个鸽笼，那么一些鸽笼
    必定含有至少两个项。往往有之，这个看起来关于数字的平凡事实却需要
    非平凡的手段来证明，但我们现在已经有了…… 
<div class="paragraph"> </div>

 首先容易证明一个有用的引理。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="in_split"><span class="id" type="lemma">in_split</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span>:<a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>) (<span class="id" type="var">l</span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> →<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>, <a class="idref" href="IndProp.html#l"><span class="id" type="variable">l</span></a> = <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> ++ <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> :: <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
现在请定一个性质 <span class="inlinecode"><span class="id" type="var">repeats</span></span>，这样 <span class="inlinecode"><span class="id" type="var">repeats</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> <span class="inlinecode"><span class="id" type="var">l</span></span> 断言 <span class="inlinecode"><span class="id" type="var">l</span></span> 包含
    至少一个重复的元素（类型为 <span class="inlinecode"><span class="id" type="var">X</span></span>）。  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="repeats"><span class="id" type="inductive">repeats</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <span class="id" type="var">X</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span><br/>
.<br/>
</div>

<div class="doc">
现在，我们这样来形式化鸽笼原理。假设列表 <span class="inlinecode"><span class="id" type="var">l<sub>2</sub></span></span> 表示鸽笼标签的列表，列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span>
    表示标签被指定给一个列表里的元素。如果元素的个数多于标签的个数，那么至少有两个
    元素被指定了同一个标签——也即，列表 <span class="inlinecode"><span class="id" type="var">l<sub>1</sub></span></span> 含有重复元素。

<div class="paragraph"> </div>

    如果使用 <span class="inlinecode"><span class="id" type="var">excluded_middule</span></span> 假设来证明 <span class="inlinecode"><span class="id" type="var">In</span></span> 是可决定的（decidable），
    即，<span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">l</span>,</span> <span class="inlinecode">(<span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span> <span class="inlinecode">∨</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">In</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">l</span>)</span>，这个证明会容易很多。
    然而，<b>不</b>假设 <span class="inlinecode"><span class="id" type="var">In</span></span> 是可决定的也同样可以证明它；如果你可以完成它，
    那么便不必使用 <span class="inlinecode"><span class="id" type="var">excluded_middle</span></span> 假设。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="pigeonhole_principle"><span class="id" type="lemma">pigeonhole_principle</span></a>: <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">l<sub>1</sub></span>  <span class="id" type="var">l<sub>2</sub></span>:<a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="IndProp.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Logic.html#excluded_middle"><span class="id" type="definition">excluded_middle</span></a> →<br/>
&nbsp;&nbsp;&nbsp;(<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> → <a class="idref" href="Logic.html#In"><span class="id" type="definition">In</span></a> <a class="idref" href="IndProp.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a>) →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#l<sub>2</sub>"><span class="id" type="variable">l<sub>2</sub></span></a> &lt; <a class="idref" href="Poly.html#length"><span class="id" type="definition">length</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a> →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#repeats"><span class="id" type="inductive">repeats</span></a> <a class="idref" href="IndProp.html#l<sub>1</sub>"><span class="id" type="variable">l<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">X</span> <span class="id" type="var">l<sub>1</sub></span>. <span class="id" type="tactic">induction</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">as</span> [|<span class="id" type="var">x</span> <span class="id" type="var">l<sub>1</sub>'</span> <span class="id" type="var">IHl1'</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab237"></a><h2 class="section">扩展练习：验证正则表达式匹配器</h2>

<div class="paragraph"> </div>

 我们现在已经定义了正则表达式的匹配关系和多态列表。我们可以使用定义手工证明
    给定的正则表达式匹配某个给定的字符串，但这并不是一个我们可以运行的程序来自动地
    判断是否匹配。

<div class="paragraph"> </div>

    有理由期待，用于构造匹配关系证据的归纳规则可以被翻译为一个递归函数，
    其在正则表达式上的递归对应于这种关系。然而，定义这样的函数并没有那么直接，
    由于给定的正则表达式会被 Coq 识别为递归变量，作为结果，Coq 并不会接受这个函数，
    即使它总是停机。

<div class="paragraph"> </div>

    重度优化的正则表达式匹配器会将正则表达式翻译为一个状态机，并决定状态机是否接受
    某个字符串。然而，正则表达式匹配也可以通过一个算法来实现，其仅仅操作字符串和
    正则表达式，无需定义和维护额外的数据类型，例如状态机。我们将会实现这样的算法，
    并验证其值与匹配关系是互映的。 
<div class="paragraph"> </div>

 我们将要实现的正则表达式匹配器会匹配由 ASCII 字符构成的列表：
</div>
<div class="code code-tight">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#"><span class="id" type="library">Coq.Strings.Ascii</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="string"><span class="id" type="definition">string</span></a> := <a class="idref" href="Poly.html#list"><span class="id" type="inductive">list</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>.<br/>
</div>

<div class="doc">
Coq 标准库中包含了一个不同的 ASCII 字符串的归纳定义。然而，为了应用
    之前定义的匹配关系，我们在此使用刚刚给出的 ASCII 字符列表作为定义。

<div class="paragraph"> </div>

    我们也可以定义工作在多态列表上的正则表达式匹配器，而非特定于 ASCII 字符列表。
    我们将要实现的匹配算法需要知道如何对列表中的元素判断相等，因此需要给定一个
    相等性测试函数。一般化我们给出的定义、定理和证明有一点枯燥，但是可行的。 
<div class="paragraph"> </div>

 正则表达式匹配器的正确性证明会由匹配函数的性质和 <span class="inlinecode"><span class="id" type="keyword">match</span></span> 关系的性质组成，
    <span class="inlinecode"><span class="id" type="keyword">match</span></span> 关系并不依赖匹配函数。我们将会首先证明后一类性质。他们中的多数
    将会是很直接的证明，已经被直接给出，少部分关键的引理会留给你来证明。 
</div>

<div class="doc">
每个可被证明的 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 等价于 <span class="inlinecode"><span class="id" type="var">True</span></span>。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="provable_equiv_true"><span class="id" type="lemma">provable_equiv_true</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>), <a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#True"><span class="id" type="inductive">True</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="var">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> <span class="id" type="var">_</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
其逆可被证明的 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 等价于 <span class="inlinecode"><span class="id" type="var">False</span></span>。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>), ¬<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> → (<a class="idref" href="IndProp.html#P"><span class="id" type="variable">P</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>0</sub></span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptySet</span></span> 不匹配字符串。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="null_matches_none"><span class="id" type="lemma">null_matches_none</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>), (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>) ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> 仅匹配空字符串。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="empty_matches_eps"><span class="id" type="lemma">empty_matches_eps</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>), <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = [ ].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MEmpty"><span class="id" type="constructor">MEmpty</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">EmptyStr</span></span> 不匹配非空字符串。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="empty_nomatch_ne"><span class="id" type="lemma">empty_nomatch_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, (<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a>) ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>. <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> 不匹配不以 <span class="inlinecode"><span class="id" type="var">a</span></span> 字符开始的字符串。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="char_nomatch_char"><span class="id" type="lemma">char_nomatch_char</span></a> :<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> <span class="id" type="var">b</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> ≠ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> → (<a class="idref" href="IndProp.html#b"><span class="id" type="variable">b</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ↔ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#False"><span class="id" type="inductive">False</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#not_equiv_false"><span class="id" type="lemma">not_equiv_false</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#not"><span class="id" type="definition">not</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>0</sub></span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
如果 <span class="inlinecode"><span class="id" type="var">Char</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> 匹配一个非空字符串，那么这个字符串的尾（tail）为空。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="char_eps_suffix"><span class="id" type="lemma">char_eps_suffix</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = [ ].<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MChar"><span class="id" type="constructor">MChar</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 匹配字符串 <span class="inlinecode"><span class="id" type="var">s</span></span> 当且仅当 <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>，其中 <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span>
    匹配 <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> 且 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="app_exists"><span class="id" type="lemma">app_exists</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>1</sub></span>, <span class="id" type="var">s<sub>2</sub></span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" type="tactic">split</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>3</sub></span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>4</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [ <span class="id" type="var">s<sub>0</sub></span> [ <span class="id" type="var">s<sub>1</sub></span> [ <span class="id" type="var">Happ</span> [ <span class="id" type="var">Hmat0</span> <span class="id" type="var">Hmat1</span> ] ] ] ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">rewrite</span> <span class="id" type="var">Happ</span>. <span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#MApp"><span class="id" type="constructor">MApp</span></a> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">_</span> <span class="id" type="var">s<sub>1</sub></span> <span class="id" type="var">_</span> <span class="id" type="var">Hmat0</span> <span class="id" type="var">Hmat1</span>).<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab238"></a><h4 class="section">练习：3 星, optional (app_ne)</h4>
 <span class="inlinecode"><span class="id" type="var">App</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> 当且仅当 <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> 匹配空字符串
    且 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 或 <span class="inlinecode"><span class="id" type="var">s</span>=<span class="id" type="var">s<sub>0</sub></span>++<span class="id" type="var">s<sub>1</sub></span></span>，其中 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s<sub>0</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span>
    且 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>。

<div class="paragraph"> </div>

    尽管这个性质由纯粹的匹配关系构成，它是一个重要的观察隐藏在我们匹配器的设计背后。
    因此（1）花一些时间理解它，（2）证明它，并且（3）留心后面你会如何使用它。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="app_ne"><span class="id" type="lemma">app_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span> <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>) ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;([ ] =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>) ∨<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">s</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">Union</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span> 当且仅当 <span class="inlinecode"><span class="id" type="var">s</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> 或 <span class="inlinecode"><span class="id" type="var">s</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="union_disj"><span class="id" type="lemma">union_disj</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re<sub>0</sub></span> <span class="id" type="var">re<sub>1</sub></span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Union"><span class="id" type="constructor">Union</span></a> <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>0</sub>"><span class="id" type="variable">re<sub>0</sub></span></a> ∨ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re<sub>1</sub>"><span class="id" type="variable">re<sub>1</sub></span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H<sub>2</sub></span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [ <span class="id" type="var">H</span> | <span class="id" type="var">H</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MUnionL"><span class="id" type="constructor">MUnionL</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#MUnionR"><span class="id" type="constructor">MUnionR</span></a>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab239"></a><h4 class="section">练习：3 星, optional (star_ne)</h4>
 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s</span></span> 匹配 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 当且仅当 <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">s<sub>0</sub></span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span>，其中 <span class="inlinecode"><span class="id" type="var">a</span>::<span class="id" type="var">s<sub>0</sub></span></span> 匹配
    <span class="inlinecode"><span class="id" type="var">re</span></span> 且 <span class="inlinecode"><span class="id" type="var">s<sub>1</sub></span></span> 匹配 <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>。 同 <span class="inlinecode"><span class="id" type="var">app_ne</span></span>一样，这个观察很重要，
    因此理解，证明并留意它。

<div class="paragraph"> </div>

    提示：你需要进行归纳。的确是有几个合理的候选 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> 来进行归纳。
    但唯一其作用的方式是首先拆分 <span class="inlinecode"><span class="id" type="var">iff</span></span> 为两个蕴含式，然后在 <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>
    的证据上进行归纳来证明其中一个。另一个蕴含式可以无需使用归纳来证明。

<div class="paragraph"> </div>

    为了在正确的性质上归纳，你需要使用 <span class="inlinecode"><span class="id" type="var">remember</span></span> 策略来重新表述 <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Star</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span>，
    使其成为一般变量上的 <span class="inlinecode"><span class="id" type="keyword">Prop</span></span>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="star_ne"><span class="id" type="lemma">star_ne</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">s</span> <span class="id" type="var">re</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span style='font-size:120%;'>&exist;</span> <span class="id" type="var">s<sub>0</sub></span> <span class="id" type="var">s<sub>1</sub></span>, <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> = <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> ++ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> ∧ <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s<sub>0</sub>"><span class="id" type="variable">s<sub>0</sub></span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ∧ <a class="idref" href="IndProp.html#s<sub>1</sub>"><span class="id" type="variable">s<sub>1</sub></span></a> =~ <a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 我们的正则表达式匹配器定义包括两个不动点函数。第一个函数对给定的正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span>
    进行求值，结果映射了 <span class="inlinecode"><span class="id" type="var">re</span></span> 是否匹配空字符串。这个函数满足以下性质： 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="refl_matches_eps"><span class="id" type="definition">refl_matches_eps</span></a> <span class="id" type="var">m</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> ([ ] =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab240"></a><h4 class="section">练习：2 星, optional (match_eps)</h4>
 完成 <span class="inlinecode"><span class="id" type="var">match_eps</span></span> 的定义，其测试给定的正则表达式是否匹配空字符串： 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="match_eps"><span class="id" type="definition">match_eps</span></a> (<span class="id" type="var">re</span>: @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab241"></a><h4 class="section">练习：3 星, optional (match_eps_refl)</h4>
 现在，请证明 <span class="inlinecode"><span class="id" type="var">match_eps</span></span> 确实测试了给定的正则表达式是否匹配空字符串。
    （提示：你会使用到互映引理 <span class="inlinecode"><span class="id" type="var">ReflectT</span></span> 和 <span class="inlinecode"><span class="id" type="var">ReflectF</span></span>。） 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="match_eps_refl"><span class="id" type="lemma">match_eps_refl</span></a> : <a class="idref" href="IndProp.html#refl_matches_eps"><span class="id" type="definition">refl_matches_eps</span></a> <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 我们将会定义其他函数也使用到 <span class="inlinecode"><span class="id" type="var">match_eps</span></span>。然而，这些函数的证明中你唯一会用到的
    <span class="inlinecode"><span class="id" type="var">match_eps</span></span> 的性质是 <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span>。
</div>

<div class="doc">
我们匹配器所进行的关键操作是迭代地构造一个正则表达式生成式的序列。
    对于字符 <span class="inlinecode"><span class="id" type="var">a</span></span> 和正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span>，<span class="inlinecode"><span class="id" type="var">re</span></span> 在 <span class="inlinecode"><span class="id" type="var">a</span></span> 上的生成式是一个正则表达式，
    其匹配所有匹配 <span class="inlinecode"><span class="id" type="var">re</span></span> 且以 <span class="inlinecode"><span class="id" type="var">a</span></span> 开始的字符串的后缀。也即，<span class="inlinecode"><span class="id" type="var">re'</span></span>
    是 <span class="inlinecode"><span class="id" type="var">re</span></span> 在 <span class="inlinecode"><span class="id" type="var">a</span></span> 上的一个生成式如果他们满足以下关系：
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="is_der"><span class="id" type="definition">is_der</span></a> <span class="id" type="var">re</span> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) <span class="id" type="var">re'</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">s</span>, <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> :: <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> ↔ <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re'"><span class="id" type="variable">re'</span></a>.<br/>
</div>

<div class="doc">
函数 <span class="inlinecode"><span class="id" type="var">d</span></span> 生成字符串如果对于给定的字符 <span class="inlinecode"><span class="id" type="var">a</span></span> 和正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span>，
    它求值为 <span class="inlinecode"><span class="id" type="var">re</span></span> 在 <span class="inlinecode"><span class="id" type="var">a</span></span> 上的生成式。也即，<span class="inlinecode"><span class="id" type="var">d</span></span> 满足以下关系： 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="derives"><span class="id" type="definition">derives</span></a> <span class="id" type="var">d</span> := <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">a</span> <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#is_der"><span class="id" type="definition">is_der</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> (<a class="idref" href="IndProp.html#d"><span class="id" type="variable">d</span></a> <a class="idref" href="IndProp.html#a"><span class="id" type="variable">a</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab242"></a><h4 class="section">练习：3 星, optional (derive)</h4>
 请定义 <span class="inlinecode"><span class="id" type="var">derive</span></span> 使其生成字符串。一个自然的实现是在某些分类使用
    <span class="inlinecode"><span class="id" type="var">match_eps</span></span> 来判断正则表达式是否匹配空字符串。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="derive"><span class="id" type="definition">derive</span></a> (<span class="id" type="var">a</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">derive</span></span> 函数应当通过以下测试。每个测试都在将被匹配器所求值的表达式和
    最终被匹配器返回的结果之间确立一种相等性。
    每个测试也被添加了它所反映的匹配事实的注解。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="c"><span class="id" type="definition">c</span></a> := <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii_of_nat"><span class="id" type="definition">ascii_of_nat</span></a> 99.<br/>
<span class="id" type="keyword">Example</span> <a name="d"><span class="id" type="definition">d</span></a> := <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii_of_nat"><span class="id" type="definition">ascii_of_nat</span></a> 100.<br/>
</div>

<div class="doc">
"c" =~ EmptySet: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der0"><span class="id" type="definition">test_der0</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#EmptySet"><span class="id" type="constructor">EmptySet</span></a>)) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Char c: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der1"><span class="id" type="definition">test_der1</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>)) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Char d: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der2"><span class="id" type="definition">test_der2</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>)) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ App (Char c) EmptyStr: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der3"><span class="id" type="definition">test_der3</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>) <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a>)) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ App EmptyStr (Char c): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der4"><span class="id" type="definition">test_der4</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> <a class="idref" href="IndProp.html#EmptyStr"><span class="id" type="constructor">EmptyStr</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"c" =~ Star c: 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der5"><span class="id" type="definition">test_der5</span></a> : <a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#Star"><span class="id" type="constructor">Star</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"cd" =~ App (Char c) (Char d): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der6"><span class="id" type="definition">test_der6</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>)))) = <a class="idref" href="Basics.html#true"><span class="id" type="constructor">true</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
"cd" =~ App (Char d) (Char c): 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Example</span> <a name="test_der7"><span class="id" type="definition">test_der7</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#match_eps"><span class="id" type="axiom">match_eps</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a> (<a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a> (<a class="idref" href="IndProp.html#App"><span class="id" type="constructor">App</span></a> (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#d"><span class="id" type="definition">d</span></a>) (<a class="idref" href="IndProp.html#Char"><span class="id" type="constructor">Char</span></a> <a class="idref" href="IndProp.html#c"><span class="id" type="definition">c</span></a>)))) = <a class="idref" href="Basics.html#false"><span class="id" type="constructor">false</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<a name="lab243"></a><h4 class="section">练习：4 星, optional (derive_corr)</h4>
 请证明 <span class="inlinecode"><span class="id" type="var">derive</span></span> 确实总是会生成字符串。

<div class="paragraph"> </div>

    提示：一种证明方法是对 <span class="inlinecode"><span class="id" type="var">re</span></span> 归纳，尽管你需要通过归纳和一般化合适的项来
    仔细选择要证明的性质。

<div class="paragraph"> </div>

    提示：如果你定义的 <span class="inlinecode"><span class="id" type="var">derive</span></span> 对某个正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 使用了 <span class="inlinecode"><span class="id" type="var">match_eps</span></span>，
    那么可对 <span class="inlinecode"><span class="id" type="var">re</span></span> 应用 <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span>，接着对结果解构并生成
    分类，其中你可以假设 <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配或不匹配空字符串。

<div class="paragraph"> </div>

    提示：通过使用之前证明过的引理可以帮助一点你的工作。特别是，在证明归纳的
    许多分类时，通过之前的引理，你可以用一个复杂的正则表达式（比如，
    <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">Union</span></span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>）来重写命题，得到一个简单正则表达式上的命
    题构成的布尔表达式（比如，<span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re<sub>0</sub></span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re<sub>1</sub></span></span>）。
    你可以使用 <span class="inlinecode"><span class="id" type="tactic">intro</span></span> 和 <span class="inlinecode"><span class="id" type="tactic">destruct</span></span> 来对这些命题进行推理。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <a name="derive_corr"><span class="id" type="lemma">derive_corr</span></a> : <a class="idref" href="IndProp.html#derives"><span class="id" type="definition">derives</span></a> <a class="idref" href="IndProp.html#derive"><span class="id" type="axiom">derive</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 我们将会使用 <span class="inlinecode"><span class="id" type="var">derive</span></span> 来定义正则表达式匹配器。然而，在匹配器的性质的证明中你唯一会用到
    的关于 <span class="inlinecode"><span class="id" type="var">derive</span></span> 的性质是 <span class="inlinecode"><span class="id" type="var">derive_corr</span></span>。 
</div>

<div class="doc">
函数 <span class="inlinecode"><span class="id" type="var">m</span></span> 匹配正则表达式如果对给定的字符串 <span class="inlinecode"><span class="id" type="var">s</span></span> 和正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span>，
    它求值的结果映射了 <span class="inlinecode"><span class="id" type="var">s</span></span> 是否被 <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配。也即，<span class="inlinecode"><span class="id" type="var">m</span></span> 满足以下性质：
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <a name="matches_regex"><span class="id" type="definition">matches_regex</span></a> <span class="id" type="var">m</span> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) <span class="id" type="var">re</span>, <a class="idref" href="IndProp.html#reflect"><span class="id" type="inductive">reflect</span></a> (<a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> =~ <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>) (<a class="idref" href="IndProp.html#m"><span class="id" type="variable">m</span></a> <a class="idref" href="IndProp.html#s"><span class="id" type="variable">s</span></a> <a class="idref" href="IndProp.html#re"><span class="id" type="variable">re</span></a>).<br/>
</div>

<div class="doc">
<a name="lab244"></a><h4 class="section">练习：2 星, optional (regex_match)</h4>
 完成 <span class="inlinecode"><span class="id" type="var">regex_match</span></span> 的定义，使其可以匹配正则表达式。
</div>
<div class="code code-tight">
<span class="id" type="keyword">Fixpoint</span> <a name="regex_match"><span class="id" type="definition">regex_match</span></a> (<span class="id" type="var">s</span> : <a class="idref" href="IndProp.html#string"><span class="id" type="definition">string</span></a>) (<span class="id" type="var">re</span> : @<a class="idref" href="IndProp.html#reg_exp"><span class="id" type="inductive">reg_exp</span></a> <a class="idref" href="http://coq.inria.fr/library/Coq.Strings.Ascii.html#ascii"><span class="id" type="inductive">ascii</span></a>) : <a class="idref" href="Basics.html#bool"><span class="id" type="inductive">bool</span></a><br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab245"></a><h4 class="section">练习：3 星, optional (regex_refl)</h4>
 最后，证明 <span class="inlinecode"><span class="id" type="var">regex_match</span></span> 确实可以匹配正则表达式。

<div class="paragraph"> </div>

    提示：如果你定义的 <span class="inlinecode"><span class="id" type="var">regex_match</span></span> 对正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 使用了 <span class="inlinecode"><span class="id" type="var">match_eps</span></span>，
    那么可对 <span class="inlinecode"><span class="id" type="var">re</span></span> 应用 <span class="inlinecode"><span class="id" type="var">match_eps_refl</span></span>，接着对结果解构并生成
    分类，其中你可以假设 <span class="inlinecode"><span class="id" type="var">re</span></span> 匹配或不匹配空字符串。

<div class="paragraph"> </div>

    提示：如果你定义的 <span class="inlinecode"><span class="id" type="var">regex_match</span></span> 对字符 <span class="inlinecode"><span class="id" type="var">x</span></span> 和正则表达式 <span class="inlinecode"><span class="id" type="var">re</span></span> 使用了 <span class="inlinecode"><span class="id" type="var">derive</span></span>，
    那么可对 <span class="inlinecode"><span class="id" type="var">x</span></span> 和 <span class="inlinecode"><span class="id" type="var">re</span></span> 应用 <span class="inlinecode"><span class="id" type="var">derive_corr</span></span>，以此证明 <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">re</span></span> 当给定
    <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode">=~</span> <span class="inlinecode"><span class="id" type="var">derive</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">re</span></span> 时，反之亦然。 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Theorem</span> <a name="regex_refl"><span class="id" type="lemma">regex_refl</span></a> : <a class="idref" href="IndProp.html#matches_regex"><span class="id" type="definition">matches_regex</span></a> <a class="idref" href="IndProp.html#regex_match"><span class="id" type="axiom">regex_match</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
</div>



</div>

</body>
</html>