<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>ProofObjects: 柯里-霍华德对应</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
</br><a href='index.html'>  <span class='booktitleinheader'>Volume 1: 逻辑基础</span><br></br>
<ul id='menu'>
   <a href='toc.html'><li class='section_name'>目录</li></a>
   <a href='coqindex.html'><li class='section_name'>索引</li></a>
   <a href='deps.html'><li class='section_name'>路线</li></a>
</ul>
</a></div>

<div id="main">

<h1 class="libtitle">ProofObjects<span class="subtitle">柯里-霍华德对应</span></h1>


<div class="code code-tight">

<span class="id" type="keyword">Set</span> <span class="id" type="var">Warnings</span> "-notation-overridden,-parsing".<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <a class="idref" href="IndProp.html#"><span class="id" type="library">IndProp</span></a>.<br/>
</div>

<div class="doc">
<div class="quote">"<b>算法是证明的计算性内容。</b>"  &mdash;Robert Harper</div> 
<div class="paragraph"> </div>

 我们已经知道Coq的机制有两种不同的目的。一种是为了<b>编程</b>，
    使用归纳数据类型如 <span class="inlinecode"><span class="id" type="var">nat</span></span> 和 <span class="inlinecode"><span class="id" type="var">list</span></span>，以及在这些类型上的函数；另一种是
    为了<b>证明</b>程序的性质，使用归纳命题（如 <span class="inlinecode"><span class="id" type="var">ev</span></span>），蕴含式，全称量化等
    等。目前为止，我们一直认为这些机制是相当不同的。有些时候，这也确实
    是比较好的思考方式。但是我们也看到过一些暗示，表明Coq的编程和证明
    的各种工具是非常相关的。例如，关键字 <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> 同时用于声明数据
    类型和命题，以及 <span class="inlinecode">→</span> 同时用于描述函数类型和逻辑蕴含式。这可并不是
    语法上的巧合！事实上，在Coq里面程序和证明几乎就是同一件事情。这一
    章我们会学习背后的原理。

<div class="paragraph"> </div>

    我们已经知道这个基础的思想：在Coq里面，可证明性表现为拥有具体的<b>证据</b>。
    当我们为一个基本的命题构造证明的时候，我们实际上是在构造证
    据树。证据树可被认为是一种数据结构。

<div class="paragraph"> </div>

    如果这个命题是一个蕴含式，像是 <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">B</span></span>，那么它的证明是一个证据
    的<b>转换器 (Transformer)</b>：一个将 A 的证据转换为 B 的证据的配方。
    所以从根本上来讲，证明仅仅就是操纵证据的程序。 
<div class="paragraph"> </div>

 问题：如果是证据是数据，那么命题本身是什么？

<div class="paragraph"> </div>

    答案：它们是类型！ 
<div class="paragraph"> </div>

 回顾一下 <span class="inlinecode"><span class="id" type="var">ev</span></span> 这个性质的形式化定义。  
</div>
<div class="code code-tight">

<span class="id" type="keyword">Print</span> <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a>.<br/>
<span class="comment">(*&nbsp;==&gt;<br/>
&nbsp;&nbsp;Inductive&nbsp;ev&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;Prop&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ev_0&nbsp;:&nbsp;ev&nbsp;0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ev_SS&nbsp;:&nbsp;forall&nbsp;n,&nbsp;ev&nbsp;n&nbsp;-&gt;&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n)).<br/>
*)</span><br/>
</div>

<div class="doc">
假设我们引入 “<span class="inlinecode">:</span>” 的另外一种阅读方式。我们不说“……的类型是……”，
    而说“……是……的证明”。例如，<span class="inlinecode"><span class="id" type="var">ev</span></span> 定义的第二行声明了 <span class="inlinecode"><span class="id" type="var">ev_0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span>。
    我们不说“<span class="inlinecode"><span class="id" type="var">ev_0</span></span> 拥有类型 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span>”，而说“<span class="inlinecode"><span class="id" type="var">ev_0</span></span> 是 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 的证明”。
    
<div class="paragraph"> </div>

 这个类型和命题之间的双关语，或者说，<span class="inlinecode">:</span> 的两种阅读方式“……的类型是……”
    和“……是……的证明”之间的双关语，称为 <b>柯里-霍华德对应 (Curry-Howard correspondence)</b>。
    它提出了逻辑世界和计算世界之间深层次的关联：

<div class="paragraph"> </div>

<pre>
                 命题           ~  类型
                 证明           ~  数据值
</pre>
    <a href="Bib.html#Wadler 2015"><span class="inlineref">[Wadler 2015]</span></a> 里有简单的历史和最新的详细介绍可供参考。 
<div class="paragraph"> </div>

 很多有用的简介都来自这一关联。首先，它赋予了 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 这个构造器的
    类型的一个自然的理解： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_SS&nbsp;:&nbsp;forall&nbsp;n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev&nbsp;n&nbsp;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ev&nbsp;(S&nbsp;(S&nbsp;n))&nbsp;*)</span><br/>
</div>

<div class="doc">
这可以读为“<span class="inlinecode"><span class="id" type="var">ev_SS</span></span>是一个构造器，接受两个参数——一个数字 <span class="inlinecode"><span class="id" type="var">n</span></span> 和一
    个命题 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>的证据——然后产生一个命题 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>))</span> 的证据。” 
<div class="paragraph"> </div>

 现在让我们回顾一下之前有关 <span class="inlinecode"><span class="id" type="var">ev</span></span> 的一个证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4"><span class="id" type="lemma">ev_4</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>. <span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>. <span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
就像是处理普通的数据值和函数一样，我们可以使用 <span class="inlinecode"><span class="id" type="keyword">Print</span></span> 命令来查看
    这个证明脚本所产生的<b>证据对象 (proof object)</b> 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#ev_4"><span class="id" type="lemma">ev_4</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_4&nbsp;=&nbsp;ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ev&nbsp;4&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
实际上，我们也可以<b>直接（directly)</b>写出证明对象本身，不需要一个单独的证明脚本。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev&nbsp;4&nbsp;*)</span><br/>
</div>

<div class="doc">
表达式 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> <span class="inlinecode">2</span> <span class="inlinecode">(<span class="id" type="var">ev_SS</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" type="var">ev_0</span>)</span> 可以被认为是将参数化的构造器
    <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 使用具体的参数 <span class="inlinecode">2</span>， <span class="inlinecode">0</span>，以及它们对应的证明对象 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">2</span> 和
    <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">0</span> 给实例化了。 或者，我们可以将 <span class="inlinecode"><span class="id" type="var">ev_SS</span></span> 认为是一个原子的“对
    象构造器”，当被应用到一个具体的数字时，它要求给出这个数字是偶数的
    证据。这个功能可以通过它的类型 <span class="inlinecode">[</span> <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)),</span> <span class="inlinecode">]</span> 看
    出；类似的例子有，多态类型 <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">X</span>,</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">X</span></span> 表明了构造器 <span class="inlinecode"><span class="id" type="var">nil</span></span> 可以被认为
    是一个从类型到该类型的空列表的函数。 
<div class="paragraph"> </div>

 我们在 <a href="Logic.html"><span class="inlineref">Logic</span></a> 这一章中已经了解到，我们可以使用函数应用
    的语法来实例化引理中的全称量化变量，也可以使用该语法提供引理所要求
    的假设。例如： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4'"><span class="id" type="lemma">ev_4'</span></a>: <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)).<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab257"></a><h1 class="section">证明脚本</h1>

<div class="paragraph"> </div>

 我们一直在讨论的<b>证明对象 (proof objects)</b>是Coq如何运作的核心。
    当Coq执行一个证明脚本的时候，在内部，Coq逐渐构造出一个证明对象——
    一个类型是想要证明的命题的项。在 <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> 和 <span class="inlinecode"><span class="id" type="keyword">Qed</span></span> 之间的策略告诉
    Coq如何构造该项。为了了解这个过程是如何进行的，在下面的策略证明里，
    我们在多个地方使用 <span class="inlinecode"><span class="id" type="keyword">Show</span></span> <span class="inlinecode"><span class="id" type="keyword">Proof</span></span> 命令来显示当前证明树的状态。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_4''"><span class="id" type="lemma">ev_4''</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
在任意的给定时刻，Coq已经构造了一个包含一个“洞(hole)”（即
    <span class="inlinecode">?<span class="id" type="keyword">Goal</span></span> ）的项，并且Coq知道该洞需要什么类型的证据来填补。

<div class="paragraph"> </div>

    每一个洞对应一个子目标。当没有子目标时，代表证明已经完成。此时，我
    们构造的证明将会以我们在 <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span> 里给定的名字被存储在全局环境中。 
<div class="paragraph"> </div>

 策略证明非常有用且方便，但是它们并不是必要的：原则上，我们总是能够
    手动构造想要的证据，如下所示。此处我们可以通过 <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> （而不
    是 <span class="inlinecode"><span class="id" type="keyword">Theorem</span></span>）来直接给这个证据一个全局名称。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_4'''"><span class="id" type="definition">ev_4'''</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4 :=<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>).<br/>
</div>

<div class="doc">
所有这些构造证明的不同方式，对应的存储在全局环境中的证明是完全一样的。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#ev_4"><span class="id" type="lemma">ev_4</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_4&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0)&nbsp;:&nbsp;ev&nbsp;4&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#ev_4'"><span class="id" type="lemma">ev_4'</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_4'&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0)&nbsp;:&nbsp;ev&nbsp;4&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#ev_4''"><span class="id" type="lemma">ev_4''</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_4''&nbsp;&nbsp;=&nbsp;&nbsp;&nbsp;ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0)&nbsp;:&nbsp;ev&nbsp;4&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#ev_4'''"><span class="id" type="definition">ev_4'''</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;ev_4'''&nbsp;=&nbsp;&nbsp;&nbsp;ev_SS&nbsp;2&nbsp;(ev_SS&nbsp;0&nbsp;ev_0)&nbsp;:&nbsp;ev&nbsp;4&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab258"></a><h4 class="section">练习：2 星 (eight_is_even)</h4>
 写出对应 <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">8</span> 的策略证明和证明对象。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_8"><span class="id" type="lemma">ev_8</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 8.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="ev_8'"><span class="id" type="definition">ev_8'</span></a> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 8 <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab259"></a><h1 class="section">量词，蕴含式，函数</h1>

<div class="paragraph"> </div>

 在Coq的计算世界里（即所有的数据结构和程序存在的地方），有两种值的
    类型里拥有箭头：<b>构造子(Constructors)</b>，通过归纳地定义数据类型
    引入，和<b>函数(Functions)</b>。

<div class="paragraph"> </div>

    类似地，在Coq的逻辑世界里（即我们运用证明的地方），有两种方式来给
    与蕴含式需要的证据：构造子，通过归纳地定义命题引入，和...函数！
    
<div class="paragraph"> </div>

 例如，考虑下列陈述： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Theorem</span> <a name="ev_plus4"><span class="id" type="lemma">ev_plus4</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">n</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
对应 <span class="inlinecode"><span class="id" type="var">ev_plus4</span></span> 的证明对象是什么？

<div class="paragraph"> </div>

    我们在寻找一个<b>类型(Type)</b>是 <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode"><span class="id" type="var">n</span>,</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode">(4</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span>)</span> 的表达式——也
    就是说，一个接受两个参数（一个数字和一个证据）并返回一个证据的
    <b>函数(Function)</b>!

<div class="paragraph"> </div>

    它的证据对象： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_plus4'"><span class="id" type="definition">ev_plus4'</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) ⇒ <span class="id" type="keyword">fun</span> (<span class="id" type="var">H</span> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>)) (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a>).<br/>
</div>

<div class="doc">
回顾 <span class="inlinecode"><span class="id" type="keyword">fun</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">blah</span></span> 意味着“一个函数，给定 <span class="inlinecode"><span class="id" type="var">n</span></span>，产生 <span class="inlinecode"><span class="id" type="var">blah</span></span>”，
    并且Coq认为 <span class="inlinecode">4</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">n</span></span> 和 <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode">(<span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span>)))</span> 是同义词，所以另一种写出
    这个定义的方式是： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_plus4''"><span class="id" type="definition">ev_plus4''</span></a> (<span class="id" type="var">n</span> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>) (<span class="id" type="var">H</span> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (4 + <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>)) (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> <a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a>).<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Check</span> <a class="idref" href="ProofObjects.html#ev_plus4''"><span class="id" type="definition">ev_plus4''</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n&nbsp;-&gt;&nbsp;ev&nbsp;(4&nbsp;+&nbsp;n)&nbsp;*)</span><br/>
</div>

<div class="doc">
当我们将 <span class="inlinecode"><span class="id" type="var">ev_plus4</span></span> 证明的命题视为一个函数类型时，我们可以发现一个
    有趣的现象：第二个参数的类型，<span class="inlinecode"><span class="id" type="var">ev</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span>，依赖于第一个参数 <span class="inlinecode"><span class="id" type="var">n</span></span> 的<b>值</b>。

<div class="paragraph"> </div>

    虽然这样的<b>依赖类型 (Dependent types)</b>在传统的编程语言中并不存在，
    但是它们对于编程来说有时候非常有用。最近它们在函数式编程社区里的活
    跃很好地表明了这一点。 
<div class="paragraph"> </div>

 注意到蕴含式（<span class="inlinecode">→</span>）和量化（<span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span>）都表示证据上的函数。事实上，他们
    是同一个东西：当我们使用<span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span>时没有依赖，就可以简写为当<span class="inlinecode">→</span>。即，我
    们没有必要给与箭头左边的类型一个名字：<span class="inlinecode">[</span> <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode">(<span class="id" type="var">x</span>:<span class="id" type="var">nat</span>),</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode">(<span class="id" type="var">_</span>:<span class="id" type="var">nat</span>),</span>
    <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">]</span> 
<div class="paragraph"> </div>

 例如，考虑下列命题： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_plus2"><span class="id" type="definition">ev_plus2</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">E</span> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>), <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> + 2).<br/>
</div>

<div class="doc">
这个命题的一个证明项会是一个拥有两个参数的函数：一个数字<span class="inlinecode"><span class="id" type="var">n</span></span>
    和一个表明<span class="inlinecode"><span class="id" type="var">n</span></span>是偶数的证据<span class="inlinecode"><span class="id" type="var">E</span></span>。但是对于这个证据来说，名字<span class="inlinecode"><span class="id" type="var">E</span></span>并没有
    在<span class="inlinecode"><span class="id" type="var">ev_plus2</span></span>剩余的陈述里面被使用，所以还专门为它取一个名字并没有意
    义。因此我们可以使用虚拟标志符<span class="inlinecode"><span class="id" type="var">_</span></span>来替换真实的名字： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_plus2'"><span class="id" type="definition">ev_plus2'</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">_</span> : <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>), <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> + 2).<br/>
</div>

<div class="doc">
或者，等同地，我们可以使用更加熟悉的记号： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="ev_plus2''"><span class="id" type="definition">ev_plus2''</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> → <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> + 2).<br/>
</div>

<div class="doc">
总的来说，"<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>"只是 "<span class="inlinecode"><span style='font-size:120%;'>&forall;</span></span><span class="inlinecode">(<span class="id" type="var">_</span>:<span class="id" type="var">P</span>),</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>"的语法糖。 
</div>

<div class="doc">
<a name="lab260"></a><h1 class="section">使用策略编程</h1>

<div class="paragraph"> </div>

 如果我们可以通过显式地给出项，而不是执行策略脚本，来构造证明，你可
    能会好奇我们是否可以通过<b>策略</b>，而不是显式地给出项，来构造<b>程序</b>。
    自然地，答案是可以！
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="add1"><span class="id" type="definition">add1</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a> → <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat"><span class="id" type="inductive">nat</span></a>.<br/>
<span class="id" type="tactic">intro</span> <span class="id" type="var">n</span>.<br/>
<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a>.<br/>
<span class="id" type="keyword">Show</span> <span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="tactic">apply</span> <span class="id" type="var">n</span>. <span class="id" type="keyword">Defined</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Print</span> <a class="idref" href="ProofObjects.html#add1"><span class="id" type="definition">add1</span></a>.<br/>
<span class="comment">(*&nbsp;==&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;add1&nbsp;=&nbsp;fun&nbsp;n&nbsp;:&nbsp;nat&nbsp;=&gt;&nbsp;S&nbsp;n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;nat<br/>
*)</span><br/><hr class='doublespaceincode'/>
<span class="id" type="var">Compute</span> <a class="idref" href="ProofObjects.html#add1"><span class="id" type="definition">add1</span></a> 2.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;3&nbsp;:&nbsp;nat&nbsp;*)</span><br/>
</div>

<div class="doc">
注意到我们通过使用<span class="inlinecode">.</span>终止了<span class="inlinecode"><span class="id" type="keyword">Definition</span></span>，而不是使用<span class="inlinecode">:=</span>和一个项来
    定义它。这个记号会告诉Coq进入<b>证明脚本模式(Proof Scripting
    Mode)</b>来构造类型是<span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span></span>的项。并且，我们通过使用<span class="inlinecode"><span class="id" type="keyword">Defined</span></span>而不是
    <span class="inlinecode"><span class="id" type="keyword">Qed</span></span>来终止证明；这使得这个定义是<b>透明的(Transparent)</b>，所以它可
    以在计算中就像正常定义的函数一样被使用。（通过<span class="inlinecode"><span class="id" type="keyword">Qed</span></span>定义的对象在计
    算中是不透明的。）

<div class="paragraph"> </div>

    这个特性主要是在定义拥有依赖类型的函数时非常有用。我们不会在本书中
    详细讨论后者。但是它确实表明了Coq里面基本思想的一致性和正交性。 
</div>

<div class="doc">
<a name="lab261"></a><h1 class="section">逻辑联结词作为归纳类型</h1>

<div class="paragraph"> </div>

 归纳定义足够用于表达我们目前为止遇到的大多数的联结词和量词。事实上，
    只有全称量化（因此也包括蕴含式）是Coq内置的，所有其他的都是被归纳
    定义的。在这一节中我们会看到它们的定义。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Props"><span class="id" type="module">Props</span></a>.<br/>
</div>

<div class="doc">
<a name="lab262"></a><h2 class="section">合取</h2>


<div class="paragraph"> </div>

    为了证明<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>成立，我们必须同时给出<span class="inlinecode"><span class="id" type="var">P</span></span>和<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据。因此，我们可
    以合理地将<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证明对象定义为包含两个证明的元祖：一个是<span class="inlinecode"><span class="id" type="var">P</span></span>的
    证明，另一个是<span class="inlinecode"><span class="id" type="var">Q</span></span>的证明。即我们拥有如下定义。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Props.And"><span class="id" type="module">And</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="Props.And.and"><span class="id" type="inductive">and</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="Props.And.conj"><span class="id" type="constructor">conj</span></a> : <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#and"><span class="id" type="inductive">and</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="ProofObjects.html#Props.And"><span class="id" type="module">And</span></a>.<br/>
</div>

<div class="doc">
注意到这个定义与在章节<a href="Poly.html"><span class="inlineref">Poly</span></a>中给出的<span class="inlinecode"><span class="id" type="var">prod</span></span>定义的类型的相似处；
    唯一的不同之处在于，<span class="inlinecode"><span class="id" type="var">prod</span></span>的参数是<span class="inlinecode"><span class="id" type="keyword">Type</span></span>，而<span class="inlinecode"><span class="id" type="var">and</span></span>的类型是<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Print</span> <a class="idref" href="Poly.html#prod"><span class="id" type="inductive">prod</span></a>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;Inductive&nbsp;prod&nbsp;(X&nbsp;Y&nbsp;:&nbsp;Type)&nbsp;:&nbsp;Type&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;|&nbsp;pair&nbsp;:&nbsp;X&nbsp;-&gt;&nbsp;Y&nbsp;-&gt;&nbsp;X&nbsp;*&nbsp;Y.&nbsp;*)</span><br/>
</div>

<div class="doc">
这个定义能够解释为什么<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>和<span class="inlinecode"><span class="id" type="tactic">intros</span></span>模式能用于一个合取前提。
    情况分析允许我们考虑所有<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>可能被证明的方式——只有一种方式（即
    <span class="inlinecode"><span class="id" type="var">conj</span></span>构造子）。类似地，<span class="inlinecode"><span class="id" type="tactic">split</span></span>策略能够用于所有只有一个构造子的归
    纳定义命题。特别地，它能够用于<span class="inlinecode"><span class="id" type="var">and</span></span>： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="Props.and_comm"><span class="id" type="lemma">and_comm</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∧ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ↔ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ∧ <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>]. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">intros</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>]. <span class="id" type="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
这解释了为什么一直以来我们能够使用策略来操作<span class="inlinecode"><span class="id" type="var">and</span></span>的归纳定义。我们
    也可以使用模式匹配来用它直接构造证明。例如： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="Props.and_comm'_aux"><span class="id" type="definition">and_comm'_aux</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> (<span class="id" type="var">H</span> : <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∧ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <a class="idref" href="ProofObjects.html#H"><span class="id" type="variable">H</span></a> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#conj"><span class="id" type="constructor">conj</span></a> <span class="id" type="var">HP</span> <span class="id" type="var">HQ</span> ⇒ <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#conj"><span class="id" type="constructor">conj</span></a> <span class="id" type="var">HQ</span> <span class="id" type="var">HP</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="Props.and_comm'"><span class="id" type="definition">and_comm'</span></a> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∧ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ↔ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ∧ <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#conj"><span class="id" type="constructor">conj</span></a> (<a class="idref" href="ProofObjects.html#Props.and_comm'_aux"><span class="id" type="definition">and_comm'_aux</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a>) (<a class="idref" href="ProofObjects.html#Props.and_comm'_aux"><span class="id" type="definition">and_comm'_aux</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a>).<br/>
</div>

<div class="doc">
<a name="lab263"></a><h4 class="section">练习：2 星, optional (conj_fact)</h4>
 构造一个证明对象来证明下列命题。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="Props.conj_fact"><span class="id" type="definition">conj_fact</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∧ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ∧ <a class="idref" href="ProofObjects.html#R"><span class="id" type="variable">R</span></a> → <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∧ <a class="idref" href="ProofObjects.html#R"><span class="id" type="variable">R</span></a> <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab264"></a><h2 class="section">析取</h2>


<div class="paragraph"> </div>

    析取的归纳定义有两个构造子，分别用于析取的两边： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Props.Or"><span class="id" type="module">Or</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="Props.Or.or"><span class="id" type="inductive">or</span></a> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="Props.Or.or_introl"><span class="id" type="constructor">or_introl</span></a> : <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> → <a class="idref" href="ProofObjects.html#or"><span class="id" type="inductive">or</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a><br/>
| <a name="Props.Or.or_intror"><span class="id" type="constructor">or_intror</span></a> : <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#or"><span class="id" type="inductive">or</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="ProofObjects.html#Props.Or"><span class="id" type="module">Or</span></a>.<br/>
</div>

<div class="doc">
这个声明解释了<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>策略在一个析取前提上的行为，产生的子类型和
    <span class="inlinecode"><span class="id" type="var">or_introl</span></span>以及<span class="inlinecode"><span class="id" type="var">or_intror</span></span>构造子的形状相匹配。

<div class="paragraph"> </div>

    又一次地，我们可以不使用策略，直接写出涉及<span class="inlinecode"><span class="id" type="var">or</span></span>的定义的证明对象。 
<div class="paragraph"> </div>

<a name="lab265"></a><h4 class="section">练习：2 星, optional (or_commut'')</h4>
 尝试写下<span class="inlinecode"><span class="id" type="var">or_commut</span></span>的显式证明对象。（不要使用<span class="inlinecode"><span class="id" type="keyword">Print</span></span>来偷看我们已经
    定义的版本！） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="Props.or_comm"><span class="id" type="definition">or_comm</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> ∨ <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> → <a class="idref" href="ProofObjects.html#Q"><span class="id" type="variable">Q</span></a> ∨ <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab266"></a><h2 class="section">存在量化</h2>


<div class="paragraph"> </div>

    为了给出存在量词的证据，我们将一个证据类型<span class="inlinecode"><span class="id" type="var">x</span></span>和<span class="inlinecode"><span class="id" type="var">x</span></span>满足性质<span class="inlinecode"><span class="id" type="var">P</span></span>的证明打包在一起： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="Props.Ex"><span class="id" type="module">Ex</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="Props.Ex.ex"><span class="id" type="inductive">ex</span></a> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">P</span> : <a class="idref" href="ProofObjects.html#A"><span class="id" type="variable">A</span></a> → <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="Props.Ex.ex_intro"><span class="id" type="constructor">ex_intro</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span> : <a class="idref" href="ProofObjects.html#A"><span class="id" type="variable">A</span></a>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> → <a class="idref" href="ProofObjects.html#ex"><span class="id" type="inductive">ex</span></a> <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="ProofObjects.html#Props.Ex"><span class="id" type="module">Ex</span></a>.<br/>
</div>

<div class="doc">
打包之后的命题可以通过解包操作受益。这里的核心定义是为了用于构造
    <span class="inlinecode"><span class="id" type="var">ex</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>命题的类型构造器<span class="inlinecode"><span class="id" type="var">ex</span></span>，其中<span class="inlinecode"><span class="id" type="var">P</span></span>自身是一个从类型为<span class="inlinecode"><span class="id" type="var">A</span></span>的证据类型
    值到命题的<b>函数(Function)</b>。构造子<span class="inlinecode"><span class="id" type="var">ex_intro</span></span>提供了一个给定
    证据类型<span class="inlinecode"><span class="id" type="var">x</span></span>和<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>的证 明，可以构造<span class="inlinecode"><span class="id" type="var">ex</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>的证据的方式。 
<div class="paragraph"> </div>

 我们更加熟悉的类型<span class="inlinecode"><span style='font-size:120%;'>&exist;</span></span><span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>可以转换为一个涉及<span class="inlinecode"><span class="id" type="var">ex</span></span>的表达式： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#ex"><span class="id" type="inductive">ex</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> ⇒ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>).<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;exists&nbsp;n&nbsp;:&nbsp;nat,&nbsp;ev&nbsp;n<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Prop&nbsp;*)</span><br/>
</div>

<div class="doc">
下面是我们如何定义一个涉及<span class="inlinecode"><span class="id" type="var">ex</span></span>的显式证明对象： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="Props.some_nat_is_even"><span class="id" type="definition">some_nat_is_even</span></a> : <span style='font-size:120%;'>&exist;</span> <span class="id" type="var">n</span>, <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#ex_intro"><span class="id" type="constructor">ex_intro</span></a> <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> 4 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 2 (<a class="idref" href="IndProp.html#ev_SS"><span class="id" type="constructor">ev_SS</span></a> 0 <a class="idref" href="IndProp.html#ev_0"><span class="id" type="constructor">ev_0</span></a>)).<br/>
</div>

<div class="doc">
<a name="lab267"></a><h4 class="section">练习：2 星, optional (ex_ev_Sn)</h4>
 完成下列证明对象的定义： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="Props.ex_ev_Sn"><span class="id" type="definition">ex_ev_Sn</span></a> : <a class="idref" href="http://coq.inria.fr/library/Coq.Init.Logic.html#ex"><span class="id" type="inductive">ex</span></a> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> ⇒ <a class="idref" href="IndProp.html#ev"><span class="id" type="inductive">ev</span></a> (<a class="idref" href="http://coq.inria.fr/library/Coq.Init.Datatypes.html#S"><span class="id" type="constructor">S</span></a> <a class="idref" href="ProofObjects.html#n"><span class="id" type="variable">n</span></a>)) <br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;将本行替换成&nbsp;":=&nbsp;_你的_定义_&nbsp;."&nbsp;*)</span>. <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab268"></a><h2 class="section"><span class="inlinecode"><span class="id" type="var">True</span></span>和<span class="inlinecode"><span class="id" type="var">False</span></span></h2>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">True</span></span>命题的归纳定义很简单： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="Props.True"><span class="id" type="inductive">True</span></a> : <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a name="Props.I"><span class="id" type="constructor">I</span></a> : <a class="idref" href="ProofObjects.html#True"><span class="id" type="inductive">True</span></a>.<br/>
</div>

<div class="doc">
它拥有一个构造子（因此<span class="inlinecode"><span class="id" type="var">True</span></span>的所有证据都是一样的，所以给出一个
    <span class="inlinecode"><span class="id" type="var">True</span></span>的证明并没有信息量。） 
<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">False</span></span>也一样的简单——事实上，它是如此简单，以致于第一眼看上去像是一个
    语法错误。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Inductive</span> <a name="Props.False"><span class="id" type="inductive">False</span></a> : <span class="id" type="keyword">Prop</span> :=.<br/>
</div>

<div class="doc">
也就是说， <span class="inlinecode"><span class="id" type="var">False</span></span>是一个<b>没有</b>构造子的归纳类型&mdash;即，没有任何方式能
    够构造一个它的证明。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">End</span> <a class="idref" href="ProofObjects.html#Props"><span class="id" type="module">Props</span></a>.<br/>
</div>

<div class="doc">
<a name="lab269"></a><h1 class="section">相等性</h1>

<div class="paragraph"> </div>

 在Coq里，甚至连相等性都不是内置的。它拥有如下的归纳定义。（事实上，
    在标准库里的定义是这里给出的定义的轻微变体，前者给出了稍微容易使用
    一些的归纳原理。） 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Module</span> <a name="MyEquality"><span class="id" type="module">MyEquality</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Inductive</span> <a name="MyEquality.eq"><span class="id" type="inductive">eq</span></a> {<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>} : <span class="id" type="var">X</span> → <span class="id" type="var">X</span> → <span class="id" type="keyword">Prop</span> :=<br/>
| <a name="MyEquality.eq_refl"><span class="id" type="constructor">eq_refl</span></a> : <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">x</span>, <a class="idref" href="ProofObjects.html#eq"><span class="id" type="inductive">eq</span></a> <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a>.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Notation</span> "x = y" := (<a class="idref" href="ProofObjects.html#MyEquality.eq"><span class="id" type="inductive">eq</span></a> <span class="id" type="var">x</span> <span class="id" type="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 70, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">type_scope</span>.<br/>
</div>

<div class="doc">
我们可以这样理解这个定义，给定一个集合<span class="inlinecode"><span class="id" type="var">X</span></span>，它定义了由<span class="inlinecode"><span class="id" type="var">X</span></span>的一对值
    (<span class="inlinecode"><span class="id" type="var">x</span></span>和<span class="inlinecode"><span class="id" type="var">y</span></span>)所索引的“<span class="inlinecode"><span class="id" type="var">x</span></span>与<span class="inlinecode"><span class="id" type="var">y</span></span>相等”的一<b>系列(Family)</b>的命题。只有
    一种方式能够构造该系列中任意成员的证据：将构造子<span class="inlinecode"><span class="id" type="var">eq_refl</span></span>应用到一
    个类型<span class="inlinecode"><span class="id" type="var">X</span></span>和一个值<span class="inlinecode"><span class="id" type="var">x</span>:<span class="id" type="var">X</span></span>，产生一个<span class="inlinecode"><span class="id" type="var">x</span></span>等于<span class="inlinecode"><span class="id" type="var">x</span></span>的证据。 
<div class="paragraph"> </div>

 我们可以使用<span class="inlinecode"><span class="id" type="var">eq_refl</span></span>来构造证据，比如说，<span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>。那么我们能否使用
    它来构造证据<span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>呢？答案是肯定的。事实上，它就是同一个证据！

<div class="paragraph"> </div>

    原因是如果两个项能够通过一些简单的计算规则<b>可转换(convertible)</b> ，
    那么Coq认为两者“相等”。

<div class="paragraph"> </div>

    这些计算规则，与<span class="inlinecode"><span class="id" type="var">Compute</span></span>所使用的规则相似，包括函数应用的计算，定
    义的内联，<span class="inlinecode"><span class="id" type="keyword">match</span></span>语句的化简。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="MyEquality.four"><span class="id" type="lemma">four</span></a>: 2 + 2 = 1 + 3.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">apply</span> <a class="idref" href="ProofObjects.html#MyEquality.eq_refl"><span class="id" type="constructor">eq_refl</span></a>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
至今为止我们所用来证据相等性的<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>策略本质上只是<span class="inlinecode"><span class="id" type="tactic">apply</span></span>
    <span class="inlinecode"><span class="id" type="var">eq_refl</span></span>的简写。

<div class="paragraph"> </div>

    在基于策略的相等性证明中，转换规则通常隐藏在<span class="inlinecode"><span class="id" type="tactic">simpl</span></span>的使用后面（在
    其他策略中或显式或隐式，例如<span class="inlinecode"><span class="id" type="tactic">reflexivity</span></span>）。

<div class="paragraph"> </div>

    而在如下的显式证明对象中，你可以直接看到它们： 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Definition</span> <a name="MyEquality.four'"><span class="id" type="definition">four'</span></a> : 2 + 2 = 1 + 3 :=<br/>
&nbsp;&nbsp;<a class="idref" href="ProofObjects.html#MyEquality.eq_refl"><span class="id" type="constructor">eq_refl</span></a> 4.<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">Definition</span> <a name="MyEquality.singleton"><span class="id" type="definition">singleton</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span>:<a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>), []++[<a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a>] = <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a>::[]  :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">fun</span> (<span class="id" type="var">X</span>:<span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span>:<a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>) ⇒ <a class="idref" href="ProofObjects.html#MyEquality.eq_refl"><span class="id" type="constructor">eq_refl</span></a> [<a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a>].<br/><hr class='doublespaceincode'/>
<span class="id" type="keyword">End</span> <a class="idref" href="ProofObjects.html#MyEquality"><span class="id" type="module">MyEquality</span></a>.<br/>
</div>

<div class="doc">
<a name="lab270"></a><h4 class="section">练习：2 星 (equality__leibniz_equality)</h4>
 相等性的归纳定义隐含了<b>Leibniz相等性(Leibniz equality)</b>：当我们
    说“<span class="inlinecode"><span class="id" type="var">x</span></span>和<span class="inlinecode"><span class="id" type="var">y</span></span>相等的时候”，我们意味着所有<span class="inlinecode"><span class="id" type="var">x</span></span>满足的性质<span class="inlinecode"><span class="id" type="var">P</span></span>，对于<span class="inlinecode"><span class="id" type="var">y</span></span>
    来说也满足。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="equality__leibniz_equality"><span class="id" type="lemma">equality__leibniz_equality</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span>: <a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="ProofObjects.html#y"><span class="id" type="variable">y</span></a> → <span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span>:<a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>→<span class="id" type="keyword">Prop</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> → <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#y"><span class="id" type="variable">y</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab271"></a><h4 class="section">练习：5 星, optional (leibniz_equality__equality)</h4>
 请说明，事实上，相等性的归纳定义和Leibniz相等性是
    <b>等价的(equivalent)</b>。 
</div>
<div class="code code-tight">

<span class="id" type="keyword">Lemma</span> <a name="leibniz_equality__equality"><span class="id" type="lemma">leibniz_equality__equality</span></a> : <span style='font-size:120%;'>&forall;</span> (<span class="id" type="var">X</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">x</span> <span class="id" type="var">y</span>: <a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>),<br/>
&nbsp;&nbsp;(<span style='font-size:120%;'>&forall;</span> <span class="id" type="var">P</span>:<a class="idref" href="ProofObjects.html#X"><span class="id" type="variable">X</span></a>→<span class="id" type="keyword">Prop</span>, <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> → <a class="idref" href="ProofObjects.html#P"><span class="id" type="variable">P</span></a> <a class="idref" href="ProofObjects.html#y"><span class="id" type="variable">y</span></a>) → <a class="idref" href="ProofObjects.html#x"><span class="id" type="variable">x</span></a> = <a class="idref" href="ProofObjects.html#y"><span class="id" type="variable">y</span></a>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="comment">(*&nbsp;请在此处解答&nbsp;*)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab272"></a><h2 class="section">反演, 再一次</h2>

<div class="paragraph"> </div>

 我们曾经见过<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>被同时用于相等性前提，和关于被归纳定义的命
    题的前提。现在我们明白了实际上它们是同一件事情。那么我们现在可以细
    究一下<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>是如何工作的。

<div class="paragraph"> </div>

    一般来说，<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>策略...

<div class="paragraph"> </div>

<ul class="doclist">
<li> 接受一个前提<span class="inlinecode"><span class="id" type="var">H</span></span>，该前提的类型<span class="inlinecode"><span class="id" type="var">P</span></span>是通过归纳定义的，以及

<div class="paragraph"> </div>


</li>
<li> 对于<span class="inlinecode"><span class="id" type="var">P</span></span>的定义里的每一个构造子<span class="inlinecode"><span class="id" type="var">C</span></span>，

<div class="paragraph"> </div>

<ul class="doclist">
<li> 产生一个新的子目标，在该子目标中我们假设<span class="inlinecode"><span class="id" type="var">H</span></span>是通过<span class="inlinecode"><span class="id" type="var">C</span></span>构造的，

<div class="paragraph"> </div>


</li>
<li> 作为额外的假设，在子目标的上下文中增加<span class="inlinecode"><span class="id" type="var">C</span></span>的论据（前提），

<div class="paragraph"> </div>


</li>
<li> 将<span class="inlinecode"><span class="id" type="var">C</span></span>的结论（结果类型）与当前的目标相匹配，计算出为了能够应用<span class="inlinecode"><span class="id" type="var">C</span></span>而必须成立的一些相等关系，

<div class="paragraph"> </div>


</li>
<li> 将这些相等关系加入上下文中（以及，为了方便，在目标中替换它们），以及

<div class="paragraph"> </div>


</li>
<li> 如果这些相等关系无法满足（例如，它们涉及到<span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode"><span class="id" type="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">O</span></span>），那么立即解决这个子目标。 
</li>
</ul>

</li>
</ul>

<div class="paragraph"> </div>

 <b>例子</b>：如果我们反演一个使用<span class="inlinecode"><span class="id" type="var">or</span></span>构造的前提，它有两个构
    造子，所以产生了两个子目标。构造子的结论（结果类型，即<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>）
    并没有对于<span class="inlinecode"><span class="id" type="var">P</span></span>和<span class="inlinecode"><span class="id" type="var">Q</span></span>的形式有任何要求，所以在子目标的上下文中我们不会
    获得额外的相等关系。 
<div class="paragraph"> </div>

 <b>例子</b>：如果我们反演一个使用<span class="inlinecode"><span class="id" type="var">and</span></span>构造的前提，它只有一个构造子，
    所以只产生一个子目标。再一次地，构造子的结论（结果类型，即<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>）
    并没有对于<span class="inlinecode"><span class="id" type="var">P</span></span>和<span class="inlinecode"><span class="id" type="var">Q</span></span>的形式有任何要求，所以在子目标的上下文中我们不会
    获得额外的相等关系。不过，这个构造子有两个额外的参数，我们能够在子
    目标的上下文中看到它们。 
<div class="paragraph"> </div>

 <b>例子</b>：如果我们反演一个使用<span class="inlinecode"><span class="id" type="var">eq</span></span>构造的前提，它也只有一个构造子，
    所以只产生一个子目标。但是，现在<span class="inlinecode"><span class="id" type="var">refl_equal</span></span>构造子的形式给我们带来
    的额外的信息：它告诉<span class="inlinecode"><span class="id" type="var">eq</span></span>的两个参数必须是一样的。于是<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>策
    略会将这个事实加入到上下文中。 
</div>
</div>



</div>

</body>
</html>