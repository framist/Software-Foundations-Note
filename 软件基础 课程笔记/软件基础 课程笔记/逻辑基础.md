---
title: 逻辑基础
date: 2022-11-26T01:03:43Z
lastmod: 2023-02-20T16:23:27Z
---

# 逻辑基础

[逻辑基础 (coq-zh.github.io)](https://coq-zh.github.io/SF-zh/lf-current/index.html)

## 前言    (Preface)

*coq 环境搭建参照章节归纳证明（Induction）开头*

‍

每一章都包含大量的习题。每个习题都有标有“星级”，其含义是：

* 一星：很简单习题，强调课程的重点。对于大部分读者而言， 一两分钟应该足够了。养成看到一个做一个的习惯。
* 二星：直截了当的习题（5 到 10 分钟）。
* 三星：需要一点思考的习题（10 分钟到半小时）。

‍

```coq
If you want to refer to this volume in your own writing, please do so as follows:
    @book            {Pierce:SF1,
    author       =   {Benjamin C. Pierce and
                      Arthur Azevedo de Amorim and
                      Chris Casinghino and
                      Marco Gaboardi and
                      Michael Greenberg and
                      Cătălin Hriţcu and
                      Vilhelm Sjöberg and
                      Brent Yorgey},
    editor       =   {Benjamin C. Pierce},
    title        =   "Logical Foundations",
    series       =   "Software Foundations",
    volume       =   "1",
    year         =   "2022",
    publisher    =   "Electronic textbook",
    note         =   {Version 6.2, \URL{http://softwarefoundations.cis.upenn.edu}}
    }

如果你想在自己的作品中引用本书，请采用以下格式：
   @book {Pierce:SF1,
   author = {Benjamin C. Pierce and Arthur Azevedo de Amorim and Chris Casinghino and Marco Gaboardi and Michael Greenberg and Cătălin Hriţcu and Vilhelm Sjöberg and Brent Yorgey},
   title = "逻辑基础",
   series = "Software Foundations",
   volume = "1",
   year = "2022",
   publisher = "Electronic textbook",
   note = {Version 5.7, \URL{http://softwarefoundations.cis.upenn.edu} },
   }
```

课程视频

*'《逻辑基础》'*夏季加强班（DeepSpec 夏季班系列之一）的课程讲义可访问 [https://deepspec.org/event/dsss17](https://deepspec.org/event/dsss17) 和 [https://deepspec.org/event/dsss18/](https://deepspec.org/event/dsss18/) 获取。2017 年的视频清晰度不高，但在之后的课程中会更好。

‍

章节依赖

章节之间的依赖关系图以及建议的学习路线可以在文件 [deps.html](https://coq-zh.github.io/SF-zh/lf-current/deps.html) 中查看。

‍

## Coq 函数式编程    (Basics)

* [引言](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab19)
* [数据与函数](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab20)

  * [枚举类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab21)
  * [一周七日](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab22)
  * [作业提交指南](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab23)
  * [布尔值](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab24)
  * [类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab27)
  * [由旧类型构造新类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab28)
  * [元组](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab29)
  * [模块](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab30)
  * [数值](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab31)
* [基于化简的证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab34)
* [基于改写的证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab35)
* [利用分类讨论来证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab38)
* [关于记法的更多内容 (可选)](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab41)
* [不动点 ](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)​**[Fixpoint](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)**​[ 和结构化递归 (可选)](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)
* [更多练习](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab44)

### 数据与函数

一周七日

```coq
Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

Definition next_weekday (d:day) : day :=
  match d with
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => monday
  | saturday  => monday
  | sunday    => monday
  end.

Compute (next_weekday friday).
(* ==> monday : day *)
Compute (next_weekday (next_weekday saturday)).
(* ==> tuesday : day *)

Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
Proof. simpl. reflexivity. Qed.
```

‍

​#TODO#​ 第三，我们可以让 Coq 从 **Definition** 中*'提取（Extract）'* 出用其它更加常规的编程语言编写的程序 （如 OCaml、Scheme、Haskell 等），它们拥有高性能的编译器。 这种能力非常有用，我们可以通过它将 Gallina 编写的 *'证明正确'* 的算法转译成高效的机器码。（诚然，我们必须信任 OCaml / Haskell / Scheme 的编译器，以及 Coq 提取工具自身的正确性，然而比起现在大多数软件的开发方式， 这也是很大的进步了。）实际上，这就是 Coq 最主要的使用方式之一。 在之后的章节中我们会回到这一主题上来。

```coq
Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).
```

Coq 实际上支持对_任何_归纳定义的双子句表达式使用 "if" 表达式 （不过恰巧在这里该表达式被称为 **bool**）。<u>当条件求值后得到的是第一个子句的 “构造子” (constructor)，那么条件就会被认为是 “真” ​</u>​**true**（不过恰巧 在这里第一个分支的构造子被称为 “真” **true**，并且如果求值后得到的是第二个子句， 那么条件就被认为是 “假” **false**）。

‍

如果在被 ==**Check**== 的表达式后加上一个分号和你想验证的类型，那么 Coq 会 验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。

```coq
Check true
    : bool.
Check (negb true)
    : bool.
```

‍

#### 由旧类型构造新类型

```coq
Inductive rgb : Type :=
  | red
  | green
  | blue.
Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).
```

像 **red**、**green**、**blue**、**black**、**white** 以及 **primary**（还有 **true**、**false**、**monday** 等）这样的原子标识符叫做​*'*​==*构造子（Constructor）*==​*'*​。

我们可以用它们来构建​*'构造子表达式（Constructor Expression）'*​， 其中每一个要么是一个简单的构造子，要么就是一个构造子应用于一个或多个参数 （每个这样的参数也都是构造子表达式）。

我们来仔细研究一下。每个归纳定义的类型（如 **day**、**bool**、**rgb**、**color** 等） 都描述了一组由*'构造子'*构成的​*'构造子表达式'*​。

* 我们从有限的一组*'构造子'*开始。例如 **red**、**primary**、**true**、**false**、**monday** 等等都是构造子。
* *'构造子表达式'*通过将构造子应用到一个或多个构造子表达式上构成。例如 **red**、**true**、**primary**、**primary** **red**、**red** **primary**、**red** **true**、 **primary** **(**primary **primary**) 等等
* 每个 **Inductive** 定义都刻画了一个构造子表达式的子集并赋予了它们名字，如 **bool**、**rgb** 或 **color**。

具体来说，**rgb** 和 **color** 的定义描述了如何构造这两个集合中的构造子表达式：

* 构造子表达式 **red**、**green** 和 **blue** 属于集合 **rgb**；
* 构造子表达式 **black** 和 **white** 属于集合 **color**；
* 若 **p** 是属于 **rgb** 的构造子表达式，则 **primary** **p**（读作“构造子 **primary** 应用于参数 **p**）是属于集合 **color** 的构造子表达式；且
* 通过这些方式构造的构造子表达式*'只属于'*集合 **rgb** 和 **color**。

我们可以像之前的 **day** 和 **bool** 那样用模式匹配为 **color** 定义函数。

```coq
Definition monochrome (c : color) : bool :=
  match c with
  | black ⇒ true
  | white ⇒ true
  | primary p ⇒ false
  end.
```

鉴于 **primary** 构造子接收一个参数，匹配到 **primary** 的模式应当带有一个 变量或常量。变量可以取任意名称，如上文所示；常量需有适当的类型，例如：

```coq
Definition isred (c : color) : bool :=
  match c with
  | black ⇒ false
  | white ⇒ false
  | primary red ⇒ true
  | primary _ ⇒ false
  end.
```

这里的模式 **primary** **_** 是“构造子 **primary** 应用到除 **red** 之外的任何 **rgb** 构造子上”的简写形式（通配模式 **_** 的效果与 **monochrome** 定义中的哑（dummy）模式变量 **p** 相同。）

#### 元组

一个多参数的单构造子可以用来创建元组类型。例如，为了让一个 半字节（nybble）表示四个比特。我们首先定义一个 **bit** 数据类型 来类比 **bool** 数据。并且使用 **B**​~0~ 和 **B**​~1~ 两种构造子来表示其可能的取值。 最后定义 **nybble** 这种数据类型，也就是一个四比特的元组。

```coq
Inductive bit : Type :=
  | B0
  | B1.
Inductive nybble : Type :=
  | bits (b0 b1 b2 b3 : bit).
Check (bits B1 B0 B1 B0)
    : nybble.
```

这里的 **bit** 构造子起到了对它内容的包装作用。 解包可以通过模式匹配来实现，就如同下面的 **all_zero** 函数一样， 其通过解包来验证一个半字节的所有比特是否都为 **B**​~0~。 我们用*'通配符'* 来避免创建不需要的变量名。

```coq
Definition all_zero (nb : nybble) : bool :=
  match nb with
    | (bits B0 B0 B0 B0) ⇒ true
    | (bits _ _ _ _) ⇒ false
  end.
Compute (all_zero (bits B1 B0 B1 B0)).
(* ===> false : bool *)
Compute (all_zero (bits B0 B0 B0 B0)).
(* ===> true : bool *)
```

#### 模块

Coq 提供了*'模块系统'*来帮助组织大规模的开发。在本课程中， 我们不太会用到这方面的特性。不过其中有一点非常有用： 如果我们将一组定义放在 **Module** **X** 和 **End** **X** 标记之间，那么在文件中的 **End** 之后，我们就可以通过像 **X.foo** 这样的名字来引用，而不必直接用 **foo** 了。在这里，我们通过此特性在内部模块中引入了 **nat** 类型的定义， 这样就不会覆盖标准库中的同名定义了（我们会在本书后面的部分中使用它， 因为它提供了一些简便的特殊记法。）

```coq
Module NatPlayground.
  (* ... *)
End NatPlayground.
```

#### 数值

```coq
Inductive nat : Type :=
  | O
  | S (n : nat).
```

* 构造子表达式 \[O\] 属于集合 \[nat\]；
* 如果 \[n\] 是属于集合 \[nat\] 的构造子表达式，
  那么 \[S n\] 也是属于集合 \[nat\] 的构造子表达式；并且
* 只有以这两种产生的方式构造字表达式才属于集合 \[nat\]。

为了让自然数使用起来更加自然，Coq 内建了一小部分解析打印功能： 普通的十进制数可视为“一进制”自然数的另一种记法，以代替 **S** 与 **O** 构造子； 反过来，Coq 也会默认将自然数打印为十进制形式：

```coq
Check (S (S (S (S O)))).
(* ===> 4 : nat *)

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

Compute (minustwo 4).
(* ===> 2 : nat *)
```

```coq
Check S        : nat->nat.
Check pred     : nat->nat.
Check minustwo : nat->nat.
```

以上三个东西均可作用于自然数，并产生自然数结果，但第一个 **S** 与后两者有本质区别：**pred** 和 **minustwo** 这类函数是通过给定的*'计算规则'*定义的—— 例如 **pred** 的定义表明 **pred** **2** 可化简为 **1**——但 **S** 的定义不包含此类行为。 虽然 **S** 可以作用于参数这点与函数​*'相似'*​，但其作用仅限于构造数字，而并不用于计算。（考虑标准的十进制数：数字 **1** 不代表任何计算，只表示一部分数据。 用 **111** 指代数字一百一十一，实则使用三个 **1** 符号表示此数各位。）

‍

简单的模式匹配不足以描述很多有趣的数值运算，我们还需要递归定义。

 关键字 ==**Fixpoint**== 可用于定义此类函数。

```coq
Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => evenb n'
  end.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

Compute (plus 3 2).
(* ===> 5 : nat *)

(** 你可以在两个表达式之间添加逗号来同时匹配它们：*)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

Fixpoint exp (base power : nat) : nat :=
  match power with
    | O => S O
    | S p => mult base (exp base p)
  end.
```

```coq
Notation "x + y" := (plus x y)
Notation "x - y" := (minus x y)
Notation "x * y" := (mult x y)
Notation "x =? y" := (eqb x y) 
Notation "x <=? y" := (leb x y)
Notation "x <? y" := (ltb x y) 
```

### 基于化简的证明

```coq
Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.
```

首先，我们使用了关键字 **Theorem** 而非 **Example**。这种差别纯粹是风格问题； 在 Coq 中，<u>关键字 ​</u>​<u>**Example**</u>​<u>​ 和 ​</u>​<u>**Theorem**</u>​<u>（以及其它一些，包括 ​</u>​<u>**Lemma**</u>​<u>、</u>​<u>**Fact**</u>​<u>​ 和 ​</u>​<u>**Remark**</u>​<u>）都表示完全一样的东西。</u>

其次，我们==增加了量词 ​==​==**∀**==​==​ ​==​==**n**==​==:==​==**nat**==，因此我们的定理讨论了*'所有的'* 自然数 **n**。 在非形式化的证明中，为了证明这种形式的定理，我们通常会说“*'假设'* 存在一个任意自然数 **n**...”。而在形式化证明中，这是用 **intros** **n** 来实现的，它会将量词从证明目标转移到当前假设的*'上下文'*中。 注意在 **intros** 从句中，我们可以使用别的标识符来代替 **n**

关键字 **intros**、**simpl** 和 **reflexivity** 都是*'策略（Tactic）'*的例子。 策略是一条可以用在 **Proof**（证明）和 **Qed**（证毕）之间的指令，它告诉 Coq 如何来检验我们所下的一些断言的正确性。

### 基于改写的证明

```coq
Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.
Proof.
  (* 将两个量词移到上下文中： *)
  intros n m.
  (* 将前提移到上下文中： *)
  intros H.
  (* 用前提改写目标： *)
  rewrite -> H.
  reflexivity.  Qed.
```

该定理并未对自然数 **n** 和 **m** 所有可能的值做全称断言，而是讨论了仅当 **n** **=** **m** 时这一更加特定情况。箭头符号读作“==蕴含==”。#TODO#​ 蕴含与前提的关系？

==**intros**== 策略用来将这三条前提从证明目标 移到当前上下文的假设中。

用来告诉 Coq 执行这种替换的策略叫做*'改写'* **rewrite**。

==**rewrite**== 中的箭头与蕴含无关：它指示 Coq 从左往右地应用改写。 若要从右往左改写，可以使用 `rewrite <-`​

**Check** 命令也可用来检查以前声明的引理和定理。

‍

### 利用分类讨论来证明

用 **Abort** 指令来放弃证明。

告诉 Coq 分别对 **n** **=** **0** 和 **n** **=** **S** **n'** 这两种情况进行分析的策略，叫做 **destruct**。

```coq
Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity.   Qed.
```

==**destruct**== 策略会生成*两个*子目标，为了让 Coq 认可这个定理， 我们必须接下来证明这两个子目标。

as **[|** **n'**] 这种标注被称为 ​*'引入模式'*​。它告诉 Coq 应当在每个子目标中 使用什么样的变量名。总体而言，在方括号之间的是一个由 **|** 隔开的 ​*'列表的列表'*​（译者注：list of lists）。在上面的例子中，第一个元素是 一个空列表，因为 **O** 构造子是一个空构造子（它没有任何参数）。 第二个元素提供了包含单个变量名 **n'** 的列表，因为 **S** 是一个单构造子。

在每个子目标中，Coq 会记录这个子目标中关于 **n** 的假设，**n** **=** **0** 还是 对于某个 n', **n** **=** **S** **n'**。而 **eqn**:**E** 记号则告知 Coq 以 **E** 来命名这些 假设。省略 **eqn**:**E** 会导致 Coq 省略这些假设。这种省略能够使得一些不需要 显式用到这类假设的证明显得更加流畅。但在实践中最好还是保留他们， 因为他们可以作为一种说明文档来在证明过程中指引你。

第二行和第三行中的 **-** 符号叫做​*'标号'*​，它标明了这两个生成的子目标所对应的证明部分。 （译注：此处的“标号”应理解为一个项目列表中每个 *'条目'* 前的小标记，如 ‣ 或 •。） 标号后面的证明脚本是一个子目标的完整证明。在本例中，每个子目标都简单地使用 **reflexivity** 完成了证明。通常，**reflexivity** 本身会执行一些化简操作。 例如，第二段证明将 **at** **(**S **n'** **+** **1)** **0** 化简成 **false**，是通过先将 **(**S **n'** **+** **1)** 转写成 **S** **(**n' **+** **1)**，接着展开 **beq_nat**，之后再化简 **match** 完成的。

**destruct** 策略可用于任何归纳定义的数据类型。比如，我们接下来会用它来证明 布尔值的取反是==对合（Involutive）==的 —— 即，取反是自身的逆运算。

```coq
Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity.  Qed.
```

注意这里的 **destruct** 没有 **as** 子句，因为此处 **destruct** 生成的子分类均无需绑定任何变量，因此也就不必指定名字。 实际上，我们也可以省略 *'任何'* **destruct** 中的 **as** 子句， Coq 会自动填上变量名。不过这通常是个坏习惯，因为如果任其自由决定的话， Coq 经常会选择一些容易令人混淆的名字。

有时在一个子目标内调用 **destruct**，产生出更多的*证明义务（Proof Obligation）* 也非常有用。这时候，我们使用不同的标号来标记目标的不同“层级”，比如：

```coq
Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.
```

除了 \[-\] 和 \[+\] 之外，还可以使用 \[\*\]（星号）或任何重复的标号符（如 \[--\] 或 \[\*\*\*\]）作为标号。我们也可以用花括号将每个子证明目标括起来：花括号还允许我们在一个证明中的多个层级下使用同一个标号。

```coq
Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.
```

或许你已经注意到了，    很多证明在引入变量之后会立即对它进行情况分析：

​`intros x y. destruct y as [|y] eqn:E.`

这种写法是如此的常见以至于 Coq 为它提供了一种简写：我们可以在引入 一个变量的同时对他使用*'引入模式'*来进行分类讨论。例如，下面是一个对 **plus_1_neq_0** 的更简短证明。（这种简写的缺点也显而易见， 我们无法再记录在每个子目标中所使用的假设，而之前我们可以通过 **eqn**:**E** 将它们标注出来。）

```coq
Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.
```

如果没有需要命名的构造子参数，我们只需写上 **[]** 即可进行情况分析。

```coq
Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
```

```coq
(** **** 练习：2 星, standard (andb_true_elim2) 

    证明以下断言, 当使用 [destruct] 时请用标号标出情况（以及子情况）。 *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec. 
    + simpl. reflexivity.
    + simpl. intros H. rewrite -> H. reflexivity.
  - destruct c eqn:Ec. 
    + simpl. reflexivity.
    + simpl. intros H. rewrite -> H. reflexivity.
Qed.
```

‍

### 关于记法的更多内容 (可选)

<u>专业提示：Coq 的符号机制不是特别强大，别期望太多。</u>

### 不动点 **Fixpoint** 和结构化递归 (可选)

```coq
(** **** 练习：2 星, standard, optional (decreasing) 

    为了更好的理解这一点，请尝试写一个对于所有输入都_的确_终止的 [Fixpoint]
    定义。但这个定义需要违背上述的限制，以此来让 Coq 拒绝。（如果您决定将这个可选
    练习作为作业，请确保您将您的解答注释掉以防止 Coq 拒绝执行整个文件。）
TODO : 参考来的答案  *)
Fixpoint not_accepted (n : nat) : nat :=
  match n with
  | O => not_accepted (S O)
  | S O => S O
  | S n' => S (not_accepted n')
  end.
```

​#TODO#​

### 更多练习

Each SF chapter comes with a tester file (e.g. **BasicsTest.v**), containing scripts that check most of the exercises. You can run **make** **BasicsTest.vo** in a terminal and check its output to make sure you didn't miss anything.

make *详细配置方案参考下一章（Induction）开头*

这些针对单增函数和二进制转换函数的“单元测试”可以验算你的定义的正确性。 当然，这些单元测试并不能确保你的定义在所有输入下都是正确的！我们在下一章的末尾会重新回到这个话题。

‍

‍

## 归纳证明    (Induction)

* [归纳法证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab49)
* [证明里的证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab54)
* [形式化证明 vs. 非形式化证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab55)
* [更多练习](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab58)

配置环境：

安装 coq 参考：

```coq
sudo snap install coq-prover
```

对于我使用的 VSCode +  VScoq 插件环境，推荐使用命令行方式配置 make

```bash
coq_makefile -f _CoqProject *.v -o Makefile
make Basics.vo # 编译
make BasicsTest.vo # 批改作业
```

如果遇到版本错误的问题，重新运行运行一些这些命令即可。

​#TODO#​​​ 对于 VScoq 插件，得需是当前工作区目录才能正常运行，现在还不知道问题所在。（跟coq的`Export`​​​对于文件路径的特性有关）

此环境在我的 [GitHub 仓库](https://github.com/framist/Software-Foundations-Note) 中。

‍

其他关于 Coq 的一些用法： ​#GPT#​

coqtop 是一个信息处理程序，它允许用户执行像打开文件，检查定义，通过命令交互式地编写代码等功能的 Coq 命令。

在编译 Coq 文件时，首先要使用 coqc 命令将 .v 文件编译成 .vo 文件，然后可以使用 coqtop 作为交互式编译器或链接器来使用这些 .vo 文件进行编译。

‍

### 归纳法证明

回想一下 ​*'自然数的归纳法则'*​，你也许曾在高中的数学课上，在某门离散数学课上或 在其它类似的课上学到过它：若 **P**(**n**) 为关于自然数的命题，而当我们想要证明 **P** 对于所有自然数 **n** 都成立时，可以这样推理：* 证明 **P**(**O**) 成立；

* 证明对于任何 **n'**，若 **P**(**n'**) 成立，那么 **P**(**S** **n'**) 也成立。
* 最后得出 **P**(**n**) 对于所有 **n** 都成立的结论。

在 Coq 中的步骤也一样：我们以证明 **P**(**n**) 对于所有 **n** 都成立的目标开始， 然后（通过应用 ==**induction**== 策略）把它分为两个子目标：一个是我们必须证明 **P**(**O**) 成立，另一个是我们必须证明 **P**(**n'**) **→** **P**(**S** **n'**)。下面就是对该定理的用法：

```coq
Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite <- IHn'. reflexivity.  Qed.
```

和 **destruct** 一样，**induction** 策略也能通过 **as**... 从句为引入到 子目标中的变量指定名字。由于这次有两个子目标，因此 **as**... 有两部分，用 **|** 隔开。

在第一个子目标中 **n** 被 **0** 所取代。由于没有新的变量会被引入，因此 **as** **...** 字句的第一部分为空

在第二个子目标中，**n** 被 **S** **n'** 所取代，而对 **n'** 的归纳假设（Inductive Hypothesis），即 **n'** **+** **0** **=** **n'** 则以 **IHn'** 为名被添加到了上下文中。 这两个名字在 **as**... 从句的第二部分中指定。在此上下文中，待证目标变成了 **(**S **n'**) **+** o**0** **=** **S** **n'**；它可被化简为 **S** **(**n' **+** **0)** **=** **S** **n'**，而此结论可通过 **IHn'** 得出。

（其实在这些证明中我们并不需要 **intros**：当 **induction** 策略被应用到包含量化变量的目标中时，它会自动将需要的变量移到上下文中。）

接下来就可以证明喜闻乐见的加法交换律和结合律了。

*这样子的证明会让我有一种瞎试就试出来的感觉，比用传统的方式更不明晰。但证明很快，可以保证他就是对的。后文：*"形式化证明 vs. 非形式化证明"[^1]

‍

我们的 **evenb** **n** 定义对 **n** **-** **2** 的递归调用不大方便。这让证明 **evenb** **n** 时更难对 **n** 进行归纳，因此我们需要一个关于 **n** **-** **2** 的归纳假设。 以下引理赋予了 **evenb** **(**S **n**) 另一个特征，使其在归纳时能够更好地工作：#TODO#​ 后文？

‍

### 证明里的证明

*嵌套证明*

简单地陈述并立即证明所需的“子定理”就会很方便。 我们可以用 **assert** 策略来做到。

```coq
Theorem mult_0_plus' : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  assert (H: 0 + n = n). { reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.
```

（当然也可以用 **as** 来命名该断言，与之前的 **destruct** 和 **induction** 一样。例如 **assert** **(0** **+** **n** **=** **n**) **as** **H**。）**assert** 生成的第一个子目标是我们必须证明的已断言的事实， 而在第二个子目标中，我们可以使用已断言的事实在一开始尝试证明的事情上取得进展。

```coq
(* 举例来说，假如我们要证明 (n + m) + (p + q) = (m + n) + (p + q)。 = 两边唯一不同的就是内层第一个子式中 + 的参数 m 和 n 交换了位置， 我们似乎可以用加法交换律（plus_comm）来改写它。然而， rewrite 策略并不知道应该作用在 '哪里'。本命题中 + 用了三次 ， 结果 rewrite → plus_comm 只对 '最外层' 起了作用... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* 我们只需要将 (m + n) 交换为 (n + m)... 看起来 plus_comm 能搞定！*)
  rewrite -> plus_comm.
  (* 搞不定... Coq 选错了要改写的加法！ *)
Abort.

(** 为了在需要的地方使用 [plus_comm]，我们可以（为此这里讨论的 [m] 和 [n]）
    引入一个局部引理来陈述 [n + m = m + n]，之后用 [plus_comm] 证明它，
    并用它来进行期望的改写。 *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite -> plus_comm. reflexivity. }
  rewrite -> H. reflexivity.  Qed.
```

‍

### 形式化证明 vs. 非形式化证明

“*'非形式化证明是算法，形式化证明是代码。'*”

证明是一种交流行为

形式化证明在很多方面都非常有用， 不过它们对人类之间的思想交流而言 *'并不'* 十分高效。特别是 Coq 证明中任何一处的“证明状态”都是完全 隐含的，而非形式化证明则经常反复告诉读者目前证明进行的状态。

‍

‍

### 更多练习

```coq
(** **** 练习：3 星, standard, optional (more_exercises) 

    找一张纸。对于以下定理，首先请 _'思考'_ 
    (a) 它能否能只用化简和改写来证明，
    (b) 它还需要分类讨论（[destruct]），以及 
    (c) 它还需要归纳证明。
    先写下你的预判，然后填写下面的证明（你的纸不用交上来，这只是鼓励你先思考再行动！） *)

...

Theorem zero_nbeq_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  (* 请在此处解答 *)
  (* 只用化简和改写来证明 *)
  simpl. (* TODO: 这里 出现了奇怪的蕴含式 nat -> false = false 是否意味这什么？ *)
  intros H.
  reflexivity.
Qed. 

...

Theorem S_nbeq_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  (* 请在此处解答 *)
  (* 只用化简和改写来证明 *)
  (* TODO: 为何不先证明 =? 的交换率？ *)
  simpl. reflexivity. Qed.

...


(* 可以证明一下排中律, 但不是说直觉主义逻辑不接受排中律？ 是因为 a: bool 而非命题？
*)
Theorem 排中律 : forall a: bool,
    a || (negb a) = true.
Proof.
  intros [].
  - reflexivity.
  - reflexivity.
Qed.

(* 乘法分配率 *)
Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
(* 乘法结合率 *)
Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p

(* TODO: 接下来不断用交换律可证明，就是不断代换，能证，不过实在有点麻烦 *)
```

​#TODO#​*这里 出现了奇怪的蕴含式 ​*​*`nat -> false = false`*​*​ 是否意味这什么？其他见上面的代码块。*

**replace** 策略允许你指定一个具体的要改写的子项和你想要将它改写成的项： **replace** **(**t**)** **with** **(**u**)** 会将目标中表达式 **t**（的所有副本）替换为表达式 **u**， 并生成 **t** **=** **u** 作为附加的子目标。在简单的 **rewrite** 作用在目标错误的部分上时 这种做法通常很有用。

​#剩余习题未完成#​

‍

## 使用结构化的数据    (Lists)

* [数值序对](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab65)
* [数值列表](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab68)

  * [用列表实现口袋（Bag）](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab76)
* [有关列表的论证](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab80)

  * [对列表进行归纳](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab81)
  * [Search 搜索](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab83)
  * [列表练习，第一部分](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab84)
  * [列表练习, 第二部分](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab87)
* [Options 可选类型](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab92)
* [偏映射（Partial Maps）](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab95)

### 数值序对

此声明可以读作：“构造数值序对的唯一一种方法，就是将构造子 **pair** 应用到两个 **nat** 类型的参数上。”

```coq
Inductive natprod : Type :=
| pair (n1 n2 : nat).

Notation "( x , y )" := (pair x y).
```

*会不会有符号冲突？注意coq的“函数调用”中的变量分割是空格*

我们还需要向 Coq 展示 **p** 的具体结构，这样 **simpl** 才能对 **fst** 和 **snd** 做模式匹配。通过 **destruct** 可以达到这个目的。

```coq
Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p.  destruct p as [n m].  simpl.  reflexivity.  Qed.
```

注意：不同于解构自然数产生两个子目标，**destruct** 在此只产生 一个子目标。这是因为 **natprod** 只有一种构造方法。

‍

‍

### 数值列表

​#联想#​*世界线收束！参照 CS61a 与 SICP 中的列表与链表*

通过推广序对的定义，数值*'列表'*类型可以这样描述： “一个列表要么是空的，要么就是由一个数和另一个列表组成的序对。”

```coq
Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).
```

例如，这是一个三元素列表：

```coq
Definition mylist := cons 1 (cons 2 (cons 3 nil)).
```

```coq
Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1;2;3].
```

*注意右结合 right associativity*

#### Repeat、Length、Append、Head 与 Tail

```coq
Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.

Fixpoint length (l:natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.
Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil    => l2
  | h :: t => h :: (app t l2)
  end.

Notation "x ++ y" := (app x y)
                     (right associativity, at level 60).

Definition hd (default:nat) (l:natlist) : nat :=
  match l with
  | nil => default
  | h :: t => h
  end.

Definition tl (l:natlist) : natlist :=
  match l with
  | nil => nil
  | h :: t => t
  end.
```

​#联想#​​​​ `app`​​​​ *（Append）实际定义了合并列表的函数。在这里coq是使用像数学的形式来定义；一般的函数式语言使用递归来定义；偏底层的语言（例如 C ）直接操作内存中的指针来完成整个定义*

> ​`::`​ ~=元素操作 `cons`​
>
> ​`++`​ ~=列表操作 `app`​

‍

#### 用列表实现口袋（Bag）

==**bag**==（或者叫 **multiset** 多重集）类似于集合，只是其中每个元素都能出现不止一次。 口袋的一种可行的表示是列表。

```coq
Fixpoint count (v:nat) (s:bag) : nat :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => O
  | h :: t => if h =? v
              then S (count v t)
              else count v t
  end.
```

对于以下习题，就有函数式编程的味道了，可以复用函数：

```coq
Definition sum : bag -> bag -> bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  app.
(* 对于参考其他人的解法，有：[  fun l1 l2 => app l1 l2. ] 但是是未学到的*)

Definition member (v:nat) (s:bag) : bool :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  if 0 <? (count v s)
  then true
  else false.
```

额外的练习：和 **bag** 有关的函数

```coq
Fixpoint remove_one (v:nat) (s:bag) : bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => nil
  | h :: t => if(v =? h) 
              then t 
              else h :: (remove_one v t) 
  end.

Fixpoint remove_all (v:nat) (s:bag) : bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => nil
  | h :: t => if(v =? h) 
              then remove_all v t
              else h :: (remove_all v t) 
  end.

Fixpoint subset (s1:bag) (s2:bag) : bool :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s1 with
  | nil => true
  | h :: t => if(member h s2) 
              then subset t (remove_one h s2) 
              else false 
  end.
```

### 有关列表的论证

归纳定义的集合中元素的形式 *'只能是'* 构造子对其它项的应用。

```coq
Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.
```

#### 反转列表

```coq
Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil    => nil
  | h :: t => rev t ++ [h]
  end.

Theorem app_length : forall l1 l2 : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).

Theorem rev_length_firsttry : forall l : natlist,
  length (rev l) = length l.
```

#### Search 搜索

我们已经见过很多需要使用之前证明过的结论（例如通过 **rewrite**）来证明的定理了。 但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身 我们都不能全部记住，更不用提它们的名字了。

Coq 的 ==**Search**== 指令在这时就非常有用了。执行 **Search** **foo** 会让 Coq 显示所有涉及到 **foo** 的定理。例如，去掉下面的注释后， 你会看到一个我们证明过的所有关于 **rev** 的定理的列表：

```coq
Coq < Search rev. 
test_rev2: rev [ ] = [ ]
rev_length: forall l : natlist, length (rev l) = length l
test_rev1: rev [1; 2; 3] = [3; 2; 1]
```

练习

```coq
Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.

Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.

Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
```

#### 列表练习

​#剩余习题未完成#​

‍

### Options 可选类型

假设我们想要写一个返回某个列表中第 **n** 个元素的函数。如果我们为它赋予类型 **nat** **→** **natlist** **→** **nat**，那么当列表太短时我们仍须返回某个数...

*突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 ​*"用函数构造函数"[^2]

一种更好的方式是改变 **nth_bad** 的返回类型，使其包含一个错误值作为可能的结果。 我们将此类型命名为 **natoption**。

```coq
Inductive natoption : Type :=
  | Some (n : nat)
  | None.
```

然后我们可以修改前面 **nth_bad** 的定义，使其在列表太短时返回 **None**， 在列表足够长且 **a** 在 **n** 处时返回 **Some** **a**。我们将这个新函数称为 **nth_error** 来表明它可以产生带错误的结果。

```coq
Fixpoint nth_error (l:natlist) (n:nat) : natoption :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.
```

介绍 Coq 编程语言更多细微特性：比如条件表达式...

Coq 的条件语句和其它语言中的一样，不过加上了一点更为一般化的特性。 由于 **bool** 类型不是内建的，因此 Coq 实际上支持在*'任何'*带有两个构造子的， 归纳定义的类型上使用条件表达式。当断言（guard）求值为 **Inductive** 定义中的第一个构造子时，它被认为是真的；当它被求值到第二个构造子时， 则被认为是假的。

以下函数从 **natoption** 中取出一个 **nat**，在遇到 **None** 时它将返回提供的默认值。

```coq
Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n' => n'
  | None => d
  end.
```

*这种记法在其他的一些编程语言中也有体现，例如 Rust*

### 偏映射（Partial Maps）

最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的 *'偏映射'* 数据类型，它类似于大多数编程语言中的映射或字典数据结构。

首先，我们定义一个新的归纳数据类型 **id** 来用作偏映射的“键”。

```coq
Inductive id : Type :=
  | Id (n : nat).
```

本质上来说，**id** 只是一个数。但通过 **Id** 标签封装自然数来引入新的类型， 能让定义变得更加可读，同时也给了我们更多的灵活性。

我们还需要一个 **id** 的相等关系测试：

```coq
Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | Id n1, Id n2 => n1 =? n2
  end.
```

现在我们定义偏映射的类型：

```coq
Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).
```

此声明可以读作：“有两种方式可以构造一个 **partial_map**：用构造子 **empty** 表示一个空的偏映射，或将构造子 **record** 应用到一个键、一个值和一个既有的 **partial_map** 来构造一个带“键-值”映射 的 **partial_map**。”

update 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在， 则新建其记录）。

```coq
Definition update (d : partial_map)(x : id) (value : nat)
                  : partial_map :=
  record x value d.
```

最后，**find** 函数按照给定的键搜索一个 **partial_map**。若该键无法找到， 它就返回 **None**；若该键与 **val** 相关联，则返回 **Some** **val**。 若同一个键被映到多个值，**find** 就会返回它遇到的第一个值。

```coq
Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty         => None
  | record y v d' => if eqb_id x y
                     then Some v
                     else find x d'
  end.
```

*实质上像多元列表，其中一个元不能重复*​

‍

​#TODO#​ 一个练习，答案是无穷？

```coq
Inductive baz : Type :=
  | Baz1 (x : baz)
  | Baz2 (y : baz) (b : bool).

(** 有_'多少'_个表达式具备类型 [baz]？（以注释说明。） *)
(* TODO: 无穷个？ *)
```

‍

## 多态与高阶函数    (Poly)

* [多态](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab100)

  * [多态列表](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab101)
  * [多态序对](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab110)
  * [多态候选](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab113)
* [函数作为数据](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab115)

  * [高阶函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab116)
  * [过滤器](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab117)
  * [匿名函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab118)
  * [映射](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab121)
  * [折叠](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab126)
  * [用函数构造函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab128)
* [附加练习](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab129)

‍

‍

在本章中，我们会继续发展函数式编程的基本概念，其中最关键的新概念就是 *'多态'*（在所处理的数据类型上抽象出函数）和*'高阶函数'*（函数作为数据）。

### 多态

*嗯...一种抽象手段*

#### 多态列表

为避免这些重复，Coq 支持定义*'多态'*归纳类型。 例如，以下就是*'多态列表'*数据类型。

```coq
Inductive list (X:Type) : Type :=
  | nil
  | cons (x : X) (l : list X).
```

这和上一章中 **natlist** 的定义基本一样，只是将 **cons** 构造子的 **nat** 参数换成了任意的类型 **X**，函数头的第一行添加了 **X** 的绑定， 而构造子类型中的 **natlist** 则换成了 **list** **X**。（我们可以重用构造子名 **nil** 和 **cons**，因为之前定义的 **natlist** 在当前作用之外的一个 **Module** 中。）

list 本身又是什么类型？一种不错的思路就是把 **list** 当做从 **Type** 类型到 **Inductive** 归纳定义的​*'函数'*​；或者换种更简明的思路，即 **list** 是个从 **Type** 类型到 **Type** 类型的函数。对于任何特定的类型 **X**， 类型 **list** **X** 是一个 **Inductive** 归纳定义的，元素类型为 **X** 的列表的集合。

`Check list : Type -> Type.`

**list** 的定义中的参数 **X** 自动 成为构造子 **nil** 和 **cons** 的参数 —— 也就是说，**nil** 和 **cons** 在这里是多态 的构造子；现在我们调用它们的时候必须要提供一个参数，就是它们要构造的列表的具 体类型。例如，**nil** **nat** 构造的是 **nat** 类型的空列表。

```coq
Check (nil nat) : list nat.
Check (cons nat 3 (nil nat)) : list nat.
```

**nil** 的类型会是什么呢？也许我们可以（根据定义）说它是 **list** **X**， 不过这样它就不是接受 **X** 返回 **list** 的函数了。再提出一种：**Type** **→** **list** **X** 并没有解释 **X** 是什么，**(**X **:** **Type**) **→** **list** **X** 则比较接近。 Coq 对这种情况的记法为 **∀** **X** **:** **Type**, **list** **X**：

```coq
Check nil : forall X : Type, list X.
Check cons : forall X : Type, X -> list X -> list X.
```

如果在每次使用列表构造子时，都要为它提供类型参数，那样会很麻烦。 不过我们很快就会看到如何省去这种麻烦。

现在我们可以回过头来定义之前写下的列表处理函数的多态版本了。 例如 **repeat**：

```coq
Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=
  match count with
  | 0 => nil X
  | S count' => cons X x (repeat X x count')
  end.
```

##### 类型标注的推断

Coq 可以使用*'类型推断'* 基于它们的使用方式来推出 **X**、**x** 和 **count** 一定是什么类型。例如， 由于 **X** 是作为 **cons** 的参数使用的，因此它必定是个 **Type** 类型， 因为 **cons** 期望一个 **Type** 作为其第一个参数，而用 **0** 和 **S** 来匹配 **count** 意味着它必须是个 **nat**，诸如此类。

```coq
Fixpoint repeat' X x count : list X :=
  match count with
  | 0        => nil X
  | S count' => cons X x (repeat' X x count')
  end.

Check repeat'
  : forall X : Type, X -> nat -> list X.
```

##### 类型参数的推断

在任何我们可以写类型参数的地方，我们都可 以将类型参数写为 “洞” ==**_**==，可以看做是说 “请 Coq 自行找出这里应该填什么。” 更确切地说，当 Coq 遇到 **_** 时，它会尝试*'统一'*所有的局部变量信息， 包括函数应当应用到的类型，其它参数的类型，以及应用函数的上下文中期望的类型， 以此来确定 **_** 处应当填入的具体类型。

```coq
repeat' (X : _) (x : _) (count : _) : list X

Fixpoint repeat'' X x count : list X :=
  match count with
  | 0        => nil _
  | S count' => cons _ x (repeat'' _ x count')
  end.

Definition list123 :=
  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).
(** ……我们可以用洞来这样写： *)
Definition list123' :=
  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).
```

‍

##### 隐式参数

我们甚至可以通过告诉 Coq *'总是'*推断给定函数的类型参数来在大多数情况下 直接避免写 **_**。

==Arguments== 用于指令指定函数或构造子的名字并列出其参数名， 花括号中的任何参数都会被视作隐式参数。（如果定义中的某个参数没有名字， 那么它可以用通配模式 **_** 来标记。这种情况常见于构造子中。）

```coq
Arguments nil {X}.
Arguments cons {X} _ _.
Arguments repeat {X} x count.
```

现在我们完全不用提供类型参数了：

```coq
Definition list123'' := cons 1 (cons 2 (cons 3 nil)).
```

此外，我们还可以在定义函数时就声明隐式参数，只需要将某个参数两边的圆括号换成花括号。例如：

```coq
Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=
  match count with
  | 0        => nil
  | S count' => cons x (repeat''' x count')
  end.
```

（注意我们现在甚至不必在 **repeat'''** 的递归调用中提供类型参数了， 实际上提供了反而是无效的，因为 Coq 并不想要它。）

我们会尽可能使用最后一种风格，不过还会继续在 **Inductive** 构造子中使用显式的 **Argument** 声明。原因在于如果将归纳类型的形参标为隐式的话， 不仅构造子的类型会变成隐式的，类型本身也会变成隐式的。例如， 考虑以下 **list** 类型的另一种定义：

```coq
Inductive list' {X:Type} : Type :=
  | nil'
  | cons' (x : X) (l : list').
```

<u>由于 ​</u>​<u>**X**</u>​<u>​ 在包括 ​</u>​<u>**list'**</u>​<u>​ 本身的</u>​<u>*'整个'*</u>​<u>归纳定义中都是隐式声明的， 因此当我们讨论数值、布尔值或其它任何类型的列表时，都只能写 ​</u>​<u>**list'**</u>​<u>， 而写不了 ​</u>​<u>**list'**</u>​<u>​ ​</u>​<u>**nat**</u>​<u>、</u>​<u>**list'**</u>​<u>​ ​</u>​<u>**bool**</u>​<u>​ 等等，这样就有点过分了。</u>

作为本节的收尾，我们为新的多态列表重新实现几个其它的标准列表函数...

```coq
Fixpoint app {X : Type} (l1 l2 : list X)
             : (list X) :=
  match l1 with
  | nil      => l2
  | cons h t => cons h (app t l2)
  end.

Fixpoint rev {X:Type} (l:list X) : list X :=
  match l with
  | nil      => nil
  | cons h t => app (rev t) (cons h nil)
  end.

Fixpoint length {X : Type} (l : list X) : nat :=
  match l with
  | nil => 0
  | cons _ l' => S (length l')
  end.
```

‍

‍

##### 显式提供类型参数

用 **Implicit** （隐式）将参数声明为隐式的会有个小问题：Coq 偶尔会没有足够的局部信息来确定类型参数。此时，我们需要告诉 Coq 这次我们会显示地给出参数。例如，假设我们写了如下定义：

```coq
Fail Definition mynil := nil.
(* The command has indeed failed with message:
The following term contains unresolved implicit arguments:
  nil
More precisely: 
- ?X: Cannot infer the implicit parameter X of nil whose type is "Type". *)
```

（**Definition** 前面的 **Fail** 限定符可用于*'任何'*指令， 它的作用是确保该指令在执行时确实会失败。如果该指令失败了，Coq 就会打印出相应的错误信息，不过之后会继续处理文件中剩下的部分。）

在这里，Coq 给出了一条错误信息，因为它不知道应该为 **nil** 提供何种类型。 我们可以为它提供个显式的类型声明来帮助它，这样 Coq 在“应用”**nil** 时就有更多可用的信息了：

```coq
Definition mynil : list nat := nil.
```

此外，我们还可以在函数名前加上==前缀 ​==​==**@**==​==​ ​==来强制将隐式参数变成显式的：

```coq
Check @nil : forall X : Type, list X.
Definition mynil' := @nil nat.
```

使用参数推断和隐式参数，我们可以为列表定义和前面一样的简便记法。 由于我们让构造子的的类型参数变成了隐式的，因此 Coq 就知道在我们使用该记法时自动推断它们了。

```coq
Notation "x :: y" := (cons x y)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
Notation "x ++ y" := (app x y)
                     (at level 60, right associativity).

(** 现在列表就能写成我们希望的方式了： *)

Definition list123''' := [1; 2; 3].
```

‍

#### 多态序对

按照相同的模式，我们在上一章中给出的数值序对的定义可被推广为 *'*​==*多态序对（Polymorphic Pairs）*==​*'*，它通常叫做==*'积（Products）*==​*'*：

```coq
Inductive prod (X Y : Type) : Type :=
| pair (x : X) (y : Y).

Arguments pair {X} {Y} _ _.
```

和列表一样，我们也可以将类型参数定义成隐式的， 并以此定义类似的具体记法：

```coq
Notation "( x , y )" := (pair x y).
```

我们也可以使用 **Notation** 来定义标准的*'积类型（Product Types）'*记法：

```coq
Notation "X * Y" := (prod X Y) : type_scope.
```

（标注 **:** ==**type_scope**== 会告诉 Coq 该缩写只能在解析类型而非表达式时使用。 这避免了与乘法符号的冲突。)

一开始会很容易混淆 **(**x**,**y**)** 和 **X**×**Y**。不过要记住 **(**x**,**y**)** 是一个​*'值'*​，它由两个其它的值构造得来；而 **X**×**Y** 是一个​*'类型'*​， 它由两个其它的类型构造得来。如果 **x** 的类型为 **X** 而 **y** 的类型为 **Y**， 那么 **(**x**,**y**)** 的类型就是 **X**×**Y**。

<u>第一元（first）和第二元（second）的射影函数（Projection Functions）</u>现在看起来和其它函数式编程语言中的很像了：

```coq
Definition fst {X Y : Type} (p : X * Y) : X :=
  match p with
  | (x, y) => x
  end.

Definition snd {X Y : Type} (p : X * Y) : Y :=
  match p with
  | (x, y) => y
  end.
```

​#GPT#​ 射影函数是一种数学概念，它指的是将一个点或一个向量从一个空间映射到另一个空间的函数。射影函数可以帮助人们在不同的空间之间建立联系，从而使得某些概念变得更加容易理解和推广。例如，在几何学中，人们可以使用射影函数来投影一个三维平面上的图形到二维平面上，从而使得图形的某些特征变得更加易于理解。

以下函数接受两个列表，并将它们结合成一个序对的列表。 在其它函数式语言中，它通常被称作 **zip**。我们为了与 Coq 的标准库保持一致， 将它命名为 **combine**。

```coq
Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)
           : list (X*Y) :=
  match lx, ly with
  | [], _ => []
  | _, [] => []
  | x :: tx, y :: ty => (x, y) :: (combine tx ty)
  end.
```

函数 **split** 是 **combine** 的右逆（right inverse）： 它接受一个序对的列表并返回一个列表的序对。 在很多函数式语言中，它被称作 **unzip**。

```coq
Definition append_list_pair {X Y : Type} 
                            (lp1 : (list X) * (list Y)) 
                            (lp2 : (list X) * (list Y)) : (list X) * (list Y) :=
((fst lp1) ++ (fst lp2), (snd lp1) ++ (snd lp2)).

Fixpoint split {X Y : Type} (l : list (X*Y))
               : (list X) * (list Y) :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match l with
  | [] => ([], [])
  | (h1, h2) :: tail => append_list_pair ([h1], [h2]) (split tail)
  end.
```

‍

‍

#### 多态候选

最后一种要介绍的多态类型是*'多态候选（Polymorphic Options）'*, 它推广了上一章中的 **natoption**（由于我们之后要用标准库中定义的 **option** 版本，因此这里的定义我们把它放在模块中）：

```coq
Module OptionPlayground.

Inductive option (X:Type) : Type :=
  | Some (x : X)
  | None.

Arguments Some {X} _.
Arguments None {X}.
```

现在我们可以重写 **nth_error** 函数来让它适用于任何类型的列表了。

```coq
Fixpoint nth_error {X : Type} (l : list X) (n : nat)
                   : option X :=
  match l with
  | [] => None
  | a :: l' => if n =? O then Some a else nth_error l' (pred n)
  end.
```

‍

‍

### 函数作为数据

和大部分现代编程语言一样，特别是“函数式”的语言，包括 OCaml、Haskell、 Racket、Scala、Clojure 等，Coq 也将函数视作“一等公民（First-Class Citizens）”， 即允许将它们作为参数传入其它函数、作为结果返回、以及存储在数据结构中等等。

‍

#### 高阶函数

用于操作其它函数的函数通常叫做*'高阶函数'*。以下是简单的示例：

```coq
Definition doit3times {X:Type} (f:X->X) (n:X) : X :=
  f (f (f n)).
```

注意到下面括号的使用 "突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 用..."[^3]

```coq
Check @doit3times : forall X : Type, (X -> X) -> X -> X.
```

‍

#### 过滤器

下面是个更有用的高阶函数，它接受一个元素类型为 **X** 的列表和一个 **X** 的==谓词==（即一个从 **X** 到 **bool** 的函数），然后“过滤”此列表并返回一个新列表， 其中仅包含对该谓词返回 **true** 的元素。

> 类如 python 中的`filter`​

```coq
Fixpoint filter {X:Type} (test: X->bool) (l:list X)
                : (list X) :=
  match l with
  | []     => []
  | h :: t => if test h then h :: (filter test t)
                        else       filter test t
  end.
```

‍

#### 匿名函数

```coq
Example test_anon_fun':
  doit3times (fun n => n * n) 2 = 256.
Proof. reflexivity. Qed.
```

表达式 **(**​==fun== **n** **⇒** **n** **×** **n**) 可读作“一个给定 **n** 并返回 **n** **×** **n** 的函数。”

‍

#### 映射

另一个方便的高阶函数叫做 **map**。

```coq
Fixpoint map {X Y: Type} (f:X->Y) (l:list X) : (list Y) :=
  match l with
  | []     => []
  | h :: t => (f h) :: (map f t)
  end.
```

‍

#### 折叠

一个更加强大的高阶函数叫做 **fold**。<u>本函数启发自“</u>​<u>**reduce**</u>​<u>​ 归约” 操作，它是 Google 的 map/reduce 分布式编程框架的核心。</u>

> 参考：[https://cloud.tencent.com/developer/article/1703116](https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html)
>
> https://cloud.tencent.com/developer/article/1703116

```coq
Fixpoint fold {X Y: Type} (f: X->Y->Y) (l: list X) (b: Y)
                         : Y :=
  match l with
  | nil => b
  | h :: t => f h (fold f t b)
  end.
```

```coq
Check (fold andb) : list bool -> bool -> bool.
Compute (fold andb) [true; true] false.
(* fold andb : list bool -> bool -> bool
	 : list bool -> bool -> bool
	 = false
     : bool
  这也说明了之前我猜测的柯里化是默认的 *)
```

‍

#### 用函数构造函数

```coq
Definition constfun {X: Type} (x: X) : nat->X :=
  fun (k:nat) => x.

Definition ftrue := constfun true.

Example constfun_example1 : ftrue 0 = true.
Proof. reflexivity. Qed.

Example constfun_example2 : (constfun 5) 99 = 5.
Proof. reflexivity. Qed.
```

实际上，我们已经见过的多参函数也是讲函数作为数据传入的例子。

```coq
Check plus : nat -> nat -> nat.
```

该表达式中的每个 **→** 实际上都是一个类型上的*'二元'*操作符。 该操作符是*'右结合'*的，因此 <u>**plus**</u>​<u>​ 的类型其实是 ​</u>​<u>**nat**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**(**</u>​<u>nat ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**nat**</u>​<u>) 的简写</u>，即，它可以读作“**plus** 是一个单参数函数，它接受一个 **nat** 并返回另一个函数，该函数接受另一个 **nat** 并返回一个 **nat**”。 在上面的例子中，我们总是将 **plus** 一次同时应用到两个参数上。 不过如果我们喜欢，也可以一次只提供一个参数，这叫做*'偏应用（Partial Application）'*。

### 更多练习

​`flod`​ 实现 `length`​ 和 `map`​

```coq
Definition fold_length {X : Type} (l : list X) : nat :=
  fold (fun _ n => S n) l 0.

Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y
  (* 将本行替换成 ":= _你的_定义_ ." *) :=
  fold (fun x list_elem_y => f x :: list_elem_y) l [].
```

​

在 Coq 中，函数 **f** **:** **A** **→** **B** **→** **C** 的类型其实是 **A** **→** **(**B **→** **C**)。 也就是说，如果给 **f** 一个类型为 **A** 的值，它就会给你函数 **f'** **:** **B** **→** **C**。 如果再给 **f'** 一个类型为 **B** 的值，它就会返回一个类型为 **C** 的值。 这为我们提供了 **plus3** 中的那种偏应用能力。 用返回函数的函数处理参数列表的方式被称为​*'*​==*柯里化（Currying）*==​*'*​， 它是为了纪念逻辑学家 Haskell Curry。

反之，我们也可以将 **A** **→** **B** **→** **C** 解释为 **(**A **×** **B**) **→** **C**。这叫做 ​*'*​==*反柯里化（Uncurrying）*==​*'*​。对于反柯里化的二元函数， 两个参数必须作为序对一次给出，此时它不会偏应用。

我们可以将柯里化定义如下：

```coq
Definition prod_curry {X Y Z : Type}
  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).
(** 定义它的反函数 [prod_uncurry] *)
Definition prod_uncurry {X Y Z : Type}
  (f : X -> Y -> Z) (p : X * Y) : Z :=
  f (fst p) (snd p).

Check @prod_curry : forall X Y Z : Type, (X * Y -> Z) -> X -> Y -> Z.
Check @prod_uncurry : forall X Y Z : Type, (X -> Y -> Z) -> X * Y -> Z.
```

​#联想#​ *这样看来“序对”就相当于一般编程语言的函数参数输入输出的数据结构*

‍

‍

本练习使用*'邱奇数（Church numerals）'*探讨了另一种定义自然数的方式， 它以数学家 Alonzo Church 命名。我们可以将自然数 **n** 表示为一个函数， 它接受一个函数 **f** 作为参数并返回迭代了 **n** 次的 **f**。

​#TODO#​

‍

## 更多基本策略    (Tactics)

* [apply 策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab138)
* [apply ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)​**[with](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)**​[ 策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)
* [The ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)​**[injection](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)**​[ and ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)​**[discriminate](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)**​[ Tactics](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)
* [对假设使用策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab147)
* [变换归纳假设](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab148)
* [展开定义](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab153)
* [对复合表达式使用 ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab154)​**[destruct](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab154)**
* [复习](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab157)
* [附加练习](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab158)

本章额外介绍了一些证明策略和手段， 它们能用来证明更多关于函数式程序的有趣性质。

我们会看到：如何在“**向前证明**”和“**向后证明**”两种风格中使用辅助引理；

* 如何对数据构造子进行论证，特别是，如何利用它们<u>单射且不交的事实</u>；
* 如何增强归纳假设，以及何时需要增强；
* 还有通过分类讨论进行论证的更多细节。

### apply 策略

我们经常会遇到待证目标与上下文中的前提或已证引理*'刚好相同'*的情况。

我们可以像之前那样用“**rewrite** **→** **eq**​~2~. **reflexivity**.”来完成。 不过如果我们使用 **apply** 策略，只需一步就能完成

**apply** 策略也可以配合*'条件（Conditional）'*假设和引理来使用： 如果被应用的语句是一个蕴含式，那么该<u>蕴含式的前提</u>就会被添加到待证子目标列表中。

```coq
Theorem silly2 : forall (n m o p : nat),
    n = m ->
    (n = m -> [n;o] = [m;p]) ->
    [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  apply eq2. apply eq1.  Qed.
```

​#TODO#​ 有待加深理解

通常，当我们使用 **apply** **H** 时，语句 **H** 会以一个引入了某些 *'通用变量（Universal Variables）'* 的 **∀** 开始。在 Coq 针对 **H** 的结论匹配当前目标时，它会尝试为这些变量查找适当的值。例如， 当我们在以下证明中执行 **apply** **eq**​~2~ 时，**eq**​~2~ 中的通用变量 **q** 会以 **n** 实例化，而 **r** 会以 **m** 实例化。

‍

### apply **with** 策略

...我们必须在 **apply** 的调用后面加上 "**with** **(**m**:=[**c**,**d**])**" 来显式地提供一个实例。

```coq
  apply trans_eq with (m:=[c;d]).
```

（实际上，我们通常不必在 **with** 从句中包含名字 **m**，Coq 一般足够聪明来确定我们实例化的变量。我们也可以写成： **apply** **trans_eq** **with** **[**c**;**d**]**。）

```coq
Example trans_eq_exercise : forall (n m o p : nat),
     m = (minustwo o) ->
     (n + p) = m ->
     (n + p) = (minustwo o).
Proof.
  (* 请在此处解答 *)
  intros n m o p eq1 eq2.
  apply trans_eq with (m).
  apply eq2. apply eq1. Qed.
```

‍

### **injection** 和 **discriminate** 策略

回想自然数的定义：

```coq
 Inductive nat : Type :=
   | O
   | S (n : nat).
```

我们可从该定义中观察到，所有的数都是两种形式之一：要么是构造子 **O**， 要么就是将构造子 **S** 应用到另一个数上。不过这里还有无法直接看到的： 自然数的定义中还蕴含了两个事实：

* 构造子 **S** 是*'*​==*单射（Injective）*==​*'*或*'一一对应'*的。 即，如果 **S** **n** **=** **S** **m**，那么 **n** **=** **m** 必定成立。
* 构造子 **O** 和 **S** 是*'*​==*不相交（Disjoint）*==​*'*的。 即，对于任何 **n**，**O** 都不等于 **S** **n**。

类似的原理同样适用于所有归纳定义的类型：所有构造子都是单射的， 而不同构造子构造出的值绝不可能相等。对于列表来说，**cons** 构造子是单射的， 而 **nil** 不同于任何非空列表。对于布尔值来说，**true** 和 **false** 是不同的。 因为 **true** 和 **false** 二者都不接受任何参数，它们既不在这边也不在那边。 其它归纳类型亦是如此。

例如，我们可以使用定义在 **Basics.v** 中的 **pred** 函数来证明 **S** 的单射性。 .

```coq
Theorem S_injective : forall (n m : nat),
  S n = S m ->
  n = m.
Proof.
  intros n m H1.
  assert (H2: n = pred (S n)). { reflexivity. }
  rewrite H2. rewrite H1. reflexivity.
Qed.
```

这个技巧可以通过编写等价的 **pred** 来推广到任意的构造子上 —— 即编写一个“撤销”一次构造子调用的函数。为此，Coq 提供了更加简便的 **injection** 策略，它能让我们利用任意构造子的单射性。 下面是使用 **injection** 对上面定理的另一种证法：

```coq
Theorem S_injective' : forall (n m : nat),
  S n = S m ->
  n = m.
Proof.
  intros n m H.

(** 通过在此处编写 [injection H as Hmn]，我们让 Coq
    利用构造子的单射性来产生所有它能从 [H] 所推出的等式（本例中为等式 [n = m]）。
    每一个这样的等式都作为假设（本例中为 [Hmn]）被添加到上下文中。
*)

  injection H as Hnm. apply Hnm.
Qed.
```

以下例子展示了一个 **injection** 如何直接得出多个等式。

```coq
Theorem injection_ex1 : forall (n m o : nat),
  [n; m] = [o; o] ->
  [n] = [m].
Proof.
  intros n m o H.
  (* m = o -> n = o -> [n] = [m] *)
  injection H as H1 H2.
  rewrite H1. rewrite H2. reflexivity.
Qed.
```

‍

这就是构造器的 injectivity（注射性？）。那 disjointness （不交性？）呢？

不交性的原则认为两个以不同构造器开头的项（比如 [O] 和 [S]，或 [true] 和 [false]）永远不会相等。这意味着，在某个上下文中，如果我们假设这两个项相等，我们就有理由得出任何我们想要的结论，因为这个假设是毫无意义的。

**discriminate** 策略体现了这个原则：它用于处理涉及不同构造器的等式的假设（例如 [S n = O]），它立即解决当前目标。这里有一个例子：

```coq
Theorem eqb_0_l : forall n,
   0 =? n = true -> n = 0.
Proof.
  intros n.

(** 我们可以通过对 [n] 进行分类讨论来继续。第一种分类是平凡的。 *)

  destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    intros H. reflexivity.

(** However, the second one doesn't look so simple: 
    然而，第二个看起来并不那么简单：
    assuming [0 =? (S n') = true], we must show [S n' = 0]!  
    The way forward is to observe that the assumption itself 
    is nonsensical: 
    前进的方法是观察这个假设本身是毫无意义的： *)

  - (* n = S n' *)
    simpl.

(**
    如果我们对这个假设使用 [discriminate] ，
    Coq 便会确认我们当前正在证明的目标不可行，并同时移除它，不再考虑。 *)

    intros H. discriminate H.
Qed.

```

*这种情况之前也出现过，不过是用 rewrite 来奇怪地解决了的*​

本例是逻辑学原理==*'爆炸原理'*==的一个实例，它断言矛盾的前提会推出任何东西， 甚至是假命题！

```coq
Theorem discriminate_ex1 : forall (n : nat),
  S n = O ->
  2 + 2 = 5.
Proof.
  intros n contra. discriminate contra. Qed.
```

> *这也与蕴含式的定义相同：*
>
> |p<br />|q|p->q|
> | :----| :--| :-----|
> |1|0|0|
> |0|1|1|
> |1|1|1|
> |0|0|1|
>
> [爆炸原理](https://zh.wikipedia.org/zh-cn/%E7%88%86%E7%82%B8%E5%8E%9F%E7%90%86)​
>
> ​**爆炸原理**​（principle of explosion, "from falsehood, anything (follows)"），是[经典逻辑](https://zh.wikipedia.org/wiki/%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91 "经典逻辑")中陈述从[矛盾](https://zh.wikipedia.org/wiki/%E7%9F%9B%E7%9B%BE "矛盾")中可以得出任何事物的规则。用更加形式化的术语，从形如 *P* ∧ ¬*P* 的[命题](https://zh.wikipedia.org/wiki/%E5%91%BD%E9%A2%98 "命题")可以推导出任何任意的 *Q* (ex contradictione quodlibet (ECQ))​[[1]](https://zh.wikipedia.org/zh-cn/%E7%88%86%E7%82%B8%E5%8E%9F%E7%90%86#cite_note-1)^^​。 “爆炸”指称接受一个单一的矛盾到一个系统中会导致整体定理的“爆炸”。
>
> $$
> \displaystyle (P\land \lnot P)\rightarrow Q
> $$
>
> ​#TODO#​ 除了矛盾平常的一目了然的不真实性之外，这是对在形式系统中不允许 *P* ∧ ¬*P* 为真的主要逻辑论证: 在其中任何任意的[公式](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%8F "公式")都是[定理](https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%90%86 "定理")的系统是[琐碎的](https://zh.wikipedia.org/wiki/%E7%91%A3%E7%A2%8E%E8%AB%96 "琐碎论")。所以爆炸原理证明了[无矛盾律](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%9F%9B%E7%9B%BE%E5%BE%8B "无矛盾律")的正当性。

爆炸原理可能令你费解，那么请记住上述证明*'并不'*肯定其后件， 而是说明：*'如果'*荒谬的前件成立，*'那么'*就会得出荒谬的结论， 如此一来我们将生活在一个不一致的宇宙中，这里每个陈述都是正确的。<u>​ 下一章将进一步讨论爆炸原理</u>。

**构造子的单射性**能让我们论证 **∀** **(**n **m** **:** **nat**), **S** **n** **=** **S** **m** **→** **n** **=** **m**。 此蕴含式的逆形式是一个构造子和函数的更一般的实例， 在后面我们会发现它用起来很方便：

```coq
Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),
  x = y -> f x = f y.
Proof. intros A B f x y eq. rewrite eq.  reflexivity.  Qed.

Theorem eq_implies_succ_equal : forall (n m : nat),
    n = m -> S n = S m.
Proof. intros n m H. apply f_equal. apply H. Qed.
```

还有一个名为 `f_equal`​ 的策略，可以证明这样的定理。给定形如 [f a1 ... an = g b1 ... bn] 的目标，[f_equal] 策略会产生形如 [f = g]、[a1 = b1]、...、[an = bn] 的子目标。同时，[f_equal] 会自动解决任何足够简单（例如可以立即通过 [reflexivity] 证明）的子目标。

```coq
Theorem eq_implies_succ_equal' : forall (n m : nat),
    n = m -> S n = S m.
Proof. intros n m H. f_equal. apply H. Qed.
```

​#TODO#​ *但  f_equal 不是自己定义的 Theorem 吗，为什么可以直接用作策略？*

‍

### 对假设使用策略 apply in

默认情况下，大部分策略会作用于目标公式并保持上下文不变。然而， 大部分策略还有对应的变体来对上下文中的语句执行类似的操作。

‍

类似地，**apply** **L** **in** **H** 会针对上下文中的假设 **H** 匹配某些 （形如 **X** **→** **Y** 中的）条件语句 **L**。然而，与一般的 **apply** 不同 （它将匹配 **Y** 的目标改写为子目标 **X**），**apply** **L** **in** **H** 会针对 **X** 匹配 **H**，如果成功，就将其替换为 **Y**。

换言之，**apply** **L** **in** **H** 给了我们一种“==正向推理==”的方式：根据 **X** **→** **Y** 和一个匹配 **X** 的假设，它会产生一个匹配 **Y** 的假设。作为对比，**apply** **L** 是一种“==反向推理==”：它表示如果我们知道 **X** **→** **Y** 并且试图证明 **Y**， 那么证明 **X** 就足够了。

**正向推理**从*'给定'*的东西开始（即前提、已证明的定理）， 根据它们迭代地刻画结论直到抵达目标。**反向推理**从*'目标'*开始， 迭代地推理蕴含目标的东西，直到抵达前提或已证明的定理。

你在数学或计算机科学课上见过的非形式化证明可能倾向于正向推理。 <u>通常，Coq 习惯上倾向于使用反向推理</u>，但在某些情况下，正向推理更易于思考。

​#TODO#​ 此节有待加深理解

‍

### 变换归纳假设 generalize dependent

在 Coq 中进行归纳证明时，有时控制归纳假设的确切形式是十分重要的。 特别是，在调用 **induction** 策略前，我们有时需要用 **intros** 将假设从目标移到上下文中时要十分小心。例如，假设我们要证明 **double** 函数是单射的 -- 即，它将不同的参数映射到不同的结果：  
       **Theorem** **double_injective**: **∀** **n** **m**,  
         **double** **n** **=** **double** **m** **→** **n** **=** **m**.

此证明的开始方式有点微妙：如果我们以  
       **intros** **n**. **induction** **n**.

开始，那么一切都好（#TODO#​ 为什么？）。然而假如以  
       **intros** **n** **m**. **induction** **n**.

开始，就会卡在归纳情况中...

此时，归纳假设 **IHn'** *'不会'*给出 **n'** **=** **m'** -- 会有个额外的 **S** 阻碍 -- 因此该目标无法证明。

```coq
Theorem double_injective_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction n as [| n' IHn'].
  - (* n = O *) simpl. intros eq. destruct m as [| m'] eqn:E.
    + (* m = O *) reflexivity.
    + (* m = S m' *) discriminate eq.
  - (* n = S n' *) intros eq. destruct m as [| m'] eqn:E.
    + (* m = O *) discriminate eq.
    + (* m = S m' *) apply f_equal.

(** 此时，归纳假设 [IHn'] _'不会'_给出 [n' = m'] -- 会有个额外的 [S] 阻碍 --
    因此该目标无法证明。 *)

Abort.
```

要理解为什么它很奇怪，我们来考虑一个具体的（任意但确定的）**m** -- 比如说 **5**。该语句就会这样说：如果我们知道

* **Q** = “若 **double** **n** **=** **10** 则 **n** **=** **5**”

那么我们就能证明

* **R** = “若 **double** **(**S **n**) **=** **10** 则 **S** **n** **=** **5**”。

但是知道 **Q** 对于证明 **R** 来说并没有任何帮助！（如果我们试着根据 **Q** 证明 **R**，就会以“假设 **double** **(**S **n**) **=** **10**..”这样的句子开始， 不过之后我们就会卡住：知道 **double** **(**S **n**) 为 **10** 并不能告诉我们 **double** **n** 是否为 **10**。（实际上，它强烈地表示 **double** **n** *'不是'* **10**！） 因此 **Q** 是没有用的。）

​#TODO#​ 有待学习

在 **induction** 之前做一些 **intros** 来获得更一般归纳假设并不总是奏效。 有时需要对量化的变量做一下*'重排'*。例如，假设我们想要通过对 **m** 而非 **n** 进行归纳来证明 **double_injective**。

```coq
Theorem double_injective_take2_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction m as [| m' IHm'].
  - (* m = O *) simpl. intros eq. destruct n as [| n'] eqn:E.
    + (* n = O *) reflexivity.
    + (* n = S n' *) discriminate eq.
  - (* m = S m' *) intros eq. destruct n as [| n'] eqn:E.
    + (* n = O *) discriminate eq.
    + (* n = S n' *) apply f_equal.
        (* 和前面一样，又卡在这儿了。 *)
Abort.
```

问题在于，要对 **m** 进行归纳，我们首先必须对 **n** 归纳。 （而如果我们不引入任何东西就执行 **induction** **m**，Coq 就会自动为我们引入 **n**！）

我们可以对它做什么？一种可能就是改写该引理的陈述使得 **m** 在 **n** 之前量化。 这样是可行的，不过它不够好：我们不想调整该引理的陈述来适应具体的证明策略！ 我们更想以最清晰自然的方式陈述它。

我们可以先引入所有量化的变量，然后*'重新一般化（re-generalize）'* 其中的一个或几个，选择性地从上下文中挑出几个变量并将它们放回证明目标的开始处。 用 ==**generalize**==​==​ ​==​==**dependent**== （泛化依赖？）策略就能做到。

```coq
Theorem double_injective_take2 : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m.
  (* [n] and [m] are both in the context *)
  generalize dependent n.
  (* 现在 [n] 回到了目标中，我们可以对 [m] 进行归纳并得到足够一般的归纳假设了。 *)
  induction m as [| m' IHm'].
  - (* m = O *) simpl. intros n eq. destruct n as [| n'] eqn:E.
    + (* n = O *) reflexivity.
    + (* n = S n' *) discriminate eq.
  - (* m = S m' *) intros n eq. destruct n as [| n'] eqn:E.
    + (* n = O *) discriminate eq.
    + (* n = S n' *) apply f_equal.
      apply IHm'. injection eq as goal. apply goal. Qed.
```

我们来看一下此定理的非形式化证明。注意我们保持 **n** 的量化状态并通过归纳证明的命题，对应于我们形式化证明中依赖的一般化。

​*'定理'*​：对于任何自然数 **n** 和 **m**，若 **double** **n** **=** **double** **m**，则 **n** **=** **m**。

​*'证明'*​：令 **m** 为一个 **nat**。我们通过对 **m** 进行归纳来证明，对于任何 **n**， 若 **double** **n** **=** **double** **m**，则 **n** **=** **m**。

* 首先，设 **m** **=** **0**，而 **n** 是一个数使得 **double** **n** **=** **double** **m**。 我们必须证明 **n** **=** **0**。  
  由于 **m** **=** **0**，根据 **double** 的定义，我们有 **double** **n** **=** **0**。此时对于 **n** 需要考虑两种情况。若 **n** **=** **0**，则得证，因为 **m** **=** **0** **=** **n**，正如所需。 否则，若对于某个 **n'** 有 **n** **=** **S** **n'**，我们就会导出矛盾：根据 **double** 的定义，我们可得出 **double** **n** **=** **S** **(**S **(**double **n'**))，但它与 **double** **n** **=** **0** 相矛盾。
* 其次，设 **m** **=** **S** **m'**，而 **n** 同样是一个数使得 **double** **n** **=** **double** **m**。 我们必须证明 **n** **=** **S** **m'**，根据归纳假设，对于任何数 **s**，若 **double** **s** **=** **double** **m'**，则 **s** **=** **m'**。  
  根据 **m** **=** **S** **m'** 的事实以及 **double** 的定义我们有 **double** **n** **=** **S** **(**S **(**double **m'**))。 此时对于 **n** 需要考虑两种情况。  
  若 **n** **=** **0**，则根据 **double** **n** **=** **0** 的定义会得出矛盾。  
  故存在 **n'** 使得 **n** **=** **S** **n'**。再次根据 **double** 之定义，可得 **S** **(**S **(**double **n'**)) **=** **S** **(**S **(**double **m'**))。再由构造子单射可知 **double** **n'** **=** **double** **m'**。以**n'** 代入归纳假设，推得 **n'** **=** **m'**，故显然 **S** **n'** **=** **S** **m'**， 其中 **S** **n'** **=** **n**，**S** **m'** **=** **m**，所以原命题得证。 ☐

‍

‍

### 展开定义 unfold

有时候我们需要手动展开一个由 Definition 定义引入的名称，以便我们可以操作它所表示的表达式。例如，

```coq
Definition square n := n * n.
Lemma square_mult : forall n m, square (n * m) = square n * square m.
Proof.
  intros n m.
  simpl.
  unfold square.     (* <== *)
  rewrite mult_assoc.
  assert (H : n * m * n = n * n * m).
    { rewrite mult_comm. apply mult_assoc. }
  rewrite H. rewrite mult_assoc. reflexivity.
Qed.
```

为此，我们可以手动用 ==**unfold**== 展开 **square** 的定义。

我们已经观察到，像 **simpl**、**reflexivity** 和 **apply** 这样的策略， 通常总会在需要时自动展开函数的定义。然而，这种自动展开有些保守。一种更直白的方式就是使用 `unfold`​ 明确地告诉 Coq 去展开

‍

### 对复合表达式使用 **destruct**

我们已经见过许多通过 **destruct** 进行情况分析来处理一些变量的值了。 有时我们需要根据某些*'表达式'*的结果的情况来进行推理。我们也可以用 **destruct** 来做这件事。

在前面的证明中展开 **sillyfun** 后，我们发现卡在 **if** **(**n **=?** **3)** **then** **...** **else** **...** 上了。但由于 **n** 要么等于 **3** 要么不等于，因此我们可以用 **destruct** **(**eqb **n** **3)** 来对这两种情况进行推理。*使用 destruct 拆开 if 分支*

通常，**destruct** 策略可用于对任何计算结果进行情况分析。如果 **e** 是某个表达式，其类型为归纳定义的类型 **T**，那么对于 **T** 的每个构造子 **c**，**destruct** **e** 都会生成一个子目标，其中（即目标和上下文中）所有的 **e** 都会被替换成 **c**。

‍

**destruct** 策略的 **eqn**: 部分是可选的。然而在用 **destruct** 结构复合表达式时，<u>**eqn**</u>​<u>: 记录的信息是十分关键的</u>： 如果我们丢弃它，那么 **destruct** 会擦除我们完成证明时所需的信息。 

...

问题在于 destruct 执行的替换非常残酷 - 在这种情况下，它丢弃了每一个 n =? 3 的出现，但我们需要保留一些对这个表达式的记忆，以及它是如何被 destruct 的，因为我们需要能够推理出，由于在案例分析的这个分支中 n =? 3 = true，所以必须有 n = 3，从而得出 n 是奇数。我们在这里想要做的是替换掉所有现有的 n =? 3 的出现，但同时在上下文中添加一个方程式，记录我们所处的情况。这恰恰是 eqn: 限定符所做的。

```coq
Theorem sillyfun1_odd : forall (n : nat),
     sillyfun1 n = true ->
     oddb n = true.
Proof.
  intros n eq. unfold sillyfun1 in eq.
  destruct (n =? 3) eqn:Heqe3.
  (* 现在我们的状态和前面卡住的地方一样了，除了上下文中包含了额外的相等关系假设，
     它就是我们继续推进所需要的。 *)
    - (* e3 = true *) apply eqb_true in Heqe3.
      rewrite -> Heqe3. reflexivity.
    - (* e3 = false *)
     (* 当我们到达正在推理的函数体中第二个相等关系测试时，我们可以再次使用
        [eqn:]，以便结束此证明。 *)
      destruct (n =? 5) eqn:Heqe5.
        + (* e5 = true *)
          apply eqb_true in Heqe5.
          rewrite -> Heqe5. reflexivity.
        + (* e5 = false *) discriminate eq.  Qed.
```

‍

### 复习

现在我们已经见过 Coq 中最基础的策略了。未来的章节中我们还会介绍更多， <u>之后我们会看到一些更加强大的</u>​<u>*'自动化'*</u>​<u>策略，它能让 Coq 帮我们处理底层的细节</u>。 

下面是我们已经见过的：

* **intros**：将前提/变量从证明目标移到上下文中
* **reflexivity**：（当目标形如 **e** **=** **e** 时）结束证明
* **apply**：用前提、引理或构造子证明目标
* **apply**... **in** **H**：将前提、引理或构造子应用到上下文中的假设上（正向推理）
* **apply**... **with**...：为无法被模式匹配确定的变量显式指定值
* **simpl**：化简目标中的计算
* **simpl** **in** **H**：化简前提中的计算
* **rewrite**：使用相等关系假设（或引理）来改写目标
* **rewrite** **...** **in** **H**：使用相等关系假设（或引理）来改写前提
* **symmetry**：将形如 **t**=**u** 的目标改为 **u**=**t**
* **symmetry** **in** **H**：将形如 **t**=**u** 的前提改为 **u**=**t**
* **unfold**：用目标中的右式替换定义的常量
* **unfold**... **in** **H**：用前提中的右式替换定义的常量
* **destruct**... **as**...：对归纳定义类型的值进行情况分析
* **destruct**... **eqn**:...：为添加到上下文中的等式指定名字， 记录情况分析的结果
* **induction**... **as**...: 对归纳定义类型的值进行归纳
* **injection**: reason by injectivity on equalities between values of inductively defined types （#GPT#​​通过在归纳定义类型的值之间的等式上进行注射性推理）
* **discriminate**: reason by disjointness of constructors on equalities between values of inductively defined types （#GPT#​ 通过归纳定义类型的值之间的等式上构造器的不交性进行推理）
* **assert** **(**H**:** **e**)（或 **assert** **(**e**)** **as** **H**）：引入“局部引理”**e** 并称之为 **H**
* **generalize** **dependent** **x**：将变量 **x**（以及任何依赖它的东西） 从上下文中移回目标公式内的前提中

‍

### 附加练习

​#TODO#​ 本章还剩余大量习题未完成

‍

```coq

Definition split_combine_statement : Prop
  (* （“[: Prop]” 表示我们在这里给出了一个逻辑命题。） *)
  (* 将本行替换成 ":= _你的_定义_ ." *). Admitted.

Theorem split_combine : split_combine_statement.
Proof.
(* 请在此处解答 *) Admitted.
```

‍

## Coq 中的逻辑系统    (Logic)

* [逻辑联结词](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab165)

  * [合取](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab166)
  * [析取](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab170)
  * [假命题与否定](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab173)
  * [真值](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab179)
  * [逻辑等价](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab180)
  * [广集与逻辑等价](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab183)
  * [存在量化](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab184)
* [使用命题编程](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab187)
* [对参数应用定理](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab192)
* [Coq vs. 集合论](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab193)

  * [函数的外延性](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab194)
  * [命题 vs. 布尔值](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab196)
  * [经典逻辑 vs. 构造逻辑](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab202)

我们已经见过很多对事实的断言（即​*'命题'*​） 以及如何用证据展示其正确性（即​*'证明'*​）的例子了。特别是， 我们证明了大量的<u>*'相等性命题'*</u>​<u>（</u>​<u>**e**</u>​<u>~1~</u>​<u>​ ​</u>​<u>**=**</u>​<u>​ ​</u>​<u>**e**</u>​<u>~2~</u>​<u>）、蕴含式（</u>​<u>**P**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>）和量化命题 （</u>​<u>**∀**</u>​<u>​ ​</u>​<u>**x**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>）</u>。在本章中，我们将会看到如何用 Coq 解决类似形式的逻辑推理。

在深入细节之前，我们先来探讨一下 Coq 中数学表达式的地位。 回忆一下，Coq 是一门拥有*'类型'*的语言，也就是说，一切有意义的 表达式都具有一个相应的类型。逻辑表达也不例外，我们试图在 Coq 中证明的一切语句都有名为 **Prop** 的类型，即*'命题类型'*。

```coq
Check 3 = 3 : Prop.
Check forall n m : nat, n + m = m + n : Prop.
Check 3 = 2 : Prop. (* 简单来说，'是'一个命题与该命题'可以证明'是两回事。*)
Check forall n : nat, n = 2 : Prop.
```

注意：*'所有'*语法形式良好的命题，无论是否为真，其类型均为 **Prop**。

‍

除了拥有类型之外，命题还是*'一等的（First-Class）'*实体， 即在 Coq 的世界中，我们可以像操作其它实体那样操作命题。

到目前为止，我们已经知道命题可以出现在 **Theorem**（还有 **Lemma** 以及 **Example**）的声明中了。

不过命题还可以用在其它地方。例如，我们可以用 **Definition** 为命题取名，就像为其它表达式取名一样。

```coq
Definition plus_claim : Prop := 2 + 2 = 4.
Check plus_claim : Prop.
```

之后我们可以在任何需要此命题的地方使用它们名字——例如，作为一个 **Theorem** 声明中的断言：

```coq
Theorem plus_claim_is_true :
  plus_claim.
Proof. reflexivity.  Qed.
```

我们也可以写出*'参数化'*的命题 -- 也就是一个接受某些类型的参数， 然后返回一个命题的函数。

例如，以下函数接受某个数字，返回一个命题断言该数字等于 3： *也就是返回 Prop 类型的函数*

```coq
Definition is_three (n : nat) : Prop :=
  n = 3.
Check is_three : nat -> Prop.
```

在 Coq 中，返回命题的函数可以说是定义了其参数的*'性质'*。 例如，以下（多态的）性质定义了常见的 *'单射函数'* 的概念。

```coq
Definition injective {A B} (f : A -> B) :=
  forall x y : A, f x = f y -> x = y.

Lemma succ_inj : injective S.
Proof.
  intros n m H. injection H as H1. apply H1.
Qed.
```

相等关系运算符 **=** 也是一个返回 **Prop** 的函数。

表达式 **n** **=** **m** 只是 **eq** **n** **m** 的语法糖（它使用 **Notation** 机制定义在 Coq 标准库中）。由于 **eq** 可被用于任何类型的元素，因此它也是多态的：

```coq
Check @eq : forall A : Type, A -> A -> Prop.
```

（注意我们写的是 **@**eq 而非 **eq**：**eq** 的类型参数 **A** 是隐式声明的，因此我们需要关掉隐式参数的类型推断以便看到 **eq** 的完整类型。）

‍

> 参考eq的标准定义 #TODO#​
>
> ```coq
> Inductive eq (A:Type) (x:A) : A -> Prop :=
>     eq_refl : x = x :>A
>
> where "x = y :> A" := (@eq A x y) : type_scope.
>
> Arguments eq {A} x _.
> Arguments eq_refl {A x} , [A] x.
>
> Arguments eq_ind [A] x P _ y _ : rename.
> Arguments eq_rec [A] x P _ y _ : rename.
> Arguments eq_rect [A] x P _ y _ : rename.
>
> Notation "x = y" := (eq x y) : type_scope.
> Notation "x <> y :> T" := (~ x = y :>T) : type_scope.
> Notation "x <> y" := (~ (x = y)) : type_scope.
> ```

‍

### 逻辑联结词

#### 合取

命题 **A** 与 **B** 的*'*​==*合取*==​*'*（即*'逻辑与'*）写作 **A** **∧** **B**，表示一个 **A** 与 **B** 均为真的断言。

```coq
Example and_example : 3 + 4 = 7 /\ 2 * 2 = 4.
```

证明合取的命题通常使用 **==split==**​==​ 策略==。它会分别为语句的两部分生成两个子目标：

对于任意命题 A 和 B，如果我们假设 A 为真且 B 为真， 那么就能得出 A ∧ B 也为真的结论。

```coq
Lemma and_intro : forall A B : Prop, A -> B -> A /\ B.
Proof.
  intros A B HA HB. split.
  - apply HA.
  - apply HB.
Qed.
```

由于按照前提对某个目标应用定理会产生与该定理的前提一样多的子目标。 因此我们可以应用 **and_intro** 来达到和 **split** 一样的效果。

```coq
Example and_example' : 3 + 4 = 7 /\ 2 * 2 = 4.
Proof.
  apply and_intro.
  - (* 3 + 4 = 7 *) reflexivity.
  - (* 2 + 2 = 4 *) reflexivity.
Qed.
```

‍

```coq
(** **** 练习：2 星, standard (and_exercise)  *)
Example and_exercise :
  forall n m : nat, n + m = 0 -> n = 0 /\ m = 0.
Admitted.

(* TODO 
Proof.
  (* 请在此处解答 *)
  intros n m H. apply and_intro. 
  - induction n.
    + reflexivity.
    + inversion H.
  - induction m.
    + reflexivity.
    + rewrite plus_comm in H. inversion H.
Qed.  
*)
```

以上就是证明合取语句的方法。要反过来使用，即*'使用'*合取前提来帮助证明时， 我们会采用 **destruct** 策略。

如果当前证明上下文中存在形如 **A** **∧** **B** 的前提 **H**，那么 **destruct** **H** **as** **[**HA **HB**] 将会从上下文中移除 **H** 并增加 **HA** 和 **HB** 两个新的前提，前者断言 **A** 为真，而后者断言 **B** 为真。

```coq
Lemma and_example2 :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  (* 课上已完成 *)
  intros n m H.
  destruct H as [Hn Hm] eqn:HE. (* TODO 这个 eqn:HE 是什么意思？ *)
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

和往常一样，我们也可以在引入 **H** 的同时对其进行解构， 而不必先引入然后再解构：

```coq
Lemma and_example2' :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  intros n m [Hn Hm].
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

*为什么我们要麻烦地将 ​*​***n***​*​ ​*​***=***​*​ ​*​***0***​*​ 和 ​*​***m***​*​ ​*​***=***​*​ ​*​***0***​*​ 这两个前提放一条合取语句中呢？ 完全可以用两条独立的前提来陈述此定理啊：*

```coq
Lemma and_example2'' :
  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.
Proof.
  intros n m Hn Hm.
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

就此定理而言，两种方式都可以。不过理解如何证明合取前提非常重要， 因为合取语句通常会在证明的中间步骤中出现，特别是在做大型开发的时候。 下面是个简单的例子：

```coq
Lemma and_example3 :
  forall n m : nat, n + m = 0 -> n * m = 0.
Proof.
  (* 课上已完成 *)
  intros n m H.
  assert (H' : n = 0 /\ m = 0).
  { apply and_exercise. apply H. }
  destruct H' as [Hn Hm] eqn:HE.
  rewrite Hn. reflexivity.
Qed.
```

另一种经常遇到合取语句的场景是，我们已经知道了 **A** **∧** **B**， 但在某些上下文中只需要 **A** 或者 **B**。此时我们可以用 **destruct** 进行解构（或许是作为 **intros** 的一部分）并用下划线模式 **_** 来丢弃不需要的合取分式。

```coq
Lemma proj1 : forall P Q : Prop,
  P /\ Q -> P.
Proof.
  intros P Q HPQ.
  destruct HPQ as [HP _].
  apply HP.  Qed.
```

最后，我们有时需要重新排列合取语句的顺序，或者对多部分的合取语句进行分组。 此时使用下面的交换律和结合律会很方便。

```coq
Theorem and_commut : forall P Q : Prop,
  P /\ Q -> Q /\ P.
Proof.
  intros P Q [HP HQ].
  split.
    - (* left *) apply HQ.
    - (* right *) apply HP.  Qed.
```

‍

顺便一提，中缀记法 **∧** 只是 **and** **A** **B** 的语法糖而已； **and** 是 Coq 中将两个命题合并成一个命题的运算符。

```coq
Check and : Prop -> Prop -> Prop.
```

#### 析取

另一个重要的联结词是​*'*​==*析取*==​*'*​，即两个命题的​*'逻辑或'*​：若 **A** 或 **B** 二者之一为真，则 **A** **∨** **B** 为真。（这种中缀记法表示 **or** **A** **B**，其中 **or** **:** **Prop** **→** **Prop** **→** **Prop**。）

为了在证明中使用析取前提，我们需要分类讨论（它与 **nat** 之类的数据类型一样，都可以显式地通过 **destruct** 或隐式地通过 **intros** 模式来拆分：

```coq
Lemma eq_mult_0 :
  forall n m : nat, n = 0 \/ m = 0 -> n * m = 0.
Proof.
  (* [Hn | Hm] 会隐式地对 [n = 0 \/ m = 0] 进行分类讨论 *)
  intros n m [Hn | Hm].
  - (* 在这里 [n = 0] *)
    rewrite Hn. reflexivity.
  - (* 在这里 [m = 0] *)
    rewrite Hm. rewrite <- mult_n_O.
    reflexivity.
Qed.
```

相应地，要证明某个析取命题成立，只需证明其任意一边的命题成立就够了。 我们可以用==​ ​==​==**left**==​==​ 和 ​==​==**right**==​==​ 策略==来选取命题。顾名思义，**left** 会选取待析取证命题的左边，而 **right** 则会选取它的右边。 下面是一种平凡的用法...

```coq
Lemma or_intro_l : forall A B : Prop, A -> A \/ B.
Proof.
  intros A B HA.
  left.
  apply HA.
Qed.

(** ...而这个更有趣的例子则同时需要 [left] 和 [right]： *)

Lemma zero_or_succ :
  forall n : nat, n = 0 \/ n = S (pred n).
Proof.
  (* 课上已完成 *)
  intros [|n'].
  - left. reflexivity.
  - right. reflexivity.
Qed.
```

‍

#### 假命题与否定

目前为止，我们主要都在证明某些东西是*'真'*的：加法满足结合律， 列表的连接满足结合律，等等。当然，我们也关心*'否定'*的结果， 即证明某些给定的命题*'不是'*真的。在 Coq 中，这样的否定语句使用逻辑否定运算符 **¬** 来表达。

为了理解否定背后的原理，我们需要回想一下[Tactics](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html)一章中的​*'爆炸原理'*​。<u>​ 爆炸原理断言，当我们假设了矛盾存在时，就能推出任何命题。 遵循这一直觉，我们可以可以将 ​</u>​<u>**¬**</u>​<u>​ ​</u>​<u>**P**</u>​<u>（即非 ​</u>​<u>**P**</u>​<u>）定义为 ​</u>​<u>**∀**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>。</u>

不过 Coq 选择了稍有些不同（但等价）的做法，它将 **¬** **P** 定义为 **P** **→** **False**，而 **False** 是在标准库中特别定义的矛盾性命题。

```coq
Definition not (P:Prop) := P -> False.

Notation "~ x" := (not x) : type_scope.

Check not : Prop -> Prop.
```

由于 **False** 是个矛盾性命题，因此爆炸原理对它也适用。如果我们让 **False** 进入到了证明的上下文中，可以对它使用 **destruct** 来完成任何待证目标。

```coq
Theorem ex_falso_quodlibet : forall (P:Prop),
  False -> P.
Proof.
  (* 课上已完成 *)
  intros P contra.
  destruct contra.  Qed.
(* TODO: 具体细节的理解？ *)
```

拉丁文 *'ex falso quodlibet'* 的字面意思是“从谬误出发， 你能够证明任何你想要的”，这也是爆炸原理的另一个广为人知的名字。

不等性是十分常见的否定句的例子，，它有一个特别的记法 **x** **≠** **y**：

​`Notation "x <> y" := (~(x = y)).`​

```coq
(** 我们可以用 [not] 来陈述 [0] 和 [1] 是不同的 [nat] 元素： *)
Theorem zero_not_one : 0 <> 1.
Proof.
  (** 性质 [0 <> 1] 就是 [~(0 = 1)]，即 [not (0 = 1)]，
      它会展开为 [(0 = 1) -> False]。（这里显式地用 [unfold not]
      展示了这一点，不过一般可以忽略。 *)

  unfold not.

  (** 要证明不等性，我们可以反过来假设其相等... *)

  intros contra.

  (** ... 然后从中推出矛盾。在这里，等式 [O = S O] 与构造子 [O] 和 [S]
      的不交性相矛盾，因此用 [discriminate] 就能解决它。 *)

  discriminate contra.
Qed.
```

为了习惯用 Coq 处理否定命题，我们需要一些练习。 即便你十分清楚为什么某个否定命题成立，但能让 Coq 一下就理解则需要点小技巧。 以下常见事实的证明留给你热身。

```coq
Theorem not_False :
  ~ False.
Proof.
  unfold not. intros H. destruct H. Qed.

  (* 矛盾率 *)
Theorem contradiction_implies_anything : forall P Q : Prop,
  (P /\ ~P) -> Q.
Proof.
  intros P Q [HP HNA]. unfold not in HNA.
  apply HNA in HP. destruct HP.  Qed.

  (* 双重否定率 *)
Theorem double_neg : forall P : Prop,
  P -> ~~P.
Proof.
  intros P H. unfold not. intros G. apply G. apply H.  Qed.
```

‍

​#剩余习题未完成#​

‍

‍

由于不等性包含一个否定，因此在能够熟练地使用它前还需要一些练习。 这里有个有用的技巧：如果你需要证明某个目标不可能时（例如当前的目标陈述为 **false** **=** **true**），请使用 **ex_falso_quodlibet** 将该目标转换为 **False**。 如果在当前上下文中存在形如 **¬**P 的假设（特别是形如 **x**≠**y** 的假设）， 那么此技巧会让这些假设用起来更容易些。

```coq
Theorem not_true_is_false : forall b : bool,
  b <> true -> b = false.
Proof.
  intros b H.
  destruct b eqn:HE.
  - (* b = true *)
    unfold not in H.
    apply ex_falso_quodlibet.
    apply H. reflexivity.
  - (* b = false *)
    reflexivity.
Qed.
```

由于用 **ex_falso_quodlibet** 推理十分常用，因此 Coq 提供了内建的策略 ==**exfalso**==。

```coq
Theorem not_true_is_false' : forall b : bool,
  b <> true -> b = false.
Proof.
  intros [] H.          (* note implicit [destruct b] here *)
  - (* b = true *)
    unfold not in H.
    exfalso.                (* <=== *)
    apply H. reflexivity.
  - (* b = false *) reflexivity.
Qed.
```

‍

#### 真值

除 **False** 外，Coq 的标准库中还定义了 **True**，一个明显真的命题。 为了证明它，我们使用了预定义的常量 **I** **:** **True**：

```coq
Lemma True_is_true : True.
Proof. apply I. Qed.
```

与经常使用的 **False** 不同，**True** 很少使用，因为它作为证明目标来说过于平凡， 而作为前提又不携带任何有用的信息。 然而在使用条件从句定义复杂的 **Prop**，或者作为高阶 **Prop** 的参数时， 它还是挺有用的。之后我们会看到一些例子。

#### 逻辑等价

联结词“==当且仅当 ​==​==**iff**==”用起来十分方便，它是两个蕴含式的合取， 断言了两个命题拥有同样的真值。

```coq
Definition iff (P Q : Prop) := (P -> Q) /\ (Q -> P).

Notation "P <-> Q" := (iff P Q)
                      (at level 95, no associativity)
                      : type_scope.

Theorem iff_sym : forall P Q : Prop,
  (P <-> Q) -> (Q <-> P).
Proof.
  intros P Q [HAB HBA].
  split.
  - (* -> *) apply HBA.
  - (* <- *) apply HAB.  Qed.

Lemma not_true_iff_false : forall b,
  b <> true <-> b = false.
Proof.
  intros b. split.
  - (* -> *) apply not_true_is_false.
  - (* <- *)
    intros H. rewrite H. intros H'. discriminate H'.
Qed.
```

它同时也有自反性和传递性

```coq
(** **** 练习：1 星, standard, optional (iff_properties) 

    参照上面对 [<->] 对称性（[iff_sym]）的证明，
    请证明它同时也有自反性和传递性。 *)
Theorem iff_refl : forall P : Prop,
  P <-> P.
Proof.
  (* 请在此处解答 *)
  intros P.
  split.
  - intros P'. apply P'. 
  - intros P'. apply P'.
Qed.

Theorem iff_trans : forall P Q R : Prop,
  (P <-> Q) -> (Q <-> R) -> (P <-> R).
Proof.
  (* 请在此处解答 *)
  intros P Q R [HPQ HQP] [HQR HRQ]. split.
  - intros P'. apply HPQ in P'. apply HQR in P'. apply P'.
  - intros R'. apply HRQ in R'. apply HQP in R'. apply R'.
Qed.
```

‍

​#剩余习题未完成#​

‍

‍

#### 广集与逻辑等价

Coq 的某些策略会特殊对待 **iff** 语句，以此来避免操作某些底层的证明状态。 特别来说，**rewrite** 和 **reflexivity** 不仅可以用于相等关系，还可用于 **iff** 语句。为了开启此行为，我们需要导入 Coq 库来支持它：

```coq
From Coq Require Import Setoids.Setoid.
```

“==广集（Setoid）==”指配备了等价关系的集合，即满足自反性、对称性和传递性的关系。 当一个集合中的两个元素在这种关系上等价时，可以用 **rewrite** 将其中一个元素替换为另一个。我们已经在 Coq 中见过相等性关系 **=** 了： 当 **x** **=** **y** 时，我们可以用 **rewrite** 将 **x** 替换为 **y**，反之亦可。

同样，逻辑等价关系 **↔** 也满足自反性、对称性和传递性， 因此我们可以用它将替换命题中的一部分替换为另一部分：若 **P** **↔** **Q**，那么我们可以用 **rewrite** 将 **P** 替换为 **Q**，反之亦可。

下面是一个简单的例子，它展示了这些策略如何使用 **iff**。 首先，我们来证明一些基本的 **iff** 等价关系命题...

```coq
Lemma mult_0 : forall n m, n * m = 0 <-> n = 0 \/ m = 0.
Proof.
  split.
  - apply mult_eq_0.
  - apply eq_mult_0.
Qed.

Lemma or_assoc :
  forall P Q R : Prop, P \/ (Q \/ R) <-> (P \/ Q) \/ R.
Proof.
  intros P Q R. split.
  - intros [H | [H | H]].
    + left. left. apply H.
    + left. right. apply H.
    + right. apply H.
  - intros [[H | H] | H].
    + left. apply H.
    + right. left. apply H.
    + right. right. apply H.
Qed.
```

现在我们可以用这些事实配合 **rewrite** 与 **reflexivity** 对涉及等价关系的陈述给出流畅的证明了。以下是之前 **mult_0** 包含三个变量的版本：

```coq
Lemma mult_0_3 :
  forall n m p, n * m * p = 0 <-> n = 0 \/ m = 0 \/ p = 0.
Proof.
  intros n m p.
  rewrite mult_0. rewrite mult_0. rewrite or_assoc.
  reflexivity.
Qed.

```

‍

**apply** 策略也可以用在 **↔** 上。当给定一个等价关系命题作为 **apply** 的参数时，它会试图猜出正确的方向。

```coq
Lemma apply_iff_example :
  forall n m : nat, n * m = 0 -> n = 0 \/ m = 0.
Proof.
  intros n m H. apply mult_0. apply H.
Qed.
```

‍

‍

#### 存在量化

*'存在量化'*也是十分重要的逻辑联结词。我们说存在某个类型为 **T** 的 **x**，使得某些性质 **P** 对于 **x** 成立，写作 **∃** **x** **:** **T**, **P**。 和 **∀** 一样，如果 Coq 能从上下文中推断出 **x** 的类型，那么类型标注 **:** **T** 就可以省略。

为了证明形如 **∃** **x**, **P** 的语句，我们必须证明 **P** 对于某些特定的 **x** 成立，这些特定的 **x** 被称作存在性的*'例证'*。证明分为两步：<u>​ 首先，我们调用</u>​==<u>​ ​</u>==​==<u>**∃**</u>==​==<u>​ ​</u>==​==<u>**t**</u>==​==<u>​ 策略</u>==​<u>向 Coq 指出已经知道了使 ​</u>​<u>**P**</u>​<u>​ 成立的例证 ​</u>​<u>**t**</u>​<u>，然后证明将所有出现的 ​</u>​<u>**x**</u>​<u>​ 替换成 ​</u>​<u>**t**</u>​<u>​ 的命题 ​</u>​<u>**P**</u>​<u>。</u>

```coq
Definition even x := exists n : nat, x = double n.

Lemma four_is_even : even 4.
Proof.
  unfold even. exists 2. reflexivity.
Qed.

```

反之，如果我们的的上下文中有形如 **∃** **x**, **P** 的存在前提， 可以将其解构得到一个例证 **x** 和一个陈述 **P** 对于 **x** 成立的前提。

```coq
Theorem exists_example_2 : forall n,
  (exists m, n = 4 + m) ->
  (exists o, n = 2 + o).
Proof.
  (* 课上已完成 *)
  intros n [m Hm]. (* 注意这里隐式使用了 [destruct] *)
  exists (2 + m).
  apply Hm.  Qed.
```

**P** 对所有 **x** 成立”蕴含“不存在 **x** 使 **P** 不成立；存在量化对析取满足分配律。

```coq
(** **** 练习：1 星, standard, recommended (dist_not_exists) 

    请证明“[P] 对所有 [x] 成立”蕴含“不存在 [x] 使 [P] 不成立。”
    （提示：[destruct H as [x E]] 可以用于存在假设！） *)

Theorem dist_not_exists : forall (X:Type) (P : X -> Prop),
  (forall x, P x) -> ~ (exists x, ~ P x).
Proof.
  (* 请在此处解答 *) 
  intros X P Hall Hexist.
  destruct Hexist as [x HPnot].
  unfold not in HPnot. apply HPnot. apply Hall.
Qed.
(** [] *)

(** **** 练习：2 星, standard (dist_exists_or) 

    请证明存在量化对析取满足分配律。 *)

Theorem dist_exists_or : forall (X:Type) (P Q : X -> Prop),
  (exists x, P x \/ Q x) <-> (exists x, P x) \/ (exists x, Q x).
Proof.
   (* 请在此处解答 *)
  intros X P Q. split.
  - (* -> *) intros H. destruct H as [X' H]. destruct H as [HP | HQ].
    + left. exists X'. apply HP.
    + right. exists X'. apply HQ.  
  - (* <- *) intros H. destruct H as [HP | HQ].
    + destruct HP as [X' HP]. exists X'. left. apply HP.
    + destruct HQ as [X' HQ]. exists X'. right. apply HQ. 
Qed.
```

‍

#### 使用命题编程

我们学过的逻辑联结词为我们提供了丰富的用简单命题构造复杂命题的词汇。 为了说明，我们来看一下如何表达“元素 **x** 出现在列表 **l** 中”这一断言。 注意此性质有着简单的递归结构：* 若 **l** 为空列表，则 **x** 无法在其中出现，因此性质“**x** 出现在 **l** 中” 为假。

* 否则，若 **l** 的形式为 **x'** **::** **l'**，此时 **x** 是否出现在 **l** 中， 取决于它是否等于 **x'** 或出现在 **l'** 中。

我们可以将此定义直接翻译成递归函数，它接受一个元素和一个列表， 返回一个命题！：

```coq
Fixpoint In {A : Type} (x : A) (l : list A) : Prop :=
  match l with
  | [] => False
  | x' :: l' => x' = x \/ In x l'
  end.
```

当 **In** 应用于具体的列表时，它会被展开为一系列具体的析取式。

```coq
Example In_example_1 : In 4 [1; 2; 3; 4; 5].
Proof.
  (* 课上已完成 *)
  simpl. right. right. right. left. reflexivity.
Qed.

Example In_example_2 :
  forall n, In n [2; 4] ->
  exists n', n = 2 * n'.
Proof.
  (* 课上已完成 *)
  simpl.
  intros n [H | [H | []]].
  - exists 1. rewrite <- H. reflexivity.
  - exists 2. rewrite <- H. reflexivity.
Qed.
(** （注意我们用空模式_'无视'_了最后一种情况。） *)
```

我们也可证明关于 **In** 的更一般，更高阶的引理。

注意，首先 **In** 会被应用到一个变量上，只有当我们对它进行分类讨论时， 它才会被展开：

```coq
Lemma In_map :
  forall (A B : Type) (f : A -> B) (l : list A) (x : A),
    In x l ->
    In (f x) (map f l).
Proof.
  intros A B f l x.
  induction l as [|x' l' IHl'].
  - (* l = nil，矛盾 *)
    simpl. intros [].
  - (* l = x' :: l' *)
    simpl. intros [H | H].
    + rewrite H. left. reflexivity.
    + right. apply IHl'. apply H.
Qed.
```

虽然递归定义命题在某些情况下会很方便，但这种方式也有其劣势。特别是， 这类命题会受到 Coq 对递归函数要求的限制，例如，在 Coq 中递归函数必须是 “明显会终止”的。<u>在下一章中，我们会了解如何</u>​<u>*'归纳地'*</u>​<u>定义命题， 这是一种与之不同的技巧，有着其独特的优势和限制。</u>

​#剩余习题未完成#​

‍

#### 对参数应用定理

Coq 不同于其它证明助理（如 ACL2 和 Isabelle）的一个特性是， 它将*'证明'*本身也作为一等对象。

关于这一点有很多地方值得着墨，不过了解所有的细节对于使用 Coq 来说不是必须的。 本节点到为止，深入的探讨参见 **ProofObjects** 和 **IndPrinciples**。

我们已经知道 **Check** 命令可以用来显式表达式的类型了， 不过它还可以用来查找某个标识符所指代的定理。

```coq
Check plus_comm : forall n m : nat, n + m = m + n.
```

在检查定理 **plus_comm** 的*'陈述'*时，Coq 使用了与检查某项的*'类型'*一样的方式 （如果我们保留以冒号开始的部分，那么它会被打印出来）。这是为什么？

原因在于标识符 **plus_comm** 其实指代的是被称作*'证明对象'*的数据结构， 它表示在命题 **∀** **n** **m** **:** **nat**, **n** **+** **m** **=** **m** **+** **n** 的真实性上建立的逻辑推导。 此对象的类型*'就是'*其所证命题的陈述。

从直觉上来说，这很有道理，因为对定理的陈述说明了该定理可用来做什么， 正如可计算对象的类型告诉了我们可以对它做什么。例如，若我们有一个类型为 **nat** **→** **nat** **→** **nat** 的项，就可以给它两个 **nat** 作为参数并得到一个 **nat**。 类似地，如果我们有一个类型为 **n** **=** **m** **→** **n** **+** **n** **=** **m** **+** **m** 的对象， 就能为它提供一个类型为 **n** **=** **m** 的“参数”并推导出 **n** **+** **n** **=** **m** **+** **m**。

从操作上来说，这种类比可以更进一步：由于**定理可以作为函数**， 被应用到对应类型的前提上，因此我们可以直接产生结论而不必在途中使用断言。 例如，假设我们想要证明以下结论：

```coq
Lemma plus_comm3 :
  forall x y z, x + (y + z) = (z + y) + x.
```

乍看起来，我们似乎可以用 **plus_comm** 改写两次使两边匹配来证明它。 然而问题是，第二次 **rewrite** 会抵消第一次的效果。

我们之前在 **Induction** 一章中见过类似的问题，绕过它的一种简单方法是使用 **assert** 导出 **plus_comm** 的特殊版本，这样我们就能用它按照预期来改写。

一种更<u>优雅</u>的方式是直接把我们想要实例化的参数应用到 **plus_comm** 上， 就像我们将一个多态函数应用到类型参数上那样。

```coq
Lemma plus_comm3_take3 :
  forall x y z, x + (y + z) = (z + y) + x.
Proof.
  intros x y z.
  rewrite plus_comm.
  rewrite (plus_comm y z).
  reflexivity.
Qed.
```

我们来看看另一个像函数那样使用定理或引理的例子。 以下定理说明：任何包含元素的列表 **l** 一定非空。

```coq
Theorem in_not_nil :
  forall A (x : A) (l : list A), In x l -> l <> [].
Proof.
  intros A x l H. unfold not. intro Hl. destruct l eqn:HE.
  - simpl in H. destruct H.
  - discriminate Hl.
Qed.
```

有趣的地方是一个量化的变量（**x**）没有出现在结论（**l** **≠** **[]**）中。

我们可以用此引理来证明 **x** 为 **42** 的特殊情况。直接用 **apply** **in_not_nil** 会失败，因为它无法推出 **x** 的值。

```coq
Lemma in_not_nil_42 :
  forall l : list nat, In 42 l -> l <> [].
Proof.
  intros l H.
  Fail apply in_not_nil.
Abort.

(** 有一些方法可以绕开它： *)

(** Use [apply ... with ...] *)
Lemma in_not_nil_42_take2 :
  forall l : list nat, In 42 l -> l <> [].
Proof.
  intros l H.
  apply in_not_nil with (x := 42).
  apply H.
Qed.

(** Use [apply ... in ...] *)
Lemma in_not_nil_42_take3 :
  forall l : list nat, In 42 l -> l <> [].
Proof.
  intros l H.
  apply in_not_nil in H.
  apply H.
Qed.

(** 显式地对 [x] 的值应用引理。 *)
Lemma in_not_nil_42_take4 :
  forall l : list nat, In 42 l -> l <> [].
Proof.
  intros l H.
  apply (in_not_nil nat 42).
  apply H.
Qed.

(** 显式地对假设应用引理。 *)
Lemma in_not_nil_42_take5 :
  forall l : list nat, In 42 l -> l <> [].
Proof.
  intros l H.
  apply (in_not_nil _ _ _ H).
Qed.
```

对于几乎所有将定理名作为参数的策略而言，你都可以“将定理作为函数”来使用。 <u>注意，定理应用与函数应用使用了同样的类型推导机制，所以你可以将通配符作为定理的参数， 或者为定理声明默认的隐式前提</u>。这些特性在以下证明中展示。（此证明如何工作的细节 不必关心，这里的目标只是为了展示它的用途。）

```coq
Example lemma_application_ex :
  forall {n : nat} {ns : list nat},
    In n (map (fun m => m * 0) ns) ->
    n = 0.
Proof.
  intros n ns H.
  destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)
           as [m [Hm _]].
  rewrite mult_0_r in Hm. rewrite <- Hm. reflexivity.
Qed.
```

‍

‍

<u>在以后的章节中我们将会看到更多这方面的例子。</u>

‍

### Coq vs. 集合论

Coq 的逻辑核心，即*'归纳构造演算（Calculus of Inductive Constructions）'*系统， 在很多重要的方面不同于数学家用来写下精确而严谨的定义和证明的形式化系统。 例如，在主流的纸笔数学家中使用最普遍的*'策梅洛-弗兰克尔集合论（ZFC）'*中， <u>一个数学对象可同时属于不同的集合；而在 Coq 的逻辑中，一个项最多只属于一个类型</u>。 这些不同之处需要人们用稍微不同的方式来描述非形式化的数学概念，但总的来说， 它们都是非常自然而易于使用的。例如，在 Coq 中我们一般不说某个自然数 **n** 属于偶数集合，而是说 **even** **n** 成立，其中的 **even** **:** **nat** **→** **Prop** 描述了偶数的性质。

然而在某些情况下，将标准的数学论证翻译到 Coq 中会十分繁琐甚至是不可能的， 除非我们引入新的公理来丰富其逻辑核心。作为本章的结尾， 我们将探讨这两个世界之间最显著的*区别*。

#### 函数的外延性

目前为止我们所看见的相等关系断言基本上都只考虑了归纳类型的元素 （如 **nat**、**bool** 等等）。然而由于 Coq 的相等关系运算符是多态的， 因此我们可以在*'任何'*类型上使用它。特别是，我们可以写出断言*'两个函数相等'*的命题：

```coq
Example function_equality_ex1 :
  (fun x => 3 + x) = (fun x => (pred 4) + x).
Proof. reflexivity. Qed.
```

在一般的数学研究中，对于任意两个函数 **f** 和 **g**， 只要它们对相同的输入产生相等的结果，那么它们就被认为相等：

```coq
(forall x, f x = g x) -> f = g
```

这被称作*'*​==*函数的外延性原理*==​*'*。

<u>不甚严谨地说，所谓“外延性”是指某个对象可观察到的行为</u>。 因此，函数的外延性就是指函数的标识完全由其行为来决定。 用 Coq 的术语来说，就是函数的身份视其被应用后的结果而定。

然而，<u>函数的外延性并不在 Coq 的基本公理之内</u>，因此某些“合理”的命题是不可证明的：

```coq
Example function_equality_ex2 :
  (fun x => plus x 1) = (fun x => plus 1 x).
Proof.
   (* 卡住了 *)
Abort.
```

不过我们可以用 **Axiom** 指令将函数的外延性添加到 Coq 的核心逻辑系统中。

```coq
Axiom functional_extensionality : forall {X Y: Type}
                                    {f g : X -> Y},
  (forall (x:X), f x = g x) -> f = g.
```

将某个东西用 **Axiom** 定义为公理的效果与陈述一个定理并用 **Admitted** 跳过其证明相同， 不过它会提醒读者这是一个公理，我们无需证明！

现在我们可以在证明中调用函数的外延性了：

```coq
Example function_equality_ex2 :
  (fun x => plus x 1) = (fun x => plus 1 x).
Proof.
  apply functional_extensionality. intros x.
  apply plus_comm.
Qed.
```

当然，在为 Coq 添加公理时必须十分小心，因为这有可能会导致系统 *'不一致'*，而当系统不一致的，任何命题都能在其中证明，包括 **False** 和 **2+2=5**！

不幸的是，并没有一种简单的方式能够判断添加某条公理是否安全： 一般来说，确认任何一组公理的一致性都需要训练有素的数学家付出艰辛的努力。

然而，我们已经知道了添加函数外延性后的公理系统*'确实是'*一致的。

我们可以用 **Print** **Assumptions** 指令查看某个证明依赖的所有附加公理。

```coq
Print Assumptions function_equality_ex2.
(* ===>
     Axioms:
     functional_extensionality :
         forall (X Y : Type) (f g : X -> Y),
                (forall x : X, f x = g x) -> f = g *)
```

​#剩余习题未完成#​

列表反转函数 **rev** 的定义有一个问题，它会在每一步都执行一次 **app** 调用，而运行 **app** 所需时间与列表的大小线性渐近，也就是说 **rev** 的时间复杂度与列表长度呈渐进平方关系。我们可以用以下定义来改进它：

```coq
Fixpoint rev_append {X} (l1 l2 : list X) : list X :=
  match l1 with
  | [] => l2
  | x :: l1' => rev_append l1' (x :: l2)
  end.

Definition tr_rev {X} (l : list X) : list X :=
  rev_append l [].
```

此版本的 **rev** 是*'尾递归（tail-recursive）'*的， 因为对函数自身的递归调用是需要执行的最后一步操作 （即，在递归调用之后我们并不执行 **++** ）。 一个足够好的编译器会为此生成十分高效的代码。

‍

#### 命题 vs. 布尔值

我们已经知道在 Coq 中有两种编码逻辑事实的方式了，即使用*'布尔值'* （类型为 **bool**）和*'命题'*（类型为 **Prop**）。

例如，我们可以通过以下两种方式来断言 **n** 为偶数：

```coq
(** [evenb n] 求值为 [true]： *)
Example even_42_bool : evenb 42 = true.
Proof. reflexivity. Qed.

(** 或者存在某个 [k] 使得 [n = double k]： *)
Example even_42_prop : even 42.
Proof. unfold even. exists 21. reflexivity. Qed.
```

当然，如果二者刻画的偶数性描述的不是同一个自然数集合，那么会非常奇怪！ 幸运的是，我们确实可以证明二者相同...

首先我们需要两个辅助引理。

​#剩余习题未完成#​

Now the main theorem:

```coq
Theorem even_bool_prop : forall n,
  evenb n = true <-> even n.
Proof.
  intros n. split.
  - intros H. destruct (evenb_double_conv n) as [k Hk].
    rewrite Hk. rewrite H. exists k. reflexivity.
  - intros [k Hk]. rewrite Hk. apply evenb_double.
Qed.
```

‍

此定理说明，布尔计算 **evenb** **n** 的真假会从命题 **∃** **k**, **n** **=** **double** **k** 的真假中*'*​==*反映（reflected）*==​*'*出来。

类似地，以下两种 **n** 与 **m** 相等的表述等价：

* (1) **n** **=?** **m** 值为 **true**；
* (2) **n** **=** **m**。

同样，二者的记法也等价。

```coq
Theorem eqb_eq : forall n1 n2 : nat,
  n1 =? n2 = true <-> n1 = n2.
Proof.
  intros n1 n2. split.
  - apply eqb_true.
  - intros H. rewrite H. rewrite <- eqb_refl. reflexivity.
Qed.
```

然而，即便布尔值和命题式在逻辑上是等价的， 但它们的方便性从某些特定的目上来看并不一样。

在前面的偶数例子中，证明 **even_bool_prop** 的反向部分（即 **evenb_double**，从命题到布尔表达式的方向）时，我们对 **k** 进行了简单的归纳。而反方向的证明（即练习 **evenb_double_conv**） 则需要一种聪明的一般化方法，因为我们无法直接证明 **(**evenb **n** **=** **true**) **→** **even** **n**。

对于这些例子来说，<u>命题式的声明比与之对应的布尔表达式要更为有用， 但并非总是如此。</u>例如，我们无法在函数的定义中测试一般的命题是否为真， 因此以下代码片段会被拒绝：

```coq
Fail
Definition is_even_prime n :=
  if n = 2 then true
  else false.
```

Coq 会抱怨 **n** **=** **2** 的类型是 **Prop**，而它想要一个 **bool** 类型的元素（或其它带有两个元素的归纳类型）。<u>原因与 Coq 核心语言的</u>​<u>*'可计算性'*</u>​<u>特质有关，即它能表达的所有函数都是可计算且完全的</u>。 这样设计的的原因之一是为了能从 Coq 开发的代码中提取出可执行程序。 因此，<u>在 Coq 中 ​</u>​<u>**Prop**</u>​<u>​ ​</u>​<u>*'并没有'*</u>​<u>一种通用的情况分析操作来确定 任意给定的命题是否为真，一旦存在这种操作，我们就能写出不可计算的函数。</u>

尽管一般的不可计算性质无法表述为布尔计算，但值得注意的是，很多 *'可计算的'*性质更容易通过 **Prop** 而非 **bool** 来表达，因为<u>在 Coq 中定义递归函数中会受到很大的限制</u>。<u>例如，下一章会展示如何用 ​</u>​<u>**Prop**</u>​<u>​ 来定义“某个正则表达式可以匹配给定的字符串”这一性质。如果使用 ​</u>​<u>**bool**</u>​<u>​ 来定义，就需要写一个真正的正则表达式匹配器了，比起该性质的简单定义 （即非算法的定义）来说，这样会更加复杂，更难以理解，也更难以对它进行推理</u>。

另一方面，通过布尔值来陈述事实会带来一点重要的优势，即通过对 Coq 中的项进行计算可以实现一些自动推理，这种技术被称为*'*​==*互映证明（Proof by Reflection）*==​*'*。考虑以下陈述：

```coq
Example even_1000 : even 1000.

(** 对此命题而言，最直接的证明方式就是直接给出 [k] 的值。 *)

Proof. unfold even. exists 500. reflexivity. Qed.

(** 而使用与之对应的布尔语句的证明则更加简单（因为我们不必给出证据，Coq
    的计算机制会帮我们搞定它！） *)

Example even_1000' : evenb 1000 = true.
Proof. reflexivity. Qed.

(** 有趣的是，由于这两种定义是等价的，因此我们无需显式地给出 500，
    而是使用布尔等价式来证明彼此： *)

Example even_1000'' : even 1000.
Proof. apply even_bool_prop. reflexivity. Qed.
```

‍

尽管此例的证明脚本的长度并未因此而减少，然而更大的证明通常可通过 这种互映的方式来显著化简。举一个极端的例子，在用 Coq 证明著名的 *'四色定理'*时，人们使用互映技巧将几百种不同的情况归约成了一个布尔计算。

另一点明显的不同是<u>“布尔事实”的否定可以被直白地陈述并证明</u>， 只需翻转预期的布尔值结果即可。相反，命题的否定形式可能更难以直接证明。

```coq
Example not_even_1001 : evenb 1001 = false.
Proof.
  (* 课上已完成 *)
  reflexivity.
Qed.

(** 相反，命题的否定形式可能更难以直接证明。 *)

Example not_even_1001' : ~(even 1001).
Proof.
  (* 课上已完成 *)
  rewrite <- even_bool_prop.
  unfold not.
  simpl.
  intro H.
  discriminate H.
Qed.
```

相等性提供了另一个互补的例子，在命题的世界中它有时更容易处理。 在涉及 **n** 和 **m** 的证明中，知道 **n** **=?** **m** **=** **true** 通常没什么直接的帮助。然而如果我们将该语句转换为等价的 **n** **=** **m** 形式， 则可利用该等式改写证明目标。

```coq
Lemma plus_eqb_example : forall n m p : nat,
    n =? m = true -> n + p =? m + p = true.
Proof.
  (* 课上已完成 *)
  intros n m p H.
    rewrite eqb_eq in H.
  rewrite H.
  rewrite eqb_eq.
  reflexivity.
Qed.
```

我们不会在这里详细讨论互映技巧，然而对于展示布尔计算与一般命题的互补优势而言， 它是个很好的例子，在后面的章节中，能够在布尔和命题的世界之间来回穿梭通常会非常方便。

​#剩余习题未完成#​

以下引理将本章中讨论的**命题联结词**与对应的**布尔操作**关联了起来。

```coq
Lemma andb_true_iff : forall b1 b2:bool,
  b1 && b2 = true <-> b1 = true /\ b2 = true.
Proof.
  (* 请在此处解答 *) Admitted.

Lemma orb_true_iff : forall b1 b2,
  b1 || b2 = true <-> b1 = true \/ b2 = true.
Proof.
  (* 请在此处解答 *) Admitted.
(** [] *)
```

……

回忆一下[Tactics](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html)一章中练习 **forall_exists_challenge** 的函数 **forallb**：

```coq
Fixpoint forallb {X : Type} (test : X -> bool) (l : list X) : bool :=
  match l with
  | [] => true
  | x :: l' => andb (test x) (forallb test l')
  end.
```

请证明以下定理，它将 **forallb** 与之前的定义中 **All** 的性质联系了起来。

```coq
Theorem forallb_true_iff : forall X test (l : list X),
   forallb test l = true <-> All (fun x => test x = true) l.
Proof.
  (* 请在此处解答 *) Admitted.
```

‍

‍

（未分级的思考题）<u>函数 ​</u>​<u>**forallb**</u>​<u>​ 是否还存在尚未被此规范刻画到的重要性质？</u>

​#TODO#​

‍

‍

#### 经典逻辑 vs. 构造逻辑

我们已经知道了，在定义 Coq 函数时是无法判断命题 **P** 是否成立。 然而*'证明'*也存在类似的限制！换句话说，以下推理原则即便符合直觉， 不过在 Coq 中它是不可证明的：

```coq
Definition excluded_middle := forall P : Prop,
  P \/ ~ P.
```

为了在操作上理解为何如此, 回忆一下，在证明形如 **P** **∨** **Q** 的陈述时，我们使用了 **left** 与 **right** 策略，它们能够有效地知道析取的哪边成立。 然而在 **excluded_middle** 中，**P** 是被全称量化的*'任意'*命题，我们对它一无所知。 我们没有足够的信息来选择使用 **left** 或 **right** 中的哪一个。就像 Coq 因为缺乏信息而无法在函数内部机械地确定 **P** 是否成立一样。

然而，如果我们恰好知道 **P** 与某个布尔项互映，那么就能很轻易地知道它是否成立了： 我们只需检查 **b** 的值即可。

```coq
Theorem restricted_excluded_middle : forall P b,
  (P <-> b = true) -> P \/ ~ P.
Proof.
  intros P [] H.
  - left. rewrite H. reflexivity.
  - right. rewrite H. intros contra. discriminate contra.
Qed.
```

特别来说，对于自然数 **n** 和 **m** 的 **n** **=** **m** 而言，排中律是成立的。

```coq
Theorem restricted_excluded_middle_eq : forall (n m : nat),
  n = m \/ n <> m.
Proof.
  intros n m.
  apply (restricted_excluded_middle (n = m) (n =? m)).
  symmetry.
  apply eqb_eq.
Qed.
```

一般的排中律在 Coq 中默认并不可用，因为它是常见的逻辑系统（如 ZFC）中的标准特性。尽管如此，<u>不假设排中律的成立仍有其独特的优点： Coq 中的陈述可以构造出比标准数学中同样陈述更强的断言。特别是， 当存在 ​</u>​<u>**∃**</u>​<u>​ ​</u>​<u>**x**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>​ 的 Coq 证明时，我们可以直接给出一个使 ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>​ 得证的值 ​</u>​<u>**x**</u>​<u>。换言之，任何关于存在性的证明必定是</u>​<u>*'构造性'*</u>​<u>的。</u>

像 Coq 一样不假设排中律成立的逻辑系统被称作==*'构造逻辑'*==。

像 ZFC 这样更加传统的，排中律对于任何命题都成立的逻辑系统则被称作==*'经典逻辑'*==。

以下示例展示了为何假设排中律成立会导致非构造性证明：

*'命题'*：存在无理数 **a** 和 **b** 使得 **a** **^** **b**（**a** 的 **b** 次方）为有理数。

*'证明'*：易知 **sqrt** **2** 为无理数。若 **sqrt** **2** **^** **sqrt** **2** 为有理数， 那么可以取 **a** **=** **b** **=** **sqrt** **2** 证明结束；否则 **sqrt** **2** **^** **sqrt** **2** 为无理数。 此时，我们可以取 **a** **=** **sqrt** **2** **^** **sqrt** **2** 和 **b** **=** **sqrt** **2**，因为 **a** **^** **b** **=** **sqrt** **2** **^** **(**sqrt **2** **×** **sqrt** **2)** **=** **sqrt** **2** **^** **2** **=** **2**. ☐

看到发生什么了吗？我们使用排中律在不知道 **sqrt** **2** **^** **sqrt** **2** 是否为有理数的情况下就分别考虑了这两种情况！因此，我们通过证明知道了这样的 **a** 和 **b** 存在，但却无法确切知道它们的值（至少无法从此论据中获知）。

即便构造逻辑很有用，它也有自身的限制：<u>存在很多容易用经典逻辑证明的命题， 用构造证明只会更加复杂，而对于某些已知的命题而言这样的构造性证明甚至不存在！</u> 幸运的是，排中律和函数外延性一样都是与 Coq 的逻辑系统兼容的， 我们可以安全地将它作为公理添加到 Coq 中。然而，在本书中我们不必如此： 我们所涉及的结构都可以完全用构造逻辑得到，所需的额外代价则微不足道。

我们需要一定的实践才能理解哪些证明技巧不应在构造推理中使用， 而其中的<u>反证法</u>尤为臭名昭著，因为它会导向非构造性证明。<u>这里有个典型的例子： 假设我们想要证明存在 ​</u>​<u>**x**</u>​<u>​ 具有某种性质 ​</u>​<u>**P**</u>​<u>，即存在 ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>。我们先假设结论为假， 也就是说 ​</u>​<u>**¬**</u>​<u>​ ​</u>​<u>**∃**</u>​<u>​ ​</u>​<u>**x**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>。根据此前提，不难推出 ​</u>​<u>**∀**</u>​<u>​ ​</u>​<u>**x**</u>​<u>, ​</u>​<u>**¬**</u>​<u>​ ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>。 如果我们能够根据此中间事实得到矛盾，就能得到一个存在性证明而完全不必指出一个 ​</u>​<u>**x**</u>​<u>​ 的值使得 ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>​ 成立！</u>

从构造性的角度来看，这里存在着技术上的瑕疵，即我们试图通过对 **¬** **¬** **(**∃ **x**, **P** **x**) 的证明来证明 **∃** **x**, **P** **x**。从以下练习中我们会看到， <u>允许自己从任意陈述中</u>​==<u>去掉双重否定等价于引入排中律</u>==。因此，只要我们不引入排中律， 就无法在 Coq 中编码此推理。

​#TODO#​ 与之前证明 `P -> ~~P`​ 的关系？

‍

​#剩余习题未完成#​

证明通用排中律公理与 Coq 的一致性需要复杂的推理，而且并不能在 Coq 自身中进行。然而，以下定理蕴含了假设可判定性公理（即排中律的一个特例） 成立对于任何*'具体的'*命题 **P** 而言总是安全的。之所以如此， 是因为我们无法证明这类公理的否定命题。假如我们可以的话，就会同时有 **¬** **(**P **∨** **¬**P**)** 和 **¬** **¬** **(**P **∨** **¬**P**)**（因为根据引理 **double_neg**，**P** 蕴含 **¬** **¬** **P**）， 而这会产生矛盾。但因为我们不能，所以将 **P** **∨** **¬**P 作为公理加入是安全的。

```coq
Theorem excluded_middle_irrefutable: forall (P:Prop),
  ~ ~ (P \/ ~ P).
Proof.
  (* 请在此处解答 *) Admitted.
```

在经典逻辑中有这样一条定理，它断言以下两条命题是等价的：  
    ¬(**∃** **x**, ¬**P** **x**)  
    **∀** **x**, **P** **x**

之前的 **dist_not_exists** 证明了此等价式的一个方向。有趣的是， 我们无法用构造逻辑证明另一个方向。你的任务就是证明排中律蕴含此方向的证明。

```coq
Theorem not_exists_dist :
  excluded_middle ->
  forall (X:Type) (P : X -> Prop),
    ~ (exists x, ~ P x) -> (forall x, P x).
Proof.
  (* 请在此处解答 *) Admitted.
```

对于喜欢挑战的读者，以下练习来自于 Bertot 与 Casteran 所著的 Coq'Art 一书中第 123 页。以下四条陈述的每一条，加上 **excluded_middle** 可以认为刻画了经典逻辑。我们无法在 Coq 中证明其中的任意一条， 不过如果我们希望在经典逻辑下工作的话，可以安全地将其中任意一条作为公理添加到 Coq 中而不会造成不一致性。

请证明所有五个命题都是等价的（这四个再加上 **excluded_middle**）。

提示：不要去分别考虑每一对命题，而是证明一条将它们连接起来的单向蕴含环链。

```coq
Definition peirce := forall P Q: Prop,
  ((P->Q)->P)->P.

Definition double_negation_elimination := forall P:Prop,
  ~~P -> P.

Definition de_morgan_not_and_not := forall P Q:Prop,
  ~(~P /\ ~Q) -> P\/Q.

Definition implies_to_or := forall P Q:Prop,
  (P->Q) -> (~P\/Q).

(* 请在此处解答 *)
```

‍

‍

## 归纳定义的命题    (IndProp)

* [归纳定义的命题](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab206)

  * [偶数性的归纳定义](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab207)
* [在证明中使用证据](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab209)

  * [对证据进行反演](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab210)
  * [对证据进行归纳](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab213)
* [归纳关系](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab218)
* [案例学习：正则表达式](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab227)

  * [remember 策略](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab231)
* [案例学习：改进互映](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab235)
* [额外练习](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab238)

  * [扩展练习：经验证的正则表达式匹配器](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html#lab246)

‍

如何解决 `Require Coq.omega.Omega. ​`​出现的问题： 

```bash
COQC IndProp.v
File "./IndProp.v", line 5, characters 0-24:
Error: Cannot find a physical path bound to logical path Coq.omega.Omega.
```

确保 Omega 模块的路径正确配置，并且已经编译。  
您可以在终端中运行以下命令来检查 Omega 模块是否存在：`coqc -where`​。该命令将显示 Coq 安装的路径，其中应包括 Omega 模块的路径。  

```bash
$ ls /snap/coq-prover/31/coq-platform/lib/coq/theories/omega/
OmegaLemmas.v  OmegaLemmas.vo  OmegaLemmas.vos  PreOmega.v  PreOmega.vo  PreOmega.vos
```

‍

‍

‍

### 归纳定义的命题

在 [Logic](https://coq-zh.github.io/SF-zh/lf-current/Logic.html) 一章中，我们学习了多种方式来书写命题，包括合取、析取和存在量词。 在本章中，我们引入另一种新的方式：*'归纳定义（Inductive Definitions）'*。

*'注意'*：为简单起见，本章中的大部分内容都用一个归纳定义的“偶数性”作为展示的例子。 你可能会为此感到不解，因为我们已经有一种将偶数性定义为命题的完美方法了（若 **n** 等于某个整数的二倍，那么它是是偶数）。尚若如此，那么请放心， 在本章末尾和以后的章节中，我们会看到更多引人入胜的归纳定义的命题示例。

在前面的章节中，我们已经见过两种表述 **n** 为偶数的方式了：

(1) **evenb** **n** **=** **true**，以及

(2) **∃** **k**, **n** **=** **double** **k**。

然而还有一种方式是通过如下规则来建立 **n** 的偶数性质：

* 规则 **ev_0**: **0** 是偶数。
* 规则 **ev_SS**: 如果 **n** 是偶数, 那么 **S** **(**S **n**) 也是偶数。

为了理解这个新的偶数性质定义如何工作，我们可想象如何证明 **4** 是偶数。 根据规则 **ev_SS**，需要证明 **2** 是偶数。这时，只要证明 **0** 是偶数， 我们可继续通过规则 **ev_SS** 确保它成立。而使用规则 **ev_0** 可直接证明 **0** 是偶数。

接下来的课程中，我们会看到很多类似方式定义的命题。 在非形式化的讨论中，使用简单的记法有助于阅读和书写。 *'推断规则（Inference Rules）'*就是其中的一种。 （我们为此性质取名为 **ev**，因为 **even** 已经用过了。）

$$
\begin{gathered}
\frac{}{\operatorname{ev} ~ \theta} ~~~(ev_0)
\\

\frac{\operatorname{ev} n}{\operatorname{ev}(S(S n))}
~~~\left(e_{-} S S\right)
\end{gathered}
$$

若将上面的规则重新排版成推断规则，我们可以这样阅读它，如果线上方的 *'前提（Premises）'*成立，那么线下方的*'结论（Conclusion）'*成立。 比如，规则 **ev_SS** 读做如果 **n** 满足 **even**，那么 **S** **(**S **n**) 也满足。 如果一条规则在线上方没有前提，则结论直接成立。

我们可以通过组合推断规则来展示证明。下面展示如何转译 **4** 是偶数的证明：

```bash
                 --------  (ev_0)
                  ev 0
                 -------- (ev_SS)
                  ev 2
                 -------- (ev_SS)
                  ev 4
```

（为什么我们把这样的证明称之为“树”而非其他，比如“栈”？ 因为一般来说推断规则可以有多个前提。我们很快就会看到一些例子。

‍

#### 偶数性的归纳定义

基于上述，可将偶数性质的定义翻译为在 Coq 中使用 **Inductive** 声明的定义， 声明中每一个构造子对应一个推断规则：

```coq
Inductive ev : nat -> Prop :=
| ev_0 : ev 0
| ev_SS (n : nat) (H : ev n) : ev (S (S n)).
```

‍

这个定义与之前 **Inductive** 定义的用法有一个有趣的区别：一方面， 我们定义的并不是一个 **Type**（如 **nat**），而是一个将 **nat** 映射到 **Prop** 的函数——即关于数的性质。然而真正要关注的是，由于 **ev** 中的 **nat** 参数出现在冒号*'右侧'*，这允许在不同的构造子类型中使用不同的值：例如 **ev_0** 类型中的 **0** 以及 **ev_SS** 类型中的 **S** **(**S **n**)。与此相应， 每个构造子的类型必须在冒号后显式指定，并且对于某个自然数 **n** 来说，每个构造子的类型都必须有 **ev** **n** 的形式。

相反，回忆 **list** 的定义：

```coq
    Inductive list (X:Type) : Type :=
      | nil
      | cons (x : X) (l : list X).
```

它以*'全局的方式'*在冒号*'左侧'*引入了参数 **X**， 强迫 **nil** 和 **cons** 的结果为同一个类型（**list** **X**）。 如果在定义 **ev** 时将 **nat** 置于冒号左侧，就会得到如下错误：

```coq
Fail Inductive wrong_ev (n : nat) : Prop :=
| wrong_ev_0 : wrong_ev 0
| wrong_ev_SS (H: wrong_ev n) : wrong_ev (S (S n)).
(* ===> Error: Last occurrence of "[wrong_ev]" must have "[n]"
        as 1st argument in "[wrong_ev 0]". *)
```

在 **Inductive** 定义中，类型构造子冒号左侧的参数叫做==形参（Parameter）==， 而右侧的叫做==索引（Index）或注解（Annotation）==。

例如，在 **Inductive** **list** **(**X **:** **Type**) **:=** **...** 中，**X** 是一个形参；而在 **Inductive** **ev** **:** **nat** **→** **Prop** **:=** **...** 中，未命名的 **nat** 参数是一个索引。

在 Coq 中，我们可以认为 **ev** 定义了一个性质 **ev** **:** **nat** **→** **Prop**，其包括 “证据构造子” `ev_0 : ev 0`​ 和 `ev_SS : forall n, ev n -> ev (S (S n))`​。

这些 “证据构造子” 等同于已经证明过的定理。 具体来说，我们可以使用 Coq 中的 **apply** 策略和规则名称来证明某个数的 **ev** 性质……

```coq
Theorem ev_4 : ev 4.
Proof. apply ev_SS. apply ev_SS. apply ev_0. Qed.

(** ……或使用函数应用的语法： *)

Theorem ev_4' : ev 4.
Proof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.

(** 我们同样可以对前提中使用到 [ev] 的定理进行证明。 *)

Theorem ev_plus4 : forall n, ev n -> ev (4 + n).
Proof.
  intros n. simpl. intros Hn.
  apply ev_SS. apply ev_SS. apply Hn.
Qed.

(** 更一般地，我们可以证明以任意数乘 2 是偶数： *)

(** **** 练习：1 星, standard (ev_double)  *)
Theorem ev_double : forall n,
  ev (double n).
Proof.
  (* 请在此处解答 *)
  intros n. rewrite double_plus. induction n.
  - simpl.  apply ev_0.
  - simpl. rewrite <- plus_n_Sm. apply ev_SS. apply IHn.
Qed.
```

### 在证明中使用证据

除了*'构造'*证据（evidence）来表示某个数是偶数，我们还可以*'解构'*这样的证据， 这等于对它的构造进行论证。

对 **ev** 而言，使用 **Inductive** 声明来引入 **ev** 会告诉 Coq， **ev_0** 和 **ev_SS** 构造子不仅是构造偶数证明证据的有效方式， 还是构造一个数满足 **ev** 的证据的*'唯一'*方式。

换句话说，如果某人展示了对于 **ev** **n** 的证据 **E**，那么我们知道 **E** 必是二者其一：

* **E** 是 **ev_0**（且 **n** 为 **O**），或
* **E** 是 **ev_SS** **n'** **E'**（且 **n** 为 **S** **(**S **n'**)，**E'** 为 **ev** **n'** 的证据）.

这样的形式暗示着，我们可以像分析归纳定义的数据结构一样分析形如 **ev** **n** 的假设；特别地，对于这类证据使用*'归纳（induction）'*和*'分类讨论（case analysis）'*来进行论证也是可行的。让我们通过一些例子来学习实践中如何使用他们。

#### 对证据进行反演

假设我们正在证明涉及数字 `n`​ 的事实，并且给出了 `ev n`​ 作为假设。我们已经知道如何使用 `destruct`​ 或 `induction`​ 来对 `n`​ 进行情况分析，为`n = O`​的情况和一些`n'`​的情况 `n = S n'`​ 生成单独的子目标。但是，对于某些证明，我们可能会_*直接*_考虑 `ev n`​ 的证据。作为一种工具，我们可以使用 `destruct`​ 来证明 `ev n`​ 的特征。

```coq
Theorem ev_inversion :
  forall (n : nat), ev n ->
    (n = 0) \/ (exists n', n = S (S n') /\ ev n').
Proof.
  intros n E.
  destruct E as [ | n' E'].
  - (* E = ev_0 : ev 0 *)
    left. reflexivity.
  - (* E = ev_SS n' E' : ev (S (S n')) *)
    right. exists n'. split. reflexivity. apply E'.
Qed.
```

用 **destruct** 解构证据即可证明下述定理：

```coq
Theorem ev_minus2 : forall n,
  ev n -> ev (pred (pred n)).
Proof.
  intros n E.
  destruct E as [| n' E'].
  - (* E = ev_0 *) simpl. apply ev_0.
  - (* E = ev_SS n' E' *) simpl. apply E'.
Qed.
```

但是，这种变化不能仅仅通过 **destruct ​**来处理。

```coq
Theorem evSS_ev : forall n,
  ev (S (S n)) -> even n.
```

直观来说，我们知道支撑前提的证据不会由 **ev_0** 组成，因为 **0** 和 **S** 是 **nat** 类型不同的构造子；由此 **ev_SS** 是唯一需要应对的情况（译注：**ev_0** 无条件成立）。 不幸的是，**destruct** 并没有如此智能，它仍然为我们生成两个子目标。 更坏的是，于此同时最终目标没有改变，也无法为完成证明提供任何有用的信息。

```coq
Proof.
  intros n E.
  destruct E as [| n' E'] eqn:EE.
  - (* E = ev_0. *)
    (* 我们须证明 [n] 是偶数，但没有任何有用的假设信息可以使用！ *)
Abort.
```

究竟发生了什么？应用 **destruct** 把性质的参数替换为对应于构造子的值。 这对于证明 **ev_minus2'** 是有帮助的，因为在最终目标中直接使用到了参数 **n**。 然而，这对于 **evSS_ev** 并没有帮助，因为被替换掉的 **S** **(**S **n**) 并没有在其他地方被使用。

如果我们 [remember] 这个术语 [S (S n)]，证明就会通过。 (<u>我们将在下面更详细地讨论 [remember] ​</u>）

```coq
Theorem evSS_ev_remember : forall n,
  ev (S (S n)) -> ev n.
Proof.
  intros n H. remember (S (S n)) as k. destruct H as [|n' E'].
  - (* E = ev_0 *)
    (* Now we do have an assumption, in which [k = S (S n)] has been
       rewritten as [0 = S (S n)] by [destruct]. That assumption
       gives us a contradiction. 
       现在我们确实有一个假设，其中 [k = S (sn)] 已经
       被 [destruct] 改写为 [0 = S (sn)]。那个假设给我们一个矛盾。
       *)
    discriminate Heqk.
  - (* E = ev_S n' E' *)
    (* This time [k = S (S n)] has been rewritten as [S (S n') = S (S n)]. *)
    injection Heqk as Heq. rewrite Heq in E'. apply E'.
Qed.
```

或者，使用我们的反演引理，证明是直截了当的。

​#TODO#​ `inversion`​ 此章未完成阅读

​#剩余习题未完成#​

‍

#### 对证据进行归纳

‍

### 归纳关系

### 案例学习：正则表达式

#### remember 策略

### 案例学习：改进互映

### 额外练习

#### 扩展练习：经验证的正则表达式匹配器

‍

## 全映射与偏映射    (Maps)

* [Coq 标准库](https://coq-zh.github.io/SF-zh/lf-current/Maps.html#lab255)
* [标识符](https://coq-zh.github.io/SF-zh/lf-current/Maps.html#lab256)
* [全映射](https://coq-zh.github.io/SF-zh/lf-current/Maps.html#lab257)
* [偏映射](https://coq-zh.github.io/SF-zh/lf-current/Maps.html#lab265)

*'映射（Map）'*（或*'字典（Dictionary）'*）是一种非常普遍的数据结构， 在编程语言理论中尤甚，而之后的章节中我们会多次用到它。 映射也适合运用之前学过的概念进行研究，包括如何在高阶函数之外构建数据结构 （见 **Basics** 和 **Poly**）以及通过互映来精简证明（见 **IndProp**）。

我们会定义两种映射：在查找的键不存在时，*'全映射'*会返回“默认”元素， 而*'偏映射'*则会返回一个 **option** 来指示成功还是失败。后者根据前者来定义， 它使用 **None** 默认元素。

### Coq 标准库

```coq
From Coq Require Import Arith.Arith.
From Coq Require Import Bool.Bool.
Require Export Coq.Strings.String.
From Coq Require Import Logic.FunctionalExtensionality.
From Coq Require Import Lists.List.
Import ListNotations.
```

标准库的文档见 [https://coq.inria.fr/library/](https://coq.inria.fr/library/)。

### 标识符

首先我们需要键的类型来对映射进行索引。在 **Lists.v** 中， 我们为类似的目的引入了 **id** 类型。而在*'《软件基础》'*后面的部分， 我们会使用 Coq 标准库中的 **string** 类型。

为了比较字符串，我们定义了 **eqb_string** 函数，它在内部使用 Coq 字符串库中的 **string_dec** 函数。

```coq
Definition eqb_string (x y : string) : bool :=
  if string_dec x y then true else false.
```

（函数 **string_dec** 来自于 Coq 的字符串标准库。如果你查看 **string_dec** 的结果类型，就会发现其返回值的类型并不是 **bool**， 而是一个形如`{x = y} + {x <> y}`的类型，叫做<u>​ ​</u>​<u>**sumbool**</u>​<u>​ 类型， 它可以看做“带有证据的布尔类型”</u>。形式上来说，一个 `{x = y} + {x <> y}` 类型的元素要么是 **x** 和 **y** 的相等的证明，要么就是它们不相等的证明， 与一个标签一起来指出具体是哪一个。不过就目前来说，你可以把它当做一个 花哨的 **bool**。）

现在我们需要一些关于字符串相等性的基本性质...

```coq
Theorem eqb_string_refl : forall s : string, true = eqb_string s s.
Proof.
  intros s. unfold eqb_string.
  destruct (string_dec s s) as [Hs_eq | Hs_not_eq].
  - reflexivity.
  - destruct Hs_not_eq. reflexivity.
Qed.

```

两个字符串在 **eqb_string** 的意义上相等，当且仅当它们在 **=** 的意义上相等。因此 **eqb_string** 中反映了 **=**，[IndProp](https://coq-zh.github.io/SF-zh/lf-current/IndProp.html) 一章中<u>讨论了「互映」的意义</u>。

```coq
Theorem eqb_string_true_iff : forall x y : string,
    eqb_string x y = true <-> x = y.
Proof.
   intros x y.
   unfold eqb_string.
   destruct (string_dec x y) as [Hs_eq | Hs_not_eq].
   - rewrite Hs_eq. split. reflexivity. reflexivity.
   - split.
     + intros contra. discriminate contra.
     + intros H. rewrite H in Hs_not_eq. destruct Hs_not_eq. reflexivity.
Qed.

(** 类似地： *)

Theorem eqb_string_false_iff : forall x y : string,
    eqb_string x y = false <-> x <> y.
Proof.
  intros x y. rewrite <- eqb_string_true_iff.
  rewrite not_true_iff_false. reflexivity. Qed.

(** 以下便于使用的变体只需通过改写就能得出： *)

Theorem false_eqb_string : forall x y : string,
   x <> y -> eqb_string x y = false.
Proof.
  intros x y. rewrite eqb_string_false_iff.
  intros H. apply H. Qed.
```

‍

### 全映射

在本章中，我们的主要任务就是构建一个偏映射的定义，其行为类似于我们之前在 [Lists](https://coq-zh.github.io/SF-zh/lf-current/Lists.html) 一章中看到的那个，再加上伴随其行为的引理。

不过这一次，我们将使用*'函数'*而非“键-值”对的列表来构建映射。 这种表示方法的优点在于它提供了映射更具*'外延性'*的视角， 即以相同方式回应查询的两个映射将被表示为完全相同的东西（即一模一样的函数）， 而非只是“等价”的数据结构。这反过来简化了使用映射的证明。

我们会分两步构建偏映射。首先，我们定义一个*'全映射'*类型， 它在某个映射中查找不存在的键时会返回默认值。

```coq
Definition total_map (A : Type) := string -> A.
(* *定义 total_map 类型* *)
```

直观上来说，一个元素类型为 **A** 的全映射不过就是个根据 **string** 来查找 **A** 的函数。

给定函数 **t_empty** 一个默认元素，它会产生一个空的全映射。 此映射在应用到任何字符串时都会返回默认元素。

```coq
Definition t_empty {A : Type} (v : A) : total_map A :=
  (fun _ => v).
```

**update** 函数，它和之前一样，接受一个映射 **m**、一个键 **x** 以及一个值 **v**，并返回一个将 **x** 映射到 **v** 的新映射；其它键则与 **m** 中原来的保持一致。此定义是个高阶编程的好例子：**t_update** 接受一个*'函数'* **m** 并产生一个新的函数 **fun** **x'** **⇒** **...**，它的表现与所需的映射一致。

```coq
Definition t_update {A : Type} (m : total_map A)
                    (x : string) (v : A) :=
  fun x' => if eqb_string x x' then v else m x'.
```

例如，我们可以构建一个从 **string** 到 **bool** 的映射，其中 **&quot;**foo**&quot;** 和 **&quot;**bar**&quot;** 映射到 **true**，其它键则映射到 **false**，就像这样：

```coq
Definition examplemap :=
  t_update (t_update (t_empty false) "foo" true)
           "bar" true.
```

接下来，我们引入一些新的记法来方便映射的使用。

```coq
(** 首先，我们会使用以下记法，根据一个默认值来创建空的全映射。 *)
Notation "'_' '!->' v" := (t_empty v)
  (at level 100, right associativity).

Example example_empty := (_ !-> false).

(** 然后，我们引入一种方便的记法，通过一些绑定来扩展现有的映射。 *)
Notation "x '!->' v ';' m" := (t_update m x v)
                              (at level 100, v at next level, right associativity).

(** 前面的 [examplemap] 现在可以定义如下： *)

Definition examplemap' :=
  ( "bar" !-> true;
    "foo" !-> true;
    _     !-> false
  ).
```

到这里就完成了全映射的定义。注意我们无需定义 **find** 操作， 因为它不过就是个函数应用！

为了在后面的章节中使用映射，我们需要一些关于其表现的基本事实。

即便你没有进行下面的练习，也要确保透彻地理解以下引理的陈述！

（其中有些证明需要函数的外延性公理，我们在 [Logic](https://coq-zh.github.io/SF-zh/lf-current/Logic.html) 一节中讨论过它）。

​#剩余习题未完成#​

‍

### 偏映射

最后，我们在全映射之上定义*'偏映射'*。元素类型为 **A** 的偏映射不过就是个 元素类型为 **option** **A**，默认元素为 **None** 的全映射。

```coq
Definition partial_map (A : Type) := total_map (option A).

Definition empty {A : Type} : partial_map A :=
  t_empty None.

Definition update {A : Type} (m : partial_map A)
           (x : string) (v : A) :=
  (x !-> Some v ; m).

(** 我们为偏映射引入类似的记法。 **)
Notation "x '|->' v ';' m" := (update m x v)
  (at level 100, v at next level, right associativity).

(** 当最后一种情况为空时，我们也可以隐藏它。 *)
Notation "x '|->' v" := (update empty x v)
  (at level 100).

Example examplepmap :=
  ("Church" |-> true ; "Turing" |-> false).
```

现在我们将所有关于全映射的基本引理直接转换成对应的偏映射引理。

```coq
Lemma apply_empty : forall (A : Type) (x : string),
    @empty A x = None.
Proof.
  intros. unfold empty. rewrite t_apply_empty.
  reflexivity.
Qed.

Lemma update_eq : forall (A : Type) (m : partial_map A) x v,
    (x |-> v ; m) x = Some v.
Proof.
  intros. unfold update. rewrite t_update_eq.
  reflexivity.
Qed.

Theorem update_neq : forall (A : Type) (m : partial_map A) x1 x2 v,
    x2 <> x1 ->
    (x2 |-> v ; m) x1 = m x1.
Proof.
  intros A m x1 x2 v H.
  unfold update. rewrite t_update_neq. reflexivity.
  apply H. Qed.

Lemma update_shadow : forall (A : Type) (m : partial_map A) x v1 v2,
    (x |-> v2 ; x |-> v1 ; m) = (x |-> v2 ; m).
Proof.
  intros A m x v1 v2. unfold update. rewrite t_update_shadow.
  reflexivity.
Qed.

Theorem update_same : forall (A : Type) (m : partial_map A) x v,
    m x = Some v ->
    (x |-> v ; m) = m.
Proof.
  intros A m x v H. unfold update. rewrite <- H.
  apply t_update_same.
Qed.

Theorem update_permute : forall (A : Type) (m : partial_map A)
                                x1 x2 v1 v2,
    x2 <> x1 ->
    (x1 |-> v1 ; x2 |-> v2 ; m) = (x2 |-> v2 ; x1 |-> v1 ; m).
Proof.
  intros A m x1 x2 v1 v2. unfold update.
  apply t_update_permute.
Qed.

```

## 柯里-霍华德对应    (ProofObjects)

* [证明脚本](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab266)
* [量词，蕴含式，函数](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab268)
* [使用策略编程](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab269)
* [逻辑联结词作为归纳类型](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab270)

  * [合取](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab271)
  * [析取](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab273)
  * [存在量化](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab275)
  * [True和False](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab277)
* [相等关系](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab278)

  * [再论反演](https://coq-zh.github.io/SF-zh/lf-current/ProofObjects.html#lab281)

*'算法是证明的计算性内容。' --Robert Harper*

前文已讨论过 Coq 既可以用 **nat**、**list** 等归纳类型及其函数*'编程'*，又可以用归纳命题（如 **ev**）、蕴含式、全称量词等工具*'证明'*程序的性质。我们一直 以来区别对待此两种用法，在很多情况下确实可以这样。但也有迹象表明在 Coq 中编 程与证明紧密相关。例如，<u>关键字 ​</u>​<u>**Inductive**</u>​<u>​ 同时用于声明数据类型和命题</u>，<u>以及 ​</u>​<u>**→**</u>​<u>​ 同时用于描述函数类型和逻辑蕴含式</u>。这可并不是语法上的巧合！事实上，在 Coq 里面程序和证明几乎就是同一件事情。这一章我们会学习背后的原理。

我们已经知道这个基础的思想：<u>在Coq里面，可证明性表现为拥有具体的</u>​<u>*'证据'*</u>​<u>。 为基本命题构造证明，实则以树状结构表示其证据</u>。

对于形如 **A** **→** **B** 的蕴含式，<u>其证明为证据</u>​<u>*'转化装置（transformer）'*</u>​<u>，可将任何证明 ​</u>​<u>**A**</u>​<u>​ 的依据转化为 ​</u>​<u>**B**</u>​<u>​ 的证据。所以从根本上来讲，证明仅仅就是操纵证据的程序</u>。

试问：如果是证据是数据，那么命题本身是什么？

答曰：类型也！

回顾一下 **ev** 这个性质的形式化定义。

```coq
Print ev.
(* ==>
  Inductive ev : nat -> Prop :=
    | ev_0 : ev 0
    | ev_SS : forall n, ev n -> ev (S (S n)).
*)

```

**ev** **0** 的证明”而非“**ev_0** 的类型为 **ev** **0**”。

<u>此处 ​</u>​<u>**:**</u>​<u>​ 既在类型层面表达“具有……类型”，又在命题层面表示“是……的证明”。 这种双关称为</u>​<u>*'柯里-霍华德同构（Curry-Howard correspondence）'*</u>​<u>。</u> 它指出了逻辑与计算之间的深层联系：

$$
命题 \sim 类型\\
证明 \sim 数据值
$$

[[Wadler 2015]](https://coq-zh.github.io/SF-zh/lf-current/Bib.html#Wadler-2015) 里有简单的历史和最新的详细介绍可供参考。

该同构启发很多看问题的新方法。首先，对 **ev_SS** 构造子的理解变得更加自然：

```coq
Check ev_SS
  : forall n,
    ev n ->
    ev (S (S n)).
```

可以将其读作“**ev_SS** 构造子接受两个参数——数字 **n** 以及命题 **ev** **n** 的证明——并产生 **ev (S (S n))** 的证明。”

现在让我们回顾一下之前有关 **ev** 的一个证明。

```coq
Theorem ev_4 : ev 4.
Proof.
  apply ev_SS. apply ev_SS. apply ev_0. Qed.
```

就像是处理普通的数据值和函数一样，我们可以使用 **Print** 指令来查看 这个证明脚本所产生的*'证据对象 (proof object)'*

```coq
Print ev_4.
(* ===> ev_4 = ev_SS 2 (ev_SS 0 ev_0)
     : ev 4  *)
```

实际上，我们也可以不借助脚本*'直接'*写出表达式作为证明。

```coq
Check (ev_SS 2 (ev_SS 0 ev_0))
  : ev 4.
```

表达式 **ev_SS 2 (ev_SS 0 ev_0)** 可视为向构造子 **ev_SS** 传入参数 2 和 0 等参数，以及对应的 **ev** **2** 与 **ev** **0** 之依据所构造的证明。或言之，视 **ev_SS** 为“构造证明”之原语，需要给定一个数字，并进一步提供该数为偶数之依据以构造证明。 其类型表明了它的功能：

​`forall n, ev n -> ev (S (S n)),`​

类似地，多态类型 **∀** **X**, **list** **X** 表明可以将 **nil** 视为从某类型到由该类型元素组成的空列表的函数。

我们在 [Logic](https://coq-zh.github.io/SF-zh/lf-current/Logic.html) 这一章中已经了解到，我们可以使用函数应用 的语法来实例化引理中的全称量化变量，也可以使用该语法提供引理所要求 的假设。例如：

```coq
Theorem ev_4': ev 4.
Proof.
  apply (ev_SS 2 (ev_SS 0 ev_0)).
Qed.
```

‍

### 证明脚本

我们一直在讨论的*'证明对象 (Proof Objects)'*是Coq如何运作的核心。 当Coq执行一个证明脚本的时候，在内部，Coq逐渐构造出一个证明对象—— 一个类型是想要证明的命题的项。在 **Proof** 和 **Qed** 之间的策略告诉 Coq如何构造该项。为了了解这个过程是如何进行的，在下面的策略证明里， 我们在多个地方使用 **Show** **Proof** 指令来显示当前证明树的状态。

```coq
Theorem ev_4'' : ev 4.
Proof.
  Show Proof.   (* ?Goal *)
  apply ev_SS.
  Show Proof.   (* (ev_SS 2 ?Goal) *)
  apply ev_SS.
  Show Proof.   (* (ev_SS 2 (ev_SS 0 ?Goal)) *)
  apply ev_0.
  Show Proof.   (* (ev_SS 2 (ev_SS 0 ev_0)) *)
Qed.
```

在任意的给定时刻，Coq已经构造了一个包含一个“洞(hole)”（即 **?**Goal ）的项，并且Coq知道该洞需要什么类型的证据来填补。

每一个洞对应一个子目标。当没有子目标时，代表证明已经完成。此时，<u>我们构造的证明将会被存储在全局环境中，其名字就是在 ​</u>​<u>**Theorem**</u>​<u>​ 中给定的名字</u>

策略证明非常有用且方便，但是它们并不是必要的：原则上，我们总是能够手动构造想要的证据，如下所示。<u>此处我们可以通过 ​</u>​<u>**Definition**</u>​<u>​ （而非 ​</u>​<u>**Theorem**</u>​<u>）来直接给这个证据一个全局名称。</u>

```coq
Definition ev_4''' : ev 4 :=
  ev_SS 2 (ev_SS 0 ev_0).
(* 如果给出的定义（证明）有误，报错是类型不匹配。 例如：
Error: The term "ev_SS 2 (ev_SS 0 ev_0)" has type "ev 4"
while it is expected to have type "ev 8".
*)
```

所有这些构造证明的不同方式，对应的存储在全局环境中的证明是完全一样的。

```coq
Print ev_4.
(* ===> ev_4    =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4'.
(* ===> ev_4'   =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4''.
(* ===> ev_4''  =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
Print ev_4'''.
(* ===> ev_4''' =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
```

写出对应 **ev** **8** 的策略证明和证明对象。

```coq
Theorem ev_8 : ev 8.
Proof.
  (* 请在此处解答 *) 
  apply ev_SS.
  apply ev_SS.
  apply ev_SS.
  apply ev_SS.
  apply ev_0.
Qed.

Definition ev_8' : ev 8
  (* 将本行替换成 ":= _你的_定义_ ." *) 
  := ev_SS 6 (ev_SS 4 (ev_SS 2 (ev_SS 0 ev_0))).
```

‍

### 量词，蕴含式，函数

> 复习：
>
> 构造子：
>
> ```coq
> Inductive rgb : Type :=
>   | red
>   | green
>   | blue.
> ```
>
> 蕴含式：
>
> 函数：
>
> ```coq
> Definition next_weekday (d:day) : day :=
>   match d with
>   | monday    => tuesday
>   | tuesday   => wednesday
>   end.
> ```

在Coq的计算世界里（即所有的数据结构和程序存在的地方），有两种值的类型中拥有箭头：一种是***'构造子(Constructor)'***，它通过归纳地定义数据类型 引入，另一种是***'函数(Function)'***。

类似地，在Coq的逻辑世界里（即我们运用证明的地方），有两种方式来给与蕴含式需要的证据：构造子，通过归纳地定义命题引入，和...函数！

例如，考虑下列陈述：

```coq
Theorem ev_plus4 : forall n, ev n -> ev (4 + n).
Proof.
  intros n H. simpl.
  apply ev_SS.
  apply ev_SS.
  apply H.
Qed.
```

对应 **ev_plus4** 的证明对象是什么？

我们在寻找一个*'类型(Type)'*是 **∀** **n**, **ev** **n** **→** **ev** **(4** **+** **n**) 的表达式——也就是说，<u>一个接受两个参数（一个数字和一个证据）并返回一个证据的 ​</u>​<u>*'函数(Function)'*</u>​<u>!</u>

它的证据对象：

```coq
Definition ev_plus4' : forall n, ev n -> ev (4 + n) :=
  fun (n : nat) => fun (H : ev n) =>
    ev_SS (S (S n)) (ev_SS n H).
```

回顾 **fun** **n** **⇒** **blah** 意味着“一个函数，给定 **n**，产生 **blah**”， 并且Coq认为 **4** **+** **n** 和 **S (S (S (S n))) ​**是同义词，所以另一种写出 这个定义的方式是：

```coq
Definition ev_plus4'' (n : nat) (H : ev n)
                    : ev (4 + n) :=
  ev_SS (S (S n)) (ev_SS n H).

Check ev_plus4''
  : forall n : nat,
    ev n ->
    ev (4 + n).
```

当我们将 **ev_plus4** 证明的命题视为一个函数类型时，我们可以发现一个 有趣的现象：第二个参数的类型，**ev** **n**，依赖于第一个参数 **n** 的*'值'*。

虽然这样的==*'依赖类型 (Dependent type)'*==在传统的编程语言中并不存在， 但是它们对于编程来说有时候非常有用。最近它们在函数式编程社区里的活 跃很好地表明了这一点。

<u>注意到蕴含式（</u>​<u>**→**</u>​<u>）和量化（</u>​<u>**∀**</u>​<u>）都表示证据上的函数。事实上，他们 是同一个东西</u>：当我们使用**∀**时没有依赖，就可以简写为当**→**。即，我 们没有必要给与箭头左边的类型一个名字：  
**​           ∀ (x:nat), nat
        = ∀ (_:nat), nat
        = nat → nat**

例如，考虑下列命题：

```coq
Definition ev_plus2 : Prop :=
  forall n, forall (E : ev n), ev (n + 2).
```

这个命题的一个证明项会是一个拥有两个参数的函数：一个数字**n** 和一个表明**n**是偶数的证据**E**。但是对于这个证据来说，名字**E**并没有 在**ev_plus2**剩余的陈述里面被使用，所以还专门为它取一个名字并没有意义。因此我们可以使用虚拟标志符**_**来替换真实的名字：

```coq
Definition ev_plus2' : Prop :=
  forall n, forall (_ : ev n), ev (n + 2).
```

或者，等同地，我们可以使用更加熟悉的记号：

```coq
Definition ev_plus2'' : Prop :=
  forall n, ev n -> ev (n + 2).
```

<u>总的来说，&quot;</u>​<u>**P**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>&quot;只是 &quot;</u>​<u>**∀ (_:P), Q**</u>​<u>&quot;的语法糖。</u>

‍

> https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E7%B1%BB%E5%9E%8B
>
> 在[计算机科学](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6 "计算机科学")和[逻辑](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91 "逻辑")中，**依赖类型**（或**依存类型**，**dependent type**）是指依赖于值的[类型](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B "类型")，其理论同时包含了[数学基础](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80 "数学基础")中的[类型论](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E8%AE%BA "类型论")和计算机编程中用以减少[程序错误](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF "程序错误")的[类型系统](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F "类型系统")两方面。在 [Per Martin-Löf](https://zh.wikipedia.org/wiki/Per_Martin-L%C3%B6f "Per Martin-Löf") 的[直觉类型论](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%A7%89%E7%B1%BB%E5%9E%8B%E8%AE%BA "直觉类型论")中，依赖类型可对应于[谓词逻辑](https://zh.wikipedia.org/wiki/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91 "谓词逻辑")中的[全称量词](https://zh.wikipedia.org/wiki/%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D "全称量词")和[存在量词](https://zh.wikipedia.org/wiki/%E5%AD%98%E5%9C%A8%E9%87%8F%E8%AF%8D "存在量词")；在依赖类型[函数式编程语言](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80 "函数式编程语言")如 [ATS](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8B%95%E5%88%97%E8%BB%8A%E5%81%9C%E6%AD%A2%E8%A3%9D%E7%BD%AE "自动列车停止设备")、[Agda](https://zh.wikipedia.org/wiki/Agda "Agda")、[Dependent ML](https://zh.wikipedia.org/w/index.php?title=Dependent_ML&action=edit&redlink=1 "Dependent ML（页面不存在）")、[Epigram](https://zh.wikipedia.org/w/index.php?title=Epigram&action=edit&redlink=1 "Epigram（页面不存在）")、[F*](https://zh.wikipedia.org/wiki/F* "F*") 和 [Idris](https://zh.wikipedia.org/wiki/Idris "Idris") 中，依赖类型系统通过极其丰富的类型表达能力使得程序规范得以借助类型的形式被检查，从而有效减少程序错误。
>
> 依赖类型的两个常见实例是**依赖函数类型**（又称**依赖乘积类型**、**Π-类型**）和**依赖值对类型**（又称**依赖总和类型**、**Σ-类型**）。一个依赖类型函数的返回值类型可以依赖于某个参数的具体值，而非仅仅参数的类型，例如，一个输入参数为整型值n的函数可能返回一个长度为n的数组；一个依赖类型值对中的第二个值可以依赖于第一个值，例如，依赖类型可表示这样的类型：它由一对整数组成，其中的第二个数总是大于第一个数。
>
> 依赖类型增加了类型系统的复杂度。由于确定两个依赖于值的类型的等价性需要涉及具体的计算，若允许在依赖类型中使用任意值的话，其[类型检查](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5 "类型检查")将会成为[不可判定问题](https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8 "不可判定问题列表")；换言之，无法确保程序的类型检查一定会停机。
>
> 由于[Curry-Howard同构](https://zh.wikipedia.org/wiki/Curry-Howard%E5%90%8C%E6%9E%84 "Curry-Howard同构")揭示了程序语言的[类型论](https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E8%AE%BA "类型论")与证明论的[直觉逻辑](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%A7%89%E9%80%BB%E8%BE%91 "直觉逻辑")之间的紧密关联性，以依赖类型系统为基础的编程语言大多同时也作为构造证明与可验证程序的辅助工具而存在，如 Coq 和 Agda（但并非所有证明辅助工具都以类型论为基础）；近年来，一些以通用和系统编程为目的的编程语言被设计出来，如 Idris。
>
> 一些以证明辅助为主要目的的编程语言采用[强函数式编程](https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "强函数式编程")（total functional programming），这消除了停机问题，同时也意味着通过它们自身的核心语言无法实现任意无限递归，不是[图灵完全](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%85%A8 "图灵完全")的，如 Coq 和 Agda；另外一些依赖类型编程语言则是图灵完全的，如 Idris、由 [ML](https://zh.wikipedia.org/wiki/ML%E8%AF%AD%E8%A8%80 "ML语言") 派生而来的 ATS 和 由 [F#](https://zh.wikipedia.org/wiki/F%E2%99%AF "F♯") 派生而来的 F*。
>
>> **强函数式编程**（也称为**全函数式编程**），[[1]](https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-1)^^与之相对的是普通的或者说弱[函数式编程](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B "函数式编程")。是一种[编程](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1 "程序设计")范式，它将程序的范围限制为[可证明停机的程序](https://zh.wikipedia.org/wiki/%E5%88%A4%E5%AE%9A%E5%99%A8 "判定器")。 [[2]](https://zh.wikipedia.org/wiki/%E5%BC%BA%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-TFP-2)^^
>>

### 使用策略编程

如果我们可以通过显式地给出项，而不是执行策略脚本，来构造证明，你可能会好奇我们是否可以通过*'策略'*，而不是显式地给出项，来构造*'程序'*。 自然地，答案是可以！

```coq
Definition add1 : nat -> nat.
intro n.
Show Proof.   (* (fun n : nat => ?Goal) *)
apply S.
Show Proof.   (* (fun n : nat => S ?Goal) *)
apply n. Defined.

Print add1.
(* ==>
    add1 = fun n : nat => S n
         : nat -> nat
*)

Compute add1 2.
(* ==> 3 : nat *)
```

注意到我们通过使用**.**终止了**Definition**，而不是使用**:=**和一个项来定义它。这个记号会告诉Coq进入*'证明脚本模式(Proof Scripting Mode)'*来构造类型是**nat** **→** **nat**的项。并且，<u>我们通过使用</u>​<u>**Defined**</u>​<u>而不是 ​</u>​<u>**Qed**</u>​<u>来终止证明；这使得这个定义是</u>​==<u>*'透明的(Transparent)'*</u>==​<u>，所以它可以在计算中就像正常定义的函数一样被使用。（通过</u>​<u>**Qed**</u>​<u>定义的对象在计算中是不透明的。）</u>#TODO#​

这个特性主要是在定义拥有依赖类型的函数时非常有用。我们不会在本书中详细讨论后者。但是它确实表明了Coq里面基本思想的一致性和正交性。

‍

### 逻辑联结词作为归纳类型

归纳定义足够用于表达我们目前为止遇到的大多数的联结词。<u>事实上， 只有全称量化（以及作为特殊情况的蕴含式）是 Coq 内置的，所有其他的都是被归纳定义的。</u>在这一节中我们会看到它们的定义。

#### 合取

为了证明**P** **∧** **Q**成立，我们必须同时给出**P**和**Q**的证据。因此，我们可 以合理地将**P** **∧** **Q**的证明对象定义为包含两个证明的元祖：一个是**P**的证明，另一个是**Q**的证明。即我们拥有如下定义。

```coq
Inductive and (P Q : Prop) : Prop :=
| conj : P -> Q -> and P Q.
```

注意到这个定义与在章节 [Poly](https://coq-zh.github.io/SF-zh/lf-current/Poly.html) 中给出的 **prod** 定义的类型的相似处； 唯一的不同之处在于，**prod**的参数是 **Type**，而 **and ​**的类型是 **Prop**。

```coq
Print prod.
(* ===>
   Inductive prod (X Y : Type) : Type :=
   | pair : X -> Y -> X * Y. *)
```

这个定义能够解释为什么 **destruct ​**和 **intros ​**模式能用于一个合取前提。 情况分析允许我们考虑所有**P** **∧** **Q**可能被证明的方式——只有一种方式（即 ==**conj ​**==​==构造子==）。`| conj : P -> Q -> and P Q.`​

> ​#GPT#​ conj 来源于英语单词 conjunction，意思是“连接，连结”。它是一个 Prop 类型（数学上用来表示命题是真的，或者模型中的数据满足一些关系）的操作符，可以将两个命题组合成一个，这意味着它们必须同时为真。换句话说，一个 conj 就是一个共享了同一个 Introduction 证明过程 P /\ Q 的两个子目标 P 和 Q，它们之间没有中间状态。

类似地，==**split ​**==​==策略==能够用于所有只有一个构造子的归 纳定义命题。特别地，它能够用于**and**：

```coq
Lemma and_comm : forall P Q : Prop, P /\ Q <-> Q /\ P.
Proof.
  intros P Q. split.
  - intros [HP HQ]. split.
    + apply HQ.
    + apply HP.
  - intros [HQ HP]. split.
    + apply HP.
    + apply HQ.
Qed.

```

这解释了为什么一直以来我们能够使用策略来操作 **and ​**的归纳定义。我们也可以使用模式匹配来用它直接构造证明。例如：

```coq
Definition and_comm'_aux P Q (H : P /\ Q) : Q /\ P :=
  match H with
  | conj HP HQ => conj HQ HP
  end.

Definition and_comm' P Q : P /\ Q <-> Q /\ P :=
  conj (and_comm'_aux P Q) (and_comm'_aux Q P).
(* <-> 是 <- 与 -> 的合取  *)
```

构造一个证明对象来证明下列命题。

```coq
Definition conj_fact : forall P Q R, P /\ Q -> Q /\ R -> P /\ R
  (* 将本行替换成 ":= _你的_定义_ ." *) :=
  fun (P Q R:Prop) (HPQ:P /\ Q) (HQR:Q /\ R) => 
  match HPQ, HQR with 
  | conj HP HQ , conj HQ2 HR => conj HP HR
  end.
(* TODO 有待理解，为什么就直接产生证实了 *)
```

‍

#### 析取

析取的归纳定义有两个构造子，分别用于析取的两边：

```coq
Inductive or (P Q : Prop) : Prop :=
| or_introl : P -> or P Q
| or_intror : Q -> or P Q.
```

这个声明解释了**destruct**策略在一个析取前提上的行为，产生的子类型和 **or_introl ​**以及 **or_intror**构造子的形状相匹配。

又一次地，我们可以不使用策略，直接写出涉及**or**的定义的证明对象。

尝试写下**or_commut**的显式证明对象。（不要使用**Print**来偷看我们已经 定义的版本！）

```coq
(* 我就偷看 ;-) *)
Print or_comm.
(* or_comm = 
fun A B : Prop =>
conj
  (fun H : A \/ B =>
   match H with
   | or_introl x => (fun H0 : A => or_intror H0) x
   | or_intror x => (fun H0 : B => or_introl H0) x
   end)
  (fun H : B \/ A =>
   match H with
   | or_introl x => (fun H0 : B => or_intror H0) x
   | or_intror x => (fun H0 : A => or_introl H0) x
   end)
	 : forall A B : Prop, A \/ B <-> B \/ A

Arguments or_comm (A B)%type_scope
 *)
Print or_commut.
(* or_commut = 
fun (P Q : Prop) (H : P \/ Q) =>
match H with
| or_introl x => (fun HP : P => or_intror HP) x
| or_intror x => (fun HQ : Q => or_introl HQ) x
end
	 : forall P Q : Prop, P \/ Q -> Q \/ P

Arguments or_commut (P Q)%type_scope _
 *)
Definition or_comm : forall P Q, P \/ Q -> Q \/ P
  (* 将本行替换成 ":= _你的_定义_ ." *)  :=
  fun (P Q : Prop) (pq: P \/ Q) =>
  match pq with
    | or_introl p => or_intror Q p
    | or_intror q => or_introl P q
  end.
```

‍

#### 存在量化

为了给出存在量词的证据，我们将一个证据类型**x**和**x**满足性质**P**的证明打包在一起：

```coq
Inductive ex {A : Type} (P : A -> Prop) : Prop :=
| ex_intro : forall x : A, P x -> ex P.
```

打包之后的命题可以通过解包操作受益。这里的核心定义是为了用于构造 **ex** **P**命题的类型构造器**ex**，其中**P**自身是一个从类型为**A**的证据类型 值到命题的*'函数(Function)'*。构造子**ex_intro**提供了一个给定证据类型**x**和**P** **x**的证明，可以构造**ex** **P**的证据的方式。

我们更加熟悉的类型**∃** **x**, **P** **x**可以转换为一个涉及**ex**的表达式：

```coq
Check ex (fun n => ev n) : Prop.
```

下面是我们如何定义一个涉及**ex**的显式证明对象：

```coq
Definition some_nat_is_even : exists n, ev n :=
  ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0)).
```

```coq
(** **** 练习：2 星, standard, optional (ex_ev_Sn) 

    完成下列证明对象的定义： *)

Definition ex_ev_Sn : ex (fun n => ev (S n))
  (* 将本行替换成 ":= _你的_定义_ ." *). Admitted.
(* TODO 有待理解 *)

```

​#TODO#​

#### True 和 False

**True**命题的归纳定义很简单：

```coq
Inductive True : Prop :=
  | I : True.
```

它拥有一个构造子（因此**True**的所有证据都是一样的，所以给出一个 **True**的证明并没有信息量。）

False也一样的简单——事实上，它是如此简单，以致于第一眼看上去像是一个 语法错误。

```coq
Inductive False : Prop := .
```

也就是说， **False**是一个*'没有'*构造子的归纳类型--即，没有任何方式能 够构造一个它的证明。

‍

### 相等关系

在Coq里，甚至连相等关系都不是内置的。它拥有如下的归纳定义。（事实上， 在标准库里的定义是这里给出的定义的轻微变体，前者给出了稍微容易使用 一些的归纳法则。）

```coq
Inductive eq {X:Type} : X -> X -> Prop :=
| eq_refl : forall x, eq x x.

Notation "x == y" := (eq x y)
                    (at level 70, no associativity)
                    : type_scope.
```

我们可以这样理解这个定义，给定一个集合**X**，它定义了由**X**的一对值 (**x**和**y**)所索引的“**x**与**y**相等”的一*'系列(Family)'*的命题。只有 一种方式能够构造该系列中成员的证据：将构造子**eq_refl**应用到类型**X** 和值**x**:**X**，产生一个**x**等于**x**的证据。

其它形如 **eq** **x** **y** 的类型中的 **x** 和 **y** 并不相同，<u>因此是非居留的</u>。#疑惑#​ 意思是 非相等的？

我们可以使用**eq_refl**来构造证据，比如说，**2** **=** **2**。那么我们能否使用 它来构造证据**1** **+** **1** **=** **2**呢？答案是肯定的。事实上，它就是同一个证据！

原因是<u>如果两个项能够通过一些简单的计算规则</u>​==<u>*'可转换(convertible)'*</u>==​==<u>​ ​</u>==​<u>， 那么Coq认为两者“相等”。</u>

这些计算规则，与**Compute**所使用的规则相似，包括函数应用的计算，定义的内联，**match**语句的化简。

```coq
Lemma four: 2 + 2 == 1 + 3.
Proof.
  apply eq_refl.
Qed.
```

<u>至今为止我们所用来证据相等关系的 ​</u>​<u>**reflexivity ​**</u>​<u>策略本质上只是 ​</u>​<u>**apply**</u>​<u>​ ​</u>​<u>**eq_refl ​**</u>​<u>的简写</u>。

> ​#疑惑#​  `=`​ 与 `==`​ 的关系？实测 `reflexivity`​ 只能证明 `=`​。猜测 `==`​ 只是为了临时举例子用？
>
> ```coq
> (* TODO coq 中 `=` 与 `==` 的关系？
> 实测 `reflexivity` 只能证明 `=` *)
> Lemma four_': 2 + 2 = 1 + 3.
> Proof. reflexivity. Qed.
>
> Lemma four_f: 2 + 2 == 1 + 3.
> Proof.
>   Fail reflexivity.
> ```

在基于策略的相等关系证明中，转换规则通常隐藏在**simpl**的使用后面（在 其他策略中或显式或隐式，例如**reflexivity**）。

而在如下的显式证明对象中，你可以直接看到它们：

```coq
Definition four' : 2 + 2 == 1 + 3 :=
  eq_refl 4.

Definition singleton : forall (X:Type) (x:X), []++[x] == x::[]  :=
  fun (X:Type) (x:X) => eq_refl [x].
```

相等关系的归纳定义隐含了*'Leibniz相等关系(Leibniz equality)'*：当我们 说“**x**和**y**相等的时候”，我们意味着所有**x**满足的性质**P**，对于**y** 来说也满足。事实上，相等关系的归纳定义和Leibniz相等关系是 *'等价的(equivalent)'*。

```coq
(** **** 练习：2 星, standard (equality__leibniz_equality) 

    相等关系的归纳定义隐含了_'Leibniz相等关系(Leibniz equality)'_：当我们
    说“[x]和[y]相等的时候”，我们意味着所有[x]满足的性质[P]，对于[y]
    来说也满足。 *)

Lemma equality__leibniz_equality : forall (X : Type) (x y: X),
  x == y -> forall P:X->Prop, P x -> P y.
Proof.
(* 请在此处解答 *) Admitted.
(** [] *)

(** **** 练习：5 星, standard, optional (leibniz_equality__equality) 

    请说明，事实上，相等关系的归纳定义和Leibniz相等关系是
    _'等价的(equivalent)'_。 *)

Lemma leibniz_equality__equality : forall (X : Type) (x y: X),
  (forall P:X->Prop, P x -> P y) -> x == y.
Proof.
(* 请在此处解答 *) Admitted.

```

‍

#### 再论反演

​#TODO#​

我们曾经见过**inversion ​**被同时用于相等关系前提，和关于被归纳定义的命题的前提。现在我们明白了实际上它们是同一件事情。那么我们现在可以细 究一下**inversion**是如何工作的。

一般来说，**inversion**策略...

* 接受一个前提**H**，该前提的类型**P**是通过归纳定义的，以及
* 对于**P**的定义里的每一个构造子**C**，

  * 产生一个新的子目标，在该子目标中我们假设**H**是通过**C**构造的，
  * 作为额外的假设，在子目标的上下文中增加**C**的论据（前提），
  * 将**C**的结论（结果类型）与当前的目标相匹配，计算出为了能够应用**C**而必须成立的一些相等关系，
  * 将这些相等关系加入上下文中（以及，为了方便，在目标中替换它们），以及
  * 如果这些相等关系无法满足（例如，它们涉及到**S** **n** **=** **O**），那么立即解决这个子目标。

*'例子'*：如果我们反演一个使用**or**构造的前提，它有两个构 造子，所以产生了两个子目标。构造子的结论（结果类型，即**P** **∨** **Q**） 并没有对于**P**和**Q**的形式有任何要求，所以在子目标的上下文中我们不会 获得额外的相等关系。

*'例子'*：如果我们反演一个使用**and**构造的前提，它只有一个构造子， 所以只产生一个子目标。再一次地，构造子的结论（结果类型，即**P** **∧** **Q**） 并没有对于**P**和**Q**的形式有任何要求，所以在子目标的上下文中我们不会 获得额外的相等关系。不过，这个构造子有两个额外的参数，我们能够在子 目标的上下文中看到它们。

*'例子'*：如果我们反演一个使用**eq**构造的前提，它也只有一个构造子， 所以只产生一个子目标。但是，现在**eq_refl**构造子的形式给我们带来 的额外的信息：它告诉**eq**的两个参数必须是一样的。于是**inversion ​**策略会将这个事实加入到上下文中。

‍

## 归纳法则    (IndPrinciples)

* [基础](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab282)
* [多态](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab288)
* [归纳假设](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab293)
* [深入 ](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab294)​**[induction](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab294)**​[ 策略](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab294)
* [Prop 中的归纳法则](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab296)
* [形式化 vs. 非形式化的归纳证明](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab297)

  * [对归纳定义的集合进行归纳](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab298)
  * [对归纳定义的命题进行归纳](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab299)
* [Explicit Proof Objects for Induction (Optional)](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab300)
* [The Coq Trusted Computing Base](https://coq-zh.github.io/SF-zh/lf-current/IndPrinciples.html#lab301)

‍

‍

## 关系的性质    (Rel)

* [关系](https://coq-zh.github.io/SF-zh/lf-current/Rel.html#lab302)
* [基本性质](https://coq-zh.github.io/SF-zh/lf-current/Rel.html#lab303)
* [自反传递闭包](https://coq-zh.github.io/SF-zh/lf-current/Rel.html#lab320)

‍

## 简单的指令式程序    (Imp)

* [算术和布尔表达式](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab323)

  * [语法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab324)
  * [求值](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab325)
  * [优化](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab326)
* [Coq 自动化](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab327)

  * [泛策略](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab328)
  * [定义新的策略记法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab335)
  * [omega 策略](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab336)
  * [更多方便的策略](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab337)
* [求值作为关系](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab338)

  * [推理规则的记法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab339)
  * [定义的等价关系](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab341)
  * [计算式定义与关系式定义](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab343)
* [带变量的表达式](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab344)

  * [状态](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab345)
  * [语法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab346)
  * [记法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab347)
  * [求值](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab348)
* [指令](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab349)

  * [语法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab350)
  * [脱糖记法](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab351)
  * [Locate 命令](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab352)
  * [更多示例](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab355)
* [求值指令](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab358)

  * [求值作为函数（失败的尝试）](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab359)
  * [求值作为一种关系](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab360)
  * [求值的确定性](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab364)
* [对 Imp 进行推理](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab365)
* [附加练习](https://coq-zh.github.io/SF-zh/lf-current/Imp.html#lab370)

‍

‍

‍

## 用 Coq 实现词法分析和语法分析    (ImpParser)

* [内部结构](https://coq-zh.github.io/SF-zh/lf-current/ImpParser.html#lab378)

  * [词法分析](https://coq-zh.github.io/SF-zh/lf-current/ImpParser.html#lab379)
  * [语法分析](https://coq-zh.github.io/SF-zh/lf-current/ImpParser.html#lab380)
* [示例](https://coq-zh.github.io/SF-zh/lf-current/ImpParser.html#lab384)

‍

‍

## Imp 的求值函数    (ImpCEvalFun)

* [一个无法完成的求值器](https://coq-zh.github.io/SF-zh/lf-current/ImpCEvalFun.html#lab385)
* [一个计步的求值器](https://coq-zh.github.io/SF-zh/lf-current/ImpCEvalFun.html#lab386)
* [关系求值 vs. 计步求值](https://coq-zh.github.io/SF-zh/lf-current/ImpCEvalFun.html#lab389)
* [再论求值的确定性](https://coq-zh.github.io/SF-zh/lf-current/ImpCEvalFun.html#lab392)

‍

‍

## 从 Coq 中提取 ML    (Extraction)

* [基本的提取方式](https://coq-zh.github.io/SF-zh/lf-current/Extraction.html#lab393)
* [控制提取特定的类型](https://coq-zh.github.io/SF-zh/lf-current/Extraction.html#lab394)
* [一个完整的示例](https://coq-zh.github.io/SF-zh/lf-current/Extraction.html#lab395)
* [讨论](https://coq-zh.github.io/SF-zh/lf-current/Extraction.html#lab396)
* [更进一步](https://coq-zh.github.io/SF-zh/lf-current/Extraction.html#lab397)

‍

‍

‍

## 更多的自动化    (Auto)

‍

## More Automation    (AltAuto)

‍

## 后记    (Postscript)

‍

‍

[^1]: ### 形式化证明 vs. 非形式化证明


[^2]: #### 用函数构造函数


[^3]: 突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 用...
