---
title: 逻辑基础
date: 2022-11-26T01:03:43Z
lastmod: 2022-12-31T18:58:42Z
---

# 逻辑基础

[逻辑基础 (coq-zh.github.io)](https://coq-zh.github.io/SF-zh/lf-current/index.html)

## 前言    (Preface)

‍

每一章都包含大量的习题。每个习题都有标有“星级”，其含义是：

* 一星：很简单习题，强调课程的重点。对于大部分读者而言， 一两分钟应该足够了。养成看到一个做一个的习惯。
* 二星：直截了当的习题（5 到 10 分钟）。
* 三星：需要一点思考的习题（10 分钟到半小时）。

‍

```coq
If you want to refer to this volume in your own writing, please do so as follows:
    @book            {Pierce:SF1,
    author       =   {Benjamin C. Pierce and
                      Arthur Azevedo de Amorim and
                      Chris Casinghino and
                      Marco Gaboardi and
                      Michael Greenberg and
                      Cătălin Hriţcu and
                      Vilhelm Sjöberg and
                      Brent Yorgey},
    editor       =   {Benjamin C. Pierce},
    title        =   "Logical Foundations",
    series       =   "Software Foundations",
    volume       =   "1",
    year         =   "2022",
    publisher    =   "Electronic textbook",
    note         =   {Version 6.2, \URL{http://softwarefoundations.cis.upenn.edu}}
    }

如果你想在自己的作品中引用本书，请采用以下格式：
   @book {Pierce:SF1,
   author = {Benjamin C. Pierce and Arthur Azevedo de Amorim and Chris Casinghino and Marco Gaboardi and Michael Greenberg and Cătălin Hriţcu and Vilhelm Sjöberg and Brent Yorgey},
   title = "逻辑基础",
   series = "Software Foundations",
   volume = "1",
   year = "2022",
   publisher = "Electronic textbook",
   note = {Version 5.7, \URL{http://softwarefoundations.cis.upenn.edu} },
   }
```

课程视频

*'《逻辑基础》'*夏季加强班（DeepSpec 夏季班系列之一）的课程讲义可访问 [https://deepspec.org/event/dsss17](https://deepspec.org/event/dsss17) 和 [https://deepspec.org/event/dsss18/](https://deepspec.org/event/dsss18/) 获取。2017 年的视频清晰度不高，但在之后的课程中会更好。

‍

章节依赖

章节之间的依赖关系图以及建议的学习路线可以在文件 [deps.html](https://coq-zh.github.io/SF-zh/lf-current/deps.html) 中查看。

‍

## Coq 函数式编程    (Basics)

* [引言](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab19)
* [数据与函数](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab20)

  * [枚举类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab21)
  * [一周七日](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab22)
  * [作业提交指南](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab23)
  * [布尔值](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab24)
  * [类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab27)
  * [由旧类型构造新类型](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab28)
  * [元组](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab29)
  * [模块](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab30)
  * [数值](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab31)
* [基于化简的证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab34)
* [基于改写的证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab35)
* [利用分类讨论来证明](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab38)
* [关于记法的更多内容 (可选)](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab41)
* [不动点 ](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)​**[Fixpoint](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)**​[ 和结构化递归 (可选)](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab42)
* [更多练习](https://coq-zh.github.io/SF-zh/lf-current/Basics.html#lab44)

### 数据与函数

一周七日

```coq
Inductive day : Type :=
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday.

Definition next_weekday (d:day) : day :=
  match d with
  | monday ⇒ tuesday
  | tuesday ⇒ wednesday
  | wednesday ⇒ thursday
  | thursday ⇒ friday
  | friday ⇒ monday
  | saturday ⇒ monday
  | sunday ⇒ monday
  end.

Compute (next_weekday friday).
(* ==> monday : day *)
Compute (next_weekday (next_weekday saturday)).
(* ==> tuesday : day *)

Example test_next_weekday:
  (next_weekday (next_weekday saturday)) = tuesday.
Proof. simpl. reflexivity. Qed.
```

‍

​#TODO#​ 第三，我们可以让 Coq 从 **Definition** 中*'提取（Extract）'* 出用其它更加常规的编程语言编写的程序 （如 OCaml、Scheme、Haskell 等），它们拥有高性能的编译器。 这种能力非常有用，我们可以通过它将 Gallina 编写的 *'证明正确'* 的算法转译成高效的机器码。（诚然，我们必须信任 OCaml/Haskell/Scheme 的编译器，以及 Coq 提取工具自身的正确性，然而比起现在大多数软件的开发方式， 这也是很大的进步了。）实际上，这就是 Coq 最主要的使用方式之一。 在之后的章节中我们会回到这一主题上来。

```coq
Notation "x && y" := (andb x y).
Notation "x || y" := (orb x y).
```

Coq 实际上支持对_任何_归纳定义的双子句表达式使用 "if" 表达式 （不过恰巧在这里该表达式被称为 **bool**）。<u>当条件求值后得到的是第一个 子句的 “构造子” (constructor)，那么条件就会被认为是 “真” ​</u>​**true**（不过恰巧 在这里第一个分支的构造子被称为 “真” **true**，并且如果求值后得到的是第二个子句， 那么条件就被认为是 “假” **false**）。

‍

如果在被 ==**Check**== 的表达式后加上一个分号和你想验证的类型，那么 Coq 会 验证该表达式是否属于你提供的类型。当两者不一致时，Coq 会报错并终止执行。

```coq
Check true
    : bool.
Check (negb true)
    : bool.
```

‍

#### 由旧类型构造新类型

```coq
Inductive rgb : Type :=
  | red
  | green
  | blue.
Inductive color : Type :=
  | black
  | white
  | primary (p : rgb).
```

像 **red**、**green**、**blue**、**black**、**white** 以及 **primary**（还有 **true**、**false**、**monday** 等）这样的原子标识符叫做​*'*​==*构造子（Constructor）*==​*'*​。

我们可以用它们来构建​*'构造子表达式（Constructor Expression）'*​， 其中每一个要么是一个简单的构造子，要么就是一个构造子应用于一个或多个参数 （每个这样的参数也都是构造子表达式）。

我们来仔细研究一下。每个归纳定义的类型（如 **day**、**bool**、**rgb**、**color** 等） 都描述了一组由*'构造子'*构成的​*'构造子表达式'*​。

* 我们从有限的一组*'构造子'*开始。例如 **red**、**primary**、**true**、**false**、**monday** 等等都是构造子。
* *'构造子表达式'*通过将构造子应用到一个或多个构造子表达式上构成。例如 **red**、**true**、**primary**、**primary** **red**、**red** **primary**、**red** **true**、 **primary** **(**primary **primary**) 等等
* 每个 **Inductive** 定义都刻画了一个构造子表达式的子集并赋予了它们名字，如 **bool**、**rgb** 或 **color**。

具体来说，**rgb** 和 **color** 的定义描述了如何构造这两个集合中的构造子表达式：

* 构造子表达式 **red**、**green** 和 **blue** 属于集合 **rgb**；
* 构造子表达式 **black** 和 **white** 属于集合 **color**；
* 若 **p** 是属于 **rgb** 的构造子表达式，则 **primary** **p**（读作“构造子 **primary** 应用于参数 **p**）是属于集合 **color** 的构造子表达式；且
* 通过这些方式构造的构造子表达式*'只属于'*集合 **rgb** 和 **color**。

我们可以像之前的 **day** 和 **bool** 那样用模式匹配为 **color** 定义函数。

```coq
Definition monochrome (c : color) : bool :=
  match c with
  | black ⇒ true
  | white ⇒ true
  | primary p ⇒ false
  end.
```

鉴于 **primary** 构造子接收一个参数，匹配到 **primary** 的模式应当带有一个 变量或常量。变量可以取任意名称，如上文所示；常量需有适当的类型，例如：

```coq
Definition isred (c : color) : bool :=
  match c with
  | black ⇒ false
  | white ⇒ false
  | primary red ⇒ true
  | primary _ ⇒ false
  end.
```

这里的模式 **primary** **_** 是“构造子 **primary** 应用到除 **red** 之外的任何 **rgb** 构造子上”的简写形式（通配模式 **_** 的效果与 **monochrome** 定义中的哑（dummy）模式变量 **p** 相同。）

#### 元组

一个多参数的单构造子可以用来创建元组类型。例如，为了让一个 半字节（nybble）表示四个比特。我们首先定义一个 **bit** 数据类型 来类比 **bool** 数据。并且使用 **B**​~0~ 和 **B**​~1~ 两种构造子来表示其可能的取值。 最后定义 **nybble** 这种数据类型，也就是一个四比特的元组。

```coq
Inductive bit : Type :=
  | B0
  | B1.
Inductive nybble : Type :=
  | bits (b0 b1 b2 b3 : bit).
Check (bits B1 B0 B1 B0)
    : nybble.
```

这里的 **bit** 构造子起到了对它内容的包装作用。 解包可以通过模式匹配来实现，就如同下面的 **all_zero** 函数一样， 其通过解包来验证一个半字节的所有比特是否都为 **B**​~0~。 我们用*'通配符'* 来避免创建不需要的变量名。

```coq
Definition all_zero (nb : nybble) : bool :=
  match nb with
    | (bits B0 B0 B0 B0) ⇒ true
    | (bits _ _ _ _) ⇒ false
  end.
Compute (all_zero (bits B1 B0 B1 B0)).
(* ===> false : bool *)
Compute (all_zero (bits B0 B0 B0 B0)).
(* ===> true : bool *)
```

#### 模块

Coq 提供了*'模块系统'*来帮助组织大规模的开发。在本课程中， 我们不太会用到这方面的特性。不过其中有一点非常有用： 如果我们将一组定义放在 **Module** **X** 和 **End** **X** 标记之间，那么在文件中的 **End** 之后，我们就可以通过像 **X.foo** 这样的名字来引用，而不必直接用 **foo** 了。在这里，我们通过此特性在内部模块中引入了 **nat** 类型的定义， 这样就不会覆盖标准库中的同名定义了（我们会在本书后面的部分中使用它， 因为它提供了一些简便的特殊记法。）

```coq
Module NatPlayground.
  (* ... *)
End NatPlayground.
```

#### 数值

```coq
Inductive nat : Type :=
  | O
  | S (n : nat).
```

* 构造子表达式 \[O\] 属于集合 \[nat\]；
* 如果 \[n\] 是属于集合 \[nat\] 的构造子表达式，
  那么 \[S n\] 也是属于集合 \[nat\] 的构造子表达式；并且
* 只有以这两种产生的方式构造字表达式才属于集合 \[nat\]。

为了让自然数使用起来更加自然，Coq 内建了一小部分解析打印功能： 普通的十进制数可视为“一进制”自然数的另一种记法，以代替 **S** 与 **O** 构造子； 反过来，Coq 也会默认将自然数打印为十进制形式：

```coq
Check (S (S (S (S O)))).
(* ===> 4 : nat *)

Definition minustwo (n : nat) : nat :=
  match n with
    | O => O
    | S O => O
    | S (S n') => n'
  end.

Compute (minustwo 4).
(* ===> 2 : nat *)
```

```coq
Check S        : nat->nat.
Check pred     : nat->nat.
Check minustwo : nat->nat.
```

以上三个东西均可作用于自然数，并产生自然数结果，但第一个 **S** 与后两者有本质区别：**pred** 和 **minustwo** 这类函数是通过给定的*'计算规则'*定义的—— 例如 **pred** 的定义表明 **pred** **2** 可化简为 **1**——但 **S** 的定义不包含此类行为。 虽然 **S** 可以作用于参数这点与函数​*'相似'*​，但其作用仅限于构造数字，而并不用于计算。（考虑标准的十进制数：数字 **1** 不代表任何计算，只表示一部分数据。 用 **111** 指代数字一百一十一，实则使用三个 **1** 符号表示此数各位。）

‍

简单的模式匹配不足以描述很多有趣的数值运算，我们还需要递归定义。

 关键字 ==**Fixpoint**== 可用于定义此类函数。

```coq
Fixpoint evenb (n:nat) : bool :=
  match n with
  | O        => true
  | S O      => false
  | S (S n') => evenb n'
  end.

Fixpoint plus (n : nat) (m : nat) : nat :=
  match n with
    | O => m
    | S n' => S (plus n' m)
  end.

Compute (plus 3 2).
(* ===> 5 : nat *)

(** 你可以在两个表达式之间添加逗号来同时匹配它们：*)

Fixpoint minus (n m:nat) : nat :=
  match n, m with
  | O   , _    => O
  | S _ , O    => n
  | S n', S m' => minus n' m'
  end.

Fixpoint exp (base power : nat) : nat :=
  match power with
    | O => S O
    | S p => mult base (exp base p)
  end.
```

```coq
Notation "x + y" := (plus x y)
Notation "x - y" := (minus x y)
Notation "x * y" := (mult x y)
Notation "x =? y" := (eqb x y) 
Notation "x <=? y" := (leb x y)
Notation "x <? y" := (ltb x y) 
```

### 基于化简的证明

```coq
Theorem plus_O_n' : forall n : nat, 0 + n = n.
Proof.
  intros n. reflexivity. Qed.
```

首先，我们使用了关键字 **Theorem** 而非 **Example**。这种差别纯粹是风格问题； 在 Coq 中，<u>关键字 ​</u>​<u>**Example**</u>​<u>​ 和 ​</u>​<u>**Theorem**</u>​<u>（以及其它一些，包括 ​</u>​<u>**Lemma**</u>​<u>、</u>​<u>**Fact**</u>​<u>​ 和 ​</u>​<u>**Remark**</u>​<u>）都表示完全一样的东西。</u>

其次，我们==增加了量词 ​==​==**∀**==​==​ ​==​==**n**==​==:==​==**nat**==，因此我们的定理讨论了*'所有的'* 自然数 **n**。 在非形式化的证明中，为了证明这种形式的定理，我们通常会说“*'假设'* 存在一个任意自然数 **n**...”。而在形式化证明中，这是用 **intros** **n** 来实现的，它会将量词从证明目标转移到当前假设的*'上下文'*中。 注意在 **intros** 从句中，我们可以使用别的标识符来代替 **n**

关键字 **intros**、**simpl** 和 **reflexivity** 都是*'策略（Tactic）'*的例子。 策略是一条可以用在 **Proof**（证明）和 **Qed**（证毕）之间的指令，它告诉 Coq 如何来检验我们所下的一些断言的正确性。

### 基于改写的证明

```coq
Theorem plus_id_example : forall n m:nat,
  n = m ->
  n + n = m + m.
Proof.
  (* 将两个量词移到上下文中： *)
  intros n m.
  (* 将前提移到上下文中： *)
  intros H.
  (* 用前提改写目标： *)
  rewrite -> H.
  reflexivity.  Qed.
```

该定理并未对自然数 **n** 和 **m** 所有可能的值做全称断言，而是讨论了仅当 **n** **=** **m** 时这一更加特定情况。箭头符号读作“==蕴含==”。#TODO#​ 蕴含与前提的关系？

==**intros**== 策略用来将这三条前提从证明目标 移到当前上下文的假设中。

用来告诉 Coq 执行这种替换的策略叫做*'改写'* **rewrite**。

==**rewrite**== 中的箭头与蕴含无关：它指示 Coq 从左往右地应用改写。 若要从右往左改写，可以使用 `rewrite <-`​

**Check** 命令也可用来检查以前声明的引理和定理。

‍

### 利用分类讨论来证明

用 **Abort** 指令来放弃证明。

告诉 Coq 分别对 **n** **=** **0** 和 **n** **=** **S** **n'** 这两种情况进行分析的策略，叫做 **destruct**。

```coq
Theorem plus_1_neq_0 : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros n. destruct n as [| n'] eqn:E.
  - reflexivity.
  - reflexivity.   Qed.
```

==**destruct**== 策略会生成*两个*子目标，为了让 Coq 认可这个定理， 我们必须接下来证明这两个子目标。

as **[|** **n'**] 这种标注被称为 ​*'引入模式'*​。它告诉 Coq 应当在每个子目标中 使用什么样的变量名。总体而言，在方括号之间的是一个由 **|** 隔开的 ​*'列表的列表'*​（译者注：list of lists）。在上面的例子中，第一个元素是 一个空列表，因为 **O** 构造子是一个空构造子（它没有任何参数）。 第二个元素提供了包含单个变量名 **n'** 的列表，因为 **S** 是一个单构造子。

在每个子目标中，Coq 会记录这个子目标中关于 **n** 的假设，**n** **=** **0** 还是 对于某个 n', **n** **=** **S** **n'**。而 **eqn**:**E** 记号则告知 Coq 以 **E** 来命名这些 假设。省略 **eqn**:**E** 会导致 Coq 省略这些假设。这种省略能够使得一些不需要 显式用到这类假设的证明显得更加流畅。但在实践中最好还是保留他们， 因为他们可以作为一种说明文档来在证明过程中指引你。

第二行和第三行中的 **-** 符号叫做​*'标号'*​，它标明了这两个生成的子目标所对应的证明部分。 （译注：此处的“标号”应理解为一个项目列表中每个 *'条目'* 前的小标记，如 ‣ 或 •。） 标号后面的证明脚本是一个子目标的完整证明。在本例中，每个子目标都简单地使用 **reflexivity** 完成了证明。通常，**reflexivity** 本身会执行一些化简操作。 例如，第二段证明将 **at** **(**S **n'** **+** **1)** **0** 化简成 **false**，是通过先将 **(**S **n'** **+** **1)** 转写成 **S** **(**n' **+** **1)**，接着展开 **beq_nat**，之后再化简 **match** 完成的。

**destruct** 策略可用于任何归纳定义的数据类型。比如，我们接下来会用它来证明 布尔值的取反是==对合（Involutive）==的 —— 即，取反是自身的逆运算。

```coq
Theorem negb_involutive : forall b : bool,
  negb (negb b) = b.
Proof.
  intros b. destruct b eqn:E.
  - reflexivity.
  - reflexivity.  Qed.
```

注意这里的 **destruct** 没有 **as** 子句，因为此处 **destruct** 生成的子分类均无需绑定任何变量，因此也就不必指定名字。 实际上，我们也可以省略 *'任何'* **destruct** 中的 **as** 子句， Coq 会自动填上变量名。不过这通常是个坏习惯，因为如果任其自由决定的话， Coq 经常会选择一些容易令人混淆的名字。

有时在一个子目标内调用 **destruct**，产生出更多的*证明义务（Proof Obligation）* 也非常有用。这时候，我们使用不同的标号来标记目标的不同“层级”，比如：

```coq
Theorem andb_commutative : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
  - destruct c eqn:Ec.
    + reflexivity.
    + reflexivity.
Qed.
```

除了 \[-\] 和 \[+\] 之外，还可以使用 \[\*\]（星号）或任何重复的标号符（如 \[--\] 或 \[\*\*\*\]）作为标号。我们也可以用花括号将每个子证明目标括起来：花括号还允许我们在一个证明中的多个层级下使用同一个标号。

```coq
Theorem andb_commutative' : forall b c, andb b c = andb c b.
Proof.
  intros b c. destruct b eqn:Eb.
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
  { destruct c eqn:Ec.
    { reflexivity. }
    { reflexivity. } }
Qed.
```

或许你已经注意到了，    很多证明在引入变量之后会立即对它进行情况分析：

​`intros x y. destruct y as [|y] eqn:E.`

这种写法是如此的常见以至于 Coq 为它提供了一种简写：我们可以在引入 一个变量的同时对他使用*'引入模式'*来进行分类讨论。例如，下面是一个对 **plus_1_neq_0** 的更简短证明。（这种简写的缺点也显而易见， 我们无法再记录在每个子目标中所使用的假设，而之前我们可以通过 **eqn**:**E** 将它们标注出来。）

```coq
Theorem plus_1_neq_0' : forall n : nat,
  (n + 1) =? 0 = false.
Proof.
  intros [|n].
  - reflexivity.
  - reflexivity.  Qed.
```

如果没有需要命名的构造子参数，我们只需写上 **[]** 即可进行情况分析。

```coq
Theorem andb_commutative'' :
  forall b c, andb b c = andb c b.
Proof.
  intros [] [].
  - reflexivity.
  - reflexivity.
  - reflexivity.
  - reflexivity.
Qed.
```

```coq
(** **** 练习：2 星, standard (andb_true_elim2) 

    证明以下断言, 当使用 [destruct] 时请用标号标出情况（以及子情况）。 *)

Theorem andb_true_elim2 : forall b c : bool,
  andb b c = true -> c = true.
Proof.
  intros b c. destruct b eqn:Eb.
  - destruct c eqn:Ec. 
    + simpl. reflexivity.
    + simpl. intros H. rewrite -> H. reflexivity.
  - destruct c eqn:Ec. 
    + simpl. reflexivity.
    + simpl. intros H. rewrite -> H. reflexivity.
Qed.
(* TODO 对蕴含式 [->] 还不怎么理解  *)
```

​#TODO#​ 见上代码框

### 关于记法的更多内容 (可选)

<u>专业提示：Coq 的符号机制不是特别强大，别期望太多。</u>

### 不动点 **Fixpoint** 和结构化递归 (可选)

```coq
(** **** 练习：2 星, standard, optional (decreasing) 

    为了更好的理解这一点，请尝试写一个对于所有输入都_的确_终止的 [Fixpoint]
    定义。但这个定义需要违背上述的限制，以此来让 Coq 拒绝。（如果您决定将这个可选
    练习作为作业，请确保您将您的解答注释掉以防止 Coq 拒绝执行整个文件。）
TODO : 参考来的答案  *)
Fixpoint not_accepted (n : nat) : nat :=
  match n with
  | O => not_accepted (S O)
  | S O => S O
  | S n' => S (not_accepted n')
  end.
```

​#TODO#​

### 更多练习

Each SF chapter comes with a tester file (e.g. **BasicsTest.v**), containing scripts that check most of the exercises. You can run **make** **BasicsTest.vo** in a terminal and check its output to make sure you didn't miss anything.

make *详细配置方案参考下一章（Induction）开头*

这些针对单增函数和二进制转换函数的“单元测试”可以验算你的定义的正确性。 当然，这些单元测试并不能确保你的定义在所有输入下都是正确的！我们在下一章的 末尾会重新回到这个话题。

‍

‍

## 归纳证明    (Induction)

* [归纳法证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab49)
* [证明里的证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab54)
* [形式化证明 vs. 非形式化证明](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab55)
* [更多练习](https://coq-zh.github.io/SF-zh/lf-current/Induction.html#lab58)

配置环境：

对于我使用的 VSCode +  VScoq 插件环境，推荐使用命令行方式配置 make

```bash
coq_makefile -f _CoqProject *.v -o Makefile
make Basics.vo # 编译
make BasicsTest.vo # 批改作业
```

​#TODO#​ 对于 VScoq 插件，得需是当前工作区目录才能正常运行，现在还不知道问题所在。（跟coq的`Export`​对于文件路径的特性有关）

‍

此环境在我的 [GitHub 仓库](https://github.com/framist/Software-Foundations-Note) 中。

### 归纳法证明

回想一下 ​*'自然数的归纳法则'*​，你也许曾在高中的数学课上，在某门离散数学课上或 在其它类似的课上学到过它：若 **P**(**n**) 为关于自然数的命题，而当我们想要证明 **P** 对于所有自然数 **n** 都成立时，可以这样推理：* 证明 **P**(**O**) 成立；

* 证明对于任何 **n'**，若 **P**(**n'**) 成立，那么 **P**(**S** **n'**) 也成立。
* 最后得出 **P**(**n**) 对于所有 **n** 都成立的结论。

在 Coq 中的步骤也一样：我们以证明 **P**(**n**) 对于所有 **n** 都成立的目标开始， 然后（通过应用 ==**induction**== 策略）把它分为两个子目标：一个是我们必须证明 **P**(**O**) 成立，另一个是我们必须证明 **P**(**n'**) **→** **P**(**S** **n'**)。下面就是对该定理的用法：

```coq
Theorem plus_n_O : forall n:nat, n = n + 0.
Proof.
  intros n. induction n as [| n' IHn'].
  - (* n = 0 *)    reflexivity.
  - (* n = S n' *) simpl. rewrite <- IHn'. reflexivity.  Qed.
```

和 **destruct** 一样，**induction** 策略也能通过 **as**... 从句为引入到 子目标中的变量指定名字。由于这次有两个子目标，因此 **as**... 有两部分，用 **|** 隔开。

在第一个子目标中 **n** 被 **0** 所取代。由于没有新的变量会被引入，因此 **as** **...** 字句的第一部分为空

在第二个子目标中，**n** 被 **S** **n'** 所取代，而对 **n'** 的归纳假设（Inductive Hypothesis），即 **n'** **+** **0** **=** **n'** 则以 **IHn'** 为名被添加到了上下文中。 这两个名字在 **as**... 从句的第二部分中指定。在此上下文中，待证目标变成了 **(**S **n'**) **+** o**0** **=** **S** **n'**；它可被化简为 **S** **(**n' **+** **0)** **=** **S** **n'**，而此结论可通过 **IHn'** 得出。

（其实在这些证明中我们并不需要 **intros**：当 **induction** 策略被应用到包含量化变量的目标中时，它会自动将需要的变量移到上下文中。）

接下来就可以证明喜闻乐见的加法交换律和结合律了。

*这样子的证明会让我有一种瞎试就试出来的感觉，比用传统的方式更不明晰。但证明很快，可以保证他就是对的。后文：*"形式化证明 vs. 非形式化证明"[^1]

‍

我们的 **evenb** **n** 定义对 **n** **-** **2** 的递归调用不大方便。这让证明 **evenb** **n** 时更难对 **n** 进行归纳，因此我们需要一个关于 **n** **-** **2** 的归纳假设。 以下引理赋予了 **evenb** **(**S **n**) 另一个特征，使其在归纳时能够更好地工作：#TODO#​ 后文？

‍

### 证明里的证明

*嵌套证明*

简单地陈述并立即证明所需的“子定理”就会很方便。 我们可以用 **assert** 策略来做到。

```coq
Theorem mult_0_plus' : forall n m : nat,
  (0 + n) * m = n * m.
Proof.
  intros n m.
  assert (H: 0 + n = n). { reflexivity. }
  rewrite -> H.
  reflexivity.  Qed.
```

（当然也可以用 **as** 来命名该断言，与之前的 **destruct** 和 **induction** 一样。例如 **assert** **(0** **+** **n** **=** **n**) **as** **H**。）**assert** 生成的第一个子目标是我们必须证明的已断言的事实， 而在第二个子目标中，我们可以使用已断言的事实在一开始尝试证明的事情上取得进展。

```coq
(* 举例来说，假如我们要证明 (n + m) + (p + q) = (m + n) + (p + q)。 = 两边唯一不同的就是内层第一个子式中 + 的参数 m 和 n 交换了位置， 我们似乎可以用加法交换律（plus_comm）来改写它。然而， rewrite 策略并不知道应该作用在 '哪里'。本命题中 + 用了三次 ， 结果 rewrite → plus_comm 只对 '最外层' 起了作用... *)

Theorem plus_rearrange_firsttry : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  (* 我们只需要将 (m + n) 交换为 (n + m)... 看起来 plus_comm 能搞定！*)
  rewrite -> plus_comm.
  (* 搞不定... Coq 选错了要改写的加法！ *)
Abort.

(** 为了在需要的地方使用 [plus_comm]，我们可以（为此这里讨论的 [m] 和 [n]）
    引入一个局部引理来陈述 [n + m = m + n]，之后用 [plus_comm] 证明它，
    并用它来进行期望的改写。 *)

Theorem plus_rearrange : forall n m p q : nat,
  (n + m) + (p + q) = (m + n) + (p + q).
Proof.
  intros n m p q.
  assert (H: n + m = m + n).
  { rewrite -> plus_comm. reflexivity. }
  rewrite -> H. reflexivity.  Qed.
```

‍

### 形式化证明 vs. 非形式化证明

“*'非形式化证明是算法，形式化证明是代码。'*”

证明是一种交流行为

形式化证明在很多方面都非常有用， 不过它们对人类之间的思想交流而言 *'并不'* 十分高效。特别是 Coq 证明中任何一处的“证明状态”都是完全 隐含的，而非形式化证明则经常反复告诉读者目前证明进行的状态。

‍

‍

### 更多练习

```coq
(** **** 练习：3 星, standard, optional (more_exercises) 

    找一张纸。对于以下定理，首先请 _'思考'_ 
    (a) 它能否能只用化简和改写来证明，
    (b) 它还需要分类讨论（[destruct]），以及 
    (c) 它还需要归纳证明。
    先写下你的预判，然后填写下面的证明（你的纸不用交上来，这只是鼓励你先思考再行动！） *)

...

Theorem zero_nbeq_S : forall n:nat,
  0 =? (S n) = false.
Proof.
  (* 请在此处解答 *)
  (* 只用化简和改写来证明 *)
  simpl. (* TODO: 这里 出现了奇怪的蕴含式 nat -> false = false 是否意味这什么？ *)
  intros H.
  reflexivity.
Qed. 

...

Theorem S_nbeq_0 : forall n:nat,
  (S n) =? 0 = false.
Proof.
  (* 请在此处解答 *)
  (* 只用化简和改写来证明 *)
  (* TODO: 为何不先证明 =? 的交换率？ *)
  simpl. reflexivity. Qed.

...


(* TODO: 可以证明一下排中律, 但不是说直觉主义逻辑不接受排中律？ 
可能是因为 a: bool 而非命题？
*)
Theorem 排中律 : forall a: bool,
    a || (negb a) = true.
Proof.
  intros [].
  - reflexivity.
  - reflexivity.
Qed.

(* 乘法分配率 *)
Theorem mult_plus_distr_r : forall n m p : nat,
  (n + m) * p = (n * p) + (m * p).
(* 乘法结合率 *)
Theorem mult_assoc : forall n m p : nat,
  n * (m * p) = (n * m) * p

(* TODO: 接下来不断用交换律可证明，就是不断代换，能证，不过实在有点麻烦 *)
```

​#TODO#​*这里 出现了奇怪的蕴含式 ​*​*`nat -> false = false`*​*​ 是否意味这什么？其他见上面的代码块。*

**replace** 策略允许你指定一个具体的要改写的子项和你想要将它改写成的项： **replace** **(**t**)** **with** **(**u**)** 会将目标中表达式 **t**（的所有副本）替换为表达式 **u**， 并生成 **t** **=** **u** 作为附加的子目标。在简单的 **rewrite** 作用在目标错误的部分上时 这种做法通常很有用。

​#TODO#​ 余下部分练习

‍

## 使用结构化的数据    (Lists)

* [数值序对](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab65)
* [数值列表](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab68)

  * [用列表实现口袋（Bag）](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab76)
* [有关列表的论证](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab80)

  * [对列表进行归纳](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab81)
  * [Search 搜索](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab83)
  * [列表练习，第一部分](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab84)
  * [列表练习, 第二部分](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab87)
* [Options 可选类型](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab92)
* [偏映射（Partial Maps）](https://coq-zh.github.io/SF-zh/lf-current/Lists.html#lab95)

### 数值序对

此声明可以读作：“构造数值序对的唯一一种方法，就是将构造子 **pair** 应用到两个 **nat** 类型的参数上。”

```coq
Inductive natprod : Type :=
| pair (n1 n2 : nat).

Notation "( x , y )" := (pair x y).
```

*会不会有符号冲突？注意coq的“函数调用”中的变量分割是空格*

我们还需要向 Coq 展示 **p** 的具体结构，这样 **simpl** 才能对 **fst** 和 **snd** 做模式匹配。通过 **destruct** 可以达到这个目的。

```coq
Theorem surjective_pairing : forall (p : natprod),
  p = (fst p, snd p).
Proof.
  intros p.  destruct p as [n m].  simpl.  reflexivity.  Qed.
```

注意：不同于解构自然数产生两个子目标，**destruct** 在此只产生 一个子目标。这是因为 **natprod** 只有一种构造方法。

‍

‍

### 数值列表

​#联想#​*世界线收束！参照 CS61a 与 SICP 中的列表与链表*

通过推广序对的定义，数值*'列表'*类型可以这样描述： “一个列表要么是空的，要么就是由一个数和另一个列表组成的序对。”

```coq
Inductive natlist : Type :=
  | nil
  | cons (n : nat) (l : natlist).
```

例如，这是一个三元素列表：

```coq
Definition mylist := cons 1 (cons 2 (cons 3 nil)).
```

```coq
Notation "x :: l" := (cons x l)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) ..).

Definition mylist1 := 1 :: (2 :: (3 :: nil)).
Definition mylist2 := 1 :: 2 :: 3 :: nil.
Definition mylist3 := [1;2;3].
```

*注意右结合 right associativity*

#### Repeat、Length、Append、Head 与 Tail

```coq
Fixpoint repeat (n count : nat) : natlist :=
  match count with
  | O => nil
  | S count' => n :: (repeat n count')
  end.

Fixpoint length (l:natlist) : nat :=
  match l with
  | nil => O
  | h :: t => S (length t)
  end.
Fixpoint app (l1 l2 : natlist) : natlist :=
  match l1 with
  | nil    => l2
  | h :: t => h :: (app t l2)
  end.

Notation "x ++ y" := (app x y)
                     (right associativity, at level 60).

Definition hd (default:nat) (l:natlist) : nat :=
  match l with
  | nil => default
  | h :: t => h
  end.

Definition tl (l:natlist) : natlist :=
  match l with
  | nil => nil
  | h :: t => t
  end.
```

​#联想#​​​​ `app`​​​​ *（Append）实际定义了合并列表的函数。在这里coq是使用像数学的形式来定义；一般的函数式语言使用递归来定义；偏底层的语言（例如 C ）直接操作内存中的指针来完成整个定义*

> ​`::`​ ~=元素操作 `cons`​
>
> ​`++`​ ~=列表操作 `app`​

‍

#### 用列表实现口袋（Bag）

==**bag**==（或者叫 **multiset** 多重集）类似于集合，只是其中每个元素都能出现不止一次。 口袋的一种可行的表示是列表。

```coq
Fixpoint count (v:nat) (s:bag) : nat :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => O
  | h :: t => if h =? v
              then S (count v t)
              else count v t
  end.
```

对于以下习题，就有函数式编程的味道了，可以复用函数：

```coq
Definition sum : bag -> bag -> bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  app.
(* 对于参考其他人的解法，有：[  fun l1 l2 => app l1 l2. ] 但是是未学到的*)

Definition member (v:nat) (s:bag) : bool :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  if 0 <? (count v s)
  then true
  else false.
```

额外的练习：和 **bag** 有关的函数

```coq
Fixpoint remove_one (v:nat) (s:bag) : bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => nil
  | h :: t => if(v =? h) 
              then t 
              else h :: (remove_one v t) 
  end.

Fixpoint remove_all (v:nat) (s:bag) : bag :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s with
  | nil => nil
  | h :: t => if(v =? h) 
              then remove_all v t
              else h :: (remove_all v t) 
  end.

Fixpoint subset (s1:bag) (s2:bag) : bool :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match s1 with
  | nil => true
  | h :: t => if(member h s2) 
              then subset t (remove_one h s2) 
              else false 
  end.
```

### 有关列表的论证

归纳定义的集合中元素的形式 *'只能是'* 构造子对其它项的应用。

```coq
Theorem app_assoc : forall l1 l2 l3 : natlist,
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3. induction l1 as [| n l1' IHl1'].
  - (* l1 = nil *)
    reflexivity.
  - (* l1 = cons n l1' *)
    simpl. rewrite -> IHl1'. reflexivity.  Qed.
```

#### 反转列表

```coq
Fixpoint rev (l:natlist) : natlist :=
  match l with
  | nil    => nil
  | h :: t => rev t ++ [h]
  end.

Theorem app_length : forall l1 l2 : natlist,
  length (l1 ++ l2) = (length l1) + (length l2).

Theorem rev_length_firsttry : forall l : natlist,
  length (rev l) = length l.
```

#### Search 搜索

我们已经见过很多需要使用之前证明过的结论（例如通过 **rewrite**）来证明的定理了。 但是在引用别的定理时，我们必须事先知道它们的名字。当然，即使是已被证明的定理本身 我们都不能全部记住，更不用提它们的名字了。

Coq 的 ==**Search**== 指令在这时就非常有用了。执行 **Search** **foo** 会让 Coq 显示所有涉及到 **foo** 的定理。例如，去掉下面的注释后， 你会看到一个我们证明过的所有关于 **rev** 的定理的列表：

```coq
Coq < Search rev. 
test_rev2: rev [ ] = [ ]
rev_length: forall l : natlist, length (rev l) = length l
test_rev1: rev [1; 2; 3] = [3; 2; 1]
```

练习

```coq
Theorem app_nil_r : forall l : natlist,
  l ++ [] = l.

Theorem rev_app_distr: forall l1 l2 : natlist,
  rev (l1 ++ l2) = rev l2 ++ rev l1.

Theorem rev_involutive : forall l : natlist,
  rev (rev l) = l.
```

#### 列表练习

​#TODO#​ 仍有部分未完成

‍

### Options 可选类型

假设我们想要写一个返回某个列表中第 **n** 个元素的函数。如果我们为它赋予类型 **nat** **→** **natlist** **→** **nat**，那么当列表太短时我们仍须返回某个数...

*突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 ​*"用函数构造函数"[^2]

一种更好的方式是改变 **nth_bad** 的返回类型，使其包含一个错误值作为可能的结果。 我们将此类型命名为 **natoption**。

```coq
Inductive natoption : Type :=
  | Some (n : nat)
  | None.
```

然后我们可以修改前面 **nth_bad** 的定义，使其在列表太短时返回 **None**， 在列表足够长且 **a** 在 **n** 处时返回 **Some** **a**。我们将这个新函数称为 **nth_error** 来表明它可以产生带错误的结果。

```coq
Fixpoint nth_error (l:natlist) (n:nat) : natoption :=
  match l with
  | nil => None
  | a :: l' => match n with
               | O => Some a
               | S n' => nth_error l' n'
               end
  end.
```

介绍 Coq 编程语言更多细微特性：比如条件表达式...

Coq 的条件语句和其它语言中的一样，不过加上了一点更为一般化的特性。 由于 **bool** 类型不是内建的，因此 Coq 实际上支持在*'任何'*带有两个构造子的， 归纳定义的类型上使用条件表达式。当断言（guard）求值为 **Inductive** 定义中的第一个构造子时，它被认为是真的；当它被求值到第二个构造子时， 则被认为是假的。

以下函数从 **natoption** 中取出一个 **nat**，在遇到 **None** 时它将返回提供的默认值。

```coq
Definition option_elim (d : nat) (o : natoption) : nat :=
  match o with
  | Some n' => n'
  | None => d
  end.
```

‍

### 偏映射（Partial Maps）

最后演示一下如何在 Coq 中定义基础的数据结构。这是一个简单的 *'偏映射'* 数据类型，它类似于大多数编程语言中的映射或字典数据结构。

首先，我们定义一个新的归纳数据类型 **id** 来用作偏映射的“键”。

```coq
Inductive id : Type :=
  | Id (n : nat).
```

本质上来说，**id** 只是一个数。但通过 **Id** 标签封装自然数来引入新的类型， 能让定义变得更加可读，同时也给了我们更多的灵活性。

我们还需要一个 **id** 的相等关系测试：

```coq
Definition eqb_id (x1 x2 : id) :=
  match x1, x2 with
  | Id n1, Id n2 => n1 =? n2
  end.
```

现在我们定义偏映射的类型：

```coq
Inductive partial_map : Type :=
  | empty
  | record (i : id) (v : nat) (m : partial_map).
```

此声明可以读作：“有两种方式可以构造一个 **partial_map**：用构造子 **empty** 表示一个空的偏映射，或将构造子 **record** 应用到一个键、一个值和一个既有的 **partial_map** 来构造一个带“键-值”映射 的 **partial_map**。”

update 函数在部分映射中覆盖给定的键以取缔原值（如该键尚不存在， 则新建其记录）。

```coq
Definition update (d : partial_map)(x : id) (value : nat)
                  : partial_map :=
  record x value d.
```

最后，**find** 函数按照给定的键搜索一个 **partial_map**。若该键无法找到， 它就返回 **None**；若该键与 **val** 相关联，则返回 **Some** **val**。 若同一个键被映到多个值，**find** 就会返回它遇到的第一个值。

```coq
Fixpoint find (x : id) (d : partial_map) : natoption :=
  match d with
  | empty         => None
  | record y v d' => if eqb_id x y
                     then Some v
                     else find x d'
  end.
```

*实质上像多元列表，其中一个元不能重复*​

‍

​#TODO#​ 一个练习，答案是无穷？

```coq
Inductive baz : Type :=
  | Baz1 (x : baz)
  | Baz2 (y : baz) (b : bool).

(** 有_'多少'_个表达式具备类型 [baz]？（以注释说明。） *)
(* TODO: 无穷个？ *)
```

‍

## 多态与高阶函数    (Poly)

* [多态](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab100)

  * [多态列表](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab101)
  * [多态序对](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab110)
  * [多态候选](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab113)
* [函数作为数据](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab115)

  * [高阶函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab116)
  * [过滤器](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab117)
  * [匿名函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab118)
  * [映射](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab121)
  * [折叠](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab126)
  * [用函数构造函数](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab128)
* [附加练习](https://coq-zh.github.io/SF-zh/lf-current/Poly.html#lab129)

‍

‍

在本章中，我们会继续发展函数式编程的基本概念，其中最关键的新概念就是 *'多态'*（在所处理的数据类型上抽象出函数）和*'高阶函数'*（函数作为数据）。

### 多态

*嗯...一种抽象手段*

#### 多态列表

为避免这些重复，Coq 支持定义*'多态'*归纳类型。 例如，以下就是*'多态列表'*数据类型。

```coq
Inductive list (X:Type) : Type :=
  | nil
  | cons (x : X) (l : list X).
```

这和上一章中 **natlist** 的定义基本一样，只是将 **cons** 构造子的 **nat** 参数换成了任意的类型 **X**，函数头的第一行添加了 **X** 的绑定， 而构造子类型中的 **natlist** 则换成了 **list** **X**。（我们可以重用构造子名 **nil** 和 **cons**，因为之前定义的 **natlist** 在当前作用之外的一个 **Module** 中。）

list 本身又是什么类型？一种不错的思路就是把 **list** 当做从 **Type** 类型到 **Inductive** 归纳定义的​*'函数'*​；或者换种更简明的思路，即 **list** 是个从 **Type** 类型到 **Type** 类型的函数。对于任何特定的类型 **X**， 类型 **list** **X** 是一个 **Inductive** 归纳定义的，元素类型为 **X** 的列表的集合。

`Check list : Type -> Type.`

**list** 的定义中的参数 **X** 自动 成为构造子 **nil** 和 **cons** 的参数 —— 也就是说，**nil** 和 **cons** 在这里是多态 的构造子；现在我们调用它们的时候必须要提供一个参数，就是它们要构造的列表的具 体类型。例如，**nil** **nat** 构造的是 **nat** 类型的空列表。

```coq
Check (nil nat) : list nat.
Check (cons nat 3 (nil nat)) : list nat.
```

**nil** 的类型会是什么呢？也许我们可以（根据定义）说它是 **list** **X**， 不过这样它就不是接受 **X** 返回 **list** 的函数了。再提出一种：**Type** **→** **list** **X** 并没有解释 **X** 是什么，**(**X **:** **Type**) **→** **list** **X** 则比较接近。 Coq 对这种情况的记法为 **∀** **X** **:** **Type**, **list** **X**：

```coq
Check nil : forall X : Type, list X.
Check cons : forall X : Type, X -> list X -> list X.
```

如果在每次使用列表构造子时，都要为它提供类型参数，那样会很麻烦。 不过我们很快就会看到如何省去这种麻烦。

现在我们可以回过头来定义之前写下的列表处理函数的多态版本了。 例如 **repeat**：

```coq
Fixpoint repeat (X : Type) (x : X) (count : nat) : list X :=
  match count with
  | 0 => nil X
  | S count' => cons X x (repeat X x count')
  end.
```

##### 类型标注的推断

Coq 可以使用*'类型推断'* 基于它们的使用方式来推出 **X**、**x** 和 **count** 一定是什么类型。例如， 由于 **X** 是作为 **cons** 的参数使用的，因此它必定是个 **Type** 类型， 因为 **cons** 期望一个 **Type** 作为其第一个参数，而用 **0** 和 **S** 来匹配 **count** 意味着它必须是个 **nat**，诸如此类。

```coq
Fixpoint repeat' X x count : list X :=
  match count with
  | 0        => nil X
  | S count' => cons X x (repeat' X x count')
  end.

Check repeat'
  : forall X : Type, X -> nat -> list X.
```

##### 类型参数的推断

在任何我们可以写类型参数的地方，我们都可 以将类型参数写为 “洞” ==**_**==，可以看做是说 “请 Coq 自行找出这里应该填什么。” 更确切地说，当 Coq 遇到 **_** 时，它会尝试*'统一'*所有的局部变量信息， 包括函数应当应用到的类型，其它参数的类型，以及应用函数的上下文中期望的类型， 以此来确定 **_** 处应当填入的具体类型。

```coq
repeat' (X : _) (x : _) (count : _) : list X

Fixpoint repeat'' X x count : list X :=
  match count with
  | 0        => nil _
  | S count' => cons _ x (repeat'' _ x count')
  end.

Definition list123 :=
  cons nat 1 (cons nat 2 (cons nat 3 (nil nat))).
(** ……我们可以用洞来这样写： *)
Definition list123' :=
  cons _ 1 (cons _ 2 (cons _ 3 (nil _))).
```

‍

##### 隐式参数

我们甚至可以通过告诉 Coq *'总是'*推断给定函数的类型参数来在大多数情况下 直接避免写 **_**。

==Arguments== 用于指令指定函数或构造子的名字并列出其参数名， 花括号中的任何参数都会被视作隐式参数。（如果定义中的某个参数没有名字， 那么它可以用通配模式 **_** 来标记。这种情况常见于构造子中。）

```coq
Arguments nil {X}.
Arguments cons {X} _ _.
Arguments repeat {X} x count.
```

现在我们完全不用提供类型参数了：

```coq
Definition list123'' := cons 1 (cons 2 (cons 3 nil)).
```

此外，我们还可以在定义函数时就声明隐式参数，只需要将某个参数两边的圆括号换成花括号。例如：

```coq
Fixpoint repeat''' {X : Type} (x : X) (count : nat) : list X :=
  match count with
  | 0        => nil
  | S count' => cons x (repeat''' x count')
  end.
```

（注意我们现在甚至不必在 **repeat'''** 的递归调用中提供类型参数了， 实际上提供了反而是无效的，因为 Coq 并不想要它。）

我们会尽可能使用最后一种风格，不过还会继续在 **Inductive** 构造子中使用显式的 **Argument** 声明。原因在于如果将归纳类型的形参标为隐式的话， 不仅构造子的类型会变成隐式的，类型本身也会变成隐式的。例如， 考虑以下 **list** 类型的另一种定义：

```coq
Inductive list' {X:Type} : Type :=
  | nil'
  | cons' (x : X) (l : list').
```

<u>由于 ​</u>​<u>**X**</u>​<u>​ 在包括 ​</u>​<u>**list'**</u>​<u>​ 本身的</u>​<u>*'整个'*</u>​<u>归纳定义中都是隐式声明的， 因此当我们讨论数值、布尔值或其它任何类型的列表时，都只能写 ​</u>​<u>**list'**</u>​<u>， 而写不了 ​</u>​<u>**list'**</u>​<u>​ ​</u>​<u>**nat**</u>​<u>、</u>​<u>**list'**</u>​<u>​ ​</u>​<u>**bool**</u>​<u>​ 等等，这样就有点过分了。</u>

作为本节的收尾，我们为新的多态列表重新实现几个其它的标准列表函数...

```coq
Fixpoint app {X : Type} (l1 l2 : list X)
             : (list X) :=
  match l1 with
  | nil      => l2
  | cons h t => cons h (app t l2)
  end.

Fixpoint rev {X:Type} (l:list X) : list X :=
  match l with
  | nil      => nil
  | cons h t => app (rev t) (cons h nil)
  end.

Fixpoint length {X : Type} (l : list X) : nat :=
  match l with
  | nil => 0
  | cons _ l' => S (length l')
  end.
```

‍

‍

##### 显式提供类型参数

用 **Implicit** （隐式）将参数声明为隐式的会有个小问题：Coq 偶尔会没有足够的局部信息来确定类型参数。此时，我们需要告诉 Coq 这次我们会显示地给出参数。例如，假设我们写了如下定义：

```coq
Fail Definition mynil := nil.
(* The command has indeed failed with message:
The following term contains unresolved implicit arguments:
  nil
More precisely: 
- ?X: Cannot infer the implicit parameter X of nil whose type is "Type". *)
```

（**Definition** 前面的 **Fail** 限定符可用于*'任何'*指令， 它的作用是确保该指令在执行时确实会失败。如果该指令失败了，Coq 就会打印出相应的错误信息，不过之后会继续处理文件中剩下的部分。）

在这里，Coq 给出了一条错误信息，因为它不知道应该为 **nil** 提供何种类型。 我们可以为它提供个显式的类型声明来帮助它，这样 Coq 在“应用”**nil** 时就有更多可用的信息了：

```coq
Definition mynil : list nat := nil.
```

此外，我们还可以在函数名前加上==前缀 ​==​==**@**==​==​ ​==来强制将隐式参数变成显式的：

```coq
Check @nil : forall X : Type, list X.
Definition mynil' := @nil nat.
```

使用参数推断和隐式参数，我们可以为列表定义和前面一样的简便记法。 由于我们让构造子的的类型参数变成了隐式的，因此 Coq 就知道在我们使用该记法时自动推断它们了。

```coq
Notation "x :: y" := (cons x y)
                     (at level 60, right associativity).
Notation "[ ]" := nil.
Notation "[ x ; .. ; y ]" := (cons x .. (cons y []) ..).
Notation "x ++ y" := (app x y)
                     (at level 60, right associativity).

(** 现在列表就能写成我们希望的方式了： *)

Definition list123''' := [1; 2; 3].
```

‍

#### 多态序对

按照相同的模式，我们在上一章中给出的数值序对的定义可被推广为 *'*​==*多态序对（Polymorphic Pairs）*==​*'*，它通常叫做==*'积（Products）*==​*'*：

```coq
Inductive prod (X Y : Type) : Type :=
| pair (x : X) (y : Y).

Arguments pair {X} {Y} _ _.
```

和列表一样，我们也可以将类型参数定义成隐式的， 并以此定义类似的具体记法：

```coq
Notation "( x , y )" := (pair x y).
```

我们也可以使用 **Notation** 来定义标准的*'积类型（Product Types）'*记法：

```coq
Notation "X * Y" := (prod X Y) : type_scope.
```

（标注 **:** ==**type_scope**== 会告诉 Coq 该缩写只能在解析类型而非表达式时使用。 这避免了与乘法符号的冲突。)

一开始会很容易混淆 **(**x**,**y**)** 和 **X**×**Y**。不过要记住 **(**x**,**y**)** 是一个​*'值'*​，它由两个其它的值构造得来；而 **X**×**Y** 是一个​*'类型'*​， 它由两个其它的类型构造得来。如果 **x** 的类型为 **X** 而 **y** 的类型为 **Y**， 那么 **(**x**,**y**)** 的类型就是 **X**×**Y**。

<u>第一元（first）和第二元（second）的射影函数（Projection Functions）</u>现在看起来和其它函数式编程语言中的很像了：

```coq
Definition fst {X Y : Type} (p : X * Y) : X :=
  match p with
  | (x, y) => x
  end.

Definition snd {X Y : Type} (p : X * Y) : Y :=
  match p with
  | (x, y) => y
  end.
```

​#ChatGPT#​ 射影函数是一种数学概念，它指的是将一个点或一个向量从一个空间映射到另一个空间的函数。射影函数可以帮助人们在不同的空间之间建立联系，从而使得某些概念变得更加容易理解和推广。例如，在几何学中，人们可以使用射影函数来投影一个三维平面上的图形到二维平面上，从而使得图形的某些特征变得更加易于理解。

以下函数接受两个列表，并将它们结合成一个序对的列表。 在其它函数式语言中，它通常被称作 **zip**。我们为了与 Coq 的标准库保持一致， 将它命名为 **combine**。

```coq
Fixpoint combine {X Y : Type} (lx : list X) (ly : list Y)
           : list (X*Y) :=
  match lx, ly with
  | [], _ => []
  | _, [] => []
  | x :: tx, y :: ty => (x, y) :: (combine tx ty)
  end.
```

函数 **split** 是 **combine** 的右逆（right inverse）： 它接受一个序对的列表并返回一个列表的序对。 在很多函数式语言中，它被称作 **unzip**。

```coq
Definition append_list_pair {X Y : Type} 
                            (lp1 : (list X) * (list Y)) 
                            (lp2 : (list X) * (list Y)) : (list X) * (list Y) :=
((fst lp1) ++ (fst lp2), (snd lp1) ++ (snd lp2)).

Fixpoint split {X Y : Type} (l : list (X*Y))
               : (list X) * (list Y) :=
  (* 将本行替换成 ":= _你的_定义_ ." *)
  match l with
  | [] => ([], [])
  | (h1, h2) :: tail => append_list_pair ([h1], [h2]) (split tail)
  end.
```

‍

‍

#### 多态候选

最后一种要介绍的多态类型是*'多态候选（Polymorphic Options）'*, 它推广了上一章中的 **natoption**（由于我们之后要用标准库中定义的 **option** 版本，因此这里的定义我们把它放在模块中）：

```coq
Module OptionPlayground.

Inductive option (X:Type) : Type :=
  | Some (x : X)
  | None.

Arguments Some {X} _.
Arguments None {X}.
```

现在我们可以重写 **nth_error** 函数来让它适用于任何类型的列表了。

```coq
Fixpoint nth_error {X : Type} (l : list X) (n : nat)
                   : option X :=
  match l with
  | [] => None
  | a :: l' => if n =? O then Some a else nth_error l' (pred n)
  end.
```

‍

‍

### 函数作为数据

和大部分现代编程语言一样，特别是“函数式”的语言，包括 OCaml、Haskell、 Racket、Scala、Clojure 等，Coq 也将函数视作“一等公民（First-Class Citizens）”， 即允许将它们作为参数传入其它函数、作为结果返回、以及存储在数据结构中等等。

‍

#### 高阶函数

用于操作其它函数的函数通常叫做*'高阶函数'*。以下是简单的示例：

```coq
Definition doit3times {X:Type} (f:X->X) (n:X) : X :=
  f (f (f n)).
```

注意到下面括号的使用 "突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 用..."[^3]

```coq
Check @doit3times : forall X : Type, (X -> X) -> X -> X.
```

‍

#### 过滤器

下面是个更有用的高阶函数，它接受一个元素类型为 **X** 的列表和一个 **X** 的==谓词==（即一个从 **X** 到 **bool** 的函数），然后“过滤”此列表并返回一个新列表， 其中仅包含对该谓词返回 **true** 的元素。

> 类如 python 中的`filter`​

```coq
Fixpoint filter {X:Type} (test: X->bool) (l:list X)
                : (list X) :=
  match l with
  | []     => []
  | h :: t => if test h then h :: (filter test t)
                        else       filter test t
  end.
```

‍

#### 匿名函数

```coq
Example test_anon_fun':
  doit3times (fun n => n * n) 2 = 256.
Proof. reflexivity. Qed.
```

表达式 **(**​==fun== **n** **⇒** **n** **×** **n**) 可读作“一个给定 **n** 并返回 **n** **×** **n** 的函数。”

‍

#### 映射

另一个方便的高阶函数叫做 **map**。

```coq
Fixpoint map {X Y: Type} (f:X->Y) (l:list X) : (list Y) :=
  match l with
  | []     => []
  | h :: t => (f h) :: (map f t)
  end.
```

‍

#### 折叠

一个更加强大的高阶函数叫做 **fold**。<u>本函数启发自“</u>​<u>**reduce**</u>​<u>​ 归约” 操作，它是 Google 的 map/reduce 分布式编程框架的核心。</u>

> 参考：[https://cloud.tencent.com/developer/article/1703116](https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html)
>
> https://cloud.tencent.com/developer/article/1703116

```coq
Fixpoint fold {X Y: Type} (f: X->Y->Y) (l: list X) (b: Y)
                         : Y :=
  match l with
  | nil => b
  | h :: t => f h (fold f t b)
  end.
```

```coq
Check (fold andb) : list bool -> bool -> bool.
Compute (fold andb) [true; true] false.
(* fold andb : list bool -> bool -> bool
	 : list bool -> bool -> bool
	 = false
     : bool
  这也说明了之前我猜测的柯里化是默认的 *)
```

‍

#### 用函数构造函数

```coq
Definition constfun {X: Type} (x: X) : nat->X :=
  fun (k:nat) => x.

Definition ftrue := constfun true.

Example constfun_example1 : ftrue 0 = true.
Proof. reflexivity. Qed.

Example constfun_example2 : (constfun 5) 99 = 5.
Proof. reflexivity. Qed.
```

实际上，我们已经见过的多参函数也是讲函数作为数据传入的例子。

```coq
Check plus : nat -> nat -> nat.
```

该表达式中的每个 **→** 实际上都是一个类型上的*'二元'*操作符。 该操作符是*'右结合'*的，因此 <u>**plus**</u>​<u>​ 的类型其实是 ​</u>​<u>**nat**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**(**</u>​<u>nat ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**nat**</u>​<u>) 的简写</u>，即，它可以读作“**plus** 是一个单参数函数，它接受一个 **nat** 并返回另一个函数，该函数接受另一个 **nat** 并返回一个 **nat**”。 在上面的例子中，我们总是将 **plus** 一次同时应用到两个参数上。 不过如果我们喜欢，也可以一次只提供一个参数，这叫做*'偏应用（Partial Application）'*。

### 更多练习

​`flod`​ 实现 `length`​ 和 `map`​

```coq
Definition fold_length {X : Type} (l : list X) : nat :=
  fold (fun _ n => S n) l 0.

Definition fold_map {X Y: Type} (f: X -> Y) (l: list X) : list Y
  (* 将本行替换成 ":= _你的_定义_ ." *) :=
  fold (fun x list_elem_y => f x :: list_elem_y) l [].
```

​

在 Coq 中，函数 **f** **:** **A** **→** **B** **→** **C** 的类型其实是 **A** **→** **(**B **→** **C**)。 也就是说，如果给 **f** 一个类型为 **A** 的值，它就会给你函数 **f'** **:** **B** **→** **C**。 如果再给 **f'** 一个类型为 **B** 的值，它就会返回一个类型为 **C** 的值。 这为我们提供了 **plus3** 中的那种偏应用能力。 用返回函数的函数处理参数列表的方式被称为​*'*​==*柯里化（Currying）*==​*'*​， 它是为了纪念逻辑学家 Haskell Curry。

反之，我们也可以将 **A** **→** **B** **→** **C** 解释为 **(**A **×** **B**) **→** **C**。这叫做 ​*'*​==*反柯里化（Uncurrying）*==​*'*​。对于反柯里化的二元函数， 两个参数必须作为序对一次给出，此时它不会偏应用。

我们可以将柯里化定义如下：

```coq
Definition prod_curry {X Y Z : Type}
  (f : X * Y -> Z) (x : X) (y : Y) : Z := f (x, y).
(** 定义它的反函数 [prod_uncurry] *)
Definition prod_uncurry {X Y Z : Type}
  (f : X -> Y -> Z) (p : X * Y) : Z :=
  f (fst p) (snd p).

Check @prod_curry : forall X Y Z : Type, (X * Y -> Z) -> X -> Y -> Z.
Check @prod_uncurry : forall X Y Z : Type, (X -> Y -> Z) -> X * Y -> Z.
```

​#联想#​ *这样看来“序对”就相当于一般编程语言的函数参数输入输出的数据结构*

‍

‍

本练习使用*'邱奇数（Church numerals）'*探讨了另一种定义自然数的方式， 它以数学家 Alonzo Church 命名。我们可以将自然数 **n** 表示为一个函数， 它接受一个函数 **f** 作为参数并返回迭代了 **n** 次的 **f**。

​#TODO#​

‍

## 更多基本策略    (Tactics)

* [apply 策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab138)
* [apply ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)​**[with](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)**​[ 策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab142)
* [The ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)​**[injection](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)**​[ and ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)​**[discriminate](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)**​[ Tactics](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab144)
* [对假设使用策略](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab147)
* [变换归纳假设](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab148)
* [展开定义](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab153)
* [对复合表达式使用 ](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab154)​**[destruct](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab154)**
* [复习](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab157)
* [附加练习](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html#lab158)

本章额外介绍了一些证明策略和手段， 它们能用来证明更多关于函数式程序的有趣性质。

我们会看到：如何在“**向前证明**”和“**向后证明**”两种风格中使用辅助引理；

* 如何对数据构造子进行论证，特别是，如何利用它们<u>单射且不交的事实</u>；
* 如何增强归纳假设，以及何时需要增强；
* 还有通过分类讨论进行论证的更多细节。

### apply 策略

我们经常会遇到待证目标与上下文中的前提或已证引理*'刚好相同'*的情况。

我们可以像之前那样用“**rewrite** **→** **eq**​~2~. **reflexivity**.”来完成。 不过如果我们使用 **apply** 策略，只需一步就能完成

**apply** 策略也可以配合*'条件（Conditional）'*假设和引理来使用： 如果被应用的语句是一个蕴含式，那么该<u>蕴含式的前提</u>就会被添加到待证子目标列表中。

```coq
Theorem silly2 : forall (n m o p : nat),
    n = m ->
    (n = m -> [n;o] = [m;p]) ->
    [n;o] = [m;p].
Proof.
  intros n m o p eq1 eq2.
  apply eq2. apply eq1.  Qed.
```

​#TODO#​ 有待加深理解

通常，当我们使用 **apply** **H** 时，语句 **H** 会以一个引入了某些 *'通用变量（Universal Variables）'* 的 **∀** 开始。在 Coq 针对 **H** 的结论匹配当前目标时，它会尝试为这些变量查找适当的值。例如， 当我们在以下证明中执行 **apply** **eq**​~2~ 时，**eq**​~2~ 中的通用变量 **q** 会以 **n** 实例化，而 **r** 会以 **m** 实例化。

‍

### apply **with** 策略

...我们必须在 **apply** 的调用后面加上 "**with** **(**m**:=[**c**,**d**])**" 来显式地提供一个实例。

```coq
  apply trans_eq with (m:=[c;d]).
```

（实际上，我们通常不必在 **with** 从句中包含名字 **m**，Coq 一般足够聪明来确定我们实例化的变量。我们也可以写成： **apply** **trans_eq** **with** **[**c**;**d**]**。）

```coq
Example trans_eq_exercise : forall (n m o p : nat),
     m = (minustwo o) ->
     (n + p) = m ->
     (n + p) = (minustwo o).
Proof.
  (* 请在此处解答 *)
  intros n m o p eq1 eq2.
  apply trans_eq with (m).
  apply eq2. apply eq1. Qed.
```

‍

### **injection** 和 **discriminate** 策略

回想自然数的定义：

```coq
 Inductive nat : Type :=
   | O
   | S (n : nat).
```

我们可从该定义中观察到，所有的数都是两种形式之一：要么是构造子 **O**， 要么就是将构造子 **S** 应用到另一个数上。不过这里还有无法直接看到的： 自然数的定义中还蕴含了两个事实：

* 构造子 **S** 是*'*​==*单射（Injective）*==​*'*或*'一一对应'*的。 即，如果 **S** **n** **=** **S** **m**，那么 **n** **=** **m** 必定成立。
* 构造子 **O** 和 **S** 是*'*​==*不相交（Disjoint）*==​*'*的。 即，对于任何 **n**，**O** 都不等于 **S** **n**。

类似的原理同样适用于所有归纳定义的类型：所有构造子都是单射的， 而不同构造子构造出的值绝不可能相等。对于列表来说，**cons** 构造子是单射的， 而 **nil** 不同于任何非空列表。对于布尔值来说，**true** 和 **false** 是不同的。 因为 **true** 和 **false** 二者都不接受任何参数，它们既不在这边也不在那边。 其它归纳类型亦是如此。

例如，我们可以使用定义在 **Basics.v** 中的 **pred** 函数来证明 **S** 的单射性。 .

```coq
Theorem S_injective : forall (n m : nat),
  S n = S m ->
  n = m.
Proof.
  intros n m H1.
  assert (H2: n = pred (S n)). { reflexivity. }
  rewrite H2. rewrite H1. reflexivity.
Qed.
```

这个技巧可以通过编写等价的 **pred** 来推广到任意的构造子上 —— 即编写一个“撤销”一次构造子调用的函数。为此，Coq 提供了更加简便的 **injection** 策略，它能让我们利用任意构造子的单射性。 下面是使用 **injection** 对上面定理的另一种证法：

```coq
Theorem S_injective' : forall (n m : nat),
  S n = S m ->
  n = m.
Proof.
  intros n m H.

(** 通过在此处编写 [injection H as Hmn]，我们让 Coq
    利用构造子的单射性来产生所有它能从 [H] 所推出的等式（本例中为等式 [n = m]）。
    每一个这样的等式都作为假设（本例中为 [Hmn]）被添加到上下文中。
*)

  injection H as Hnm. apply Hnm.
Qed.
```

以下例子展示了一个 **injection** 如何直接得出多个等式。

```coq
Theorem injection_ex1 : forall (n m o : nat),
  [n; m] = [o; o] ->
  [n] = [m].
Proof.
  intros n m o H.
  (* m = o -> n = o -> [n] = [m] *)
  injection H as H1 H2.
  rewrite H1. rewrite H2. reflexivity.
Qed.
```

‍

这就是构造器的 injectivity（注射性？）。那 disjointness （不交性？）呢？

不交性的原则认为两个以不同构造器开头的项（比如 [O] 和 [S]，或 [true] 和 [false]）永远不会相等。这意味着，在某个上下文中，如果我们假设这两个项相等，我们就有理由得出任何我们想要的结论，因为这个假设是毫无意义的。

**discriminate** 策略体现了这个原则：它用于处理涉及不同构造器的等式的假设（例如 [S n = O]），它立即解决当前目标。这里有一个例子：

```coq
Theorem eqb_0_l : forall n,
   0 =? n = true -> n = 0.
Proof.
  intros n.

(** 我们可以通过对 [n] 进行分类讨论来继续。第一种分类是平凡的。 *)

  destruct n as [| n'] eqn:E.
  - (* n = 0 *)
    intros H. reflexivity.

(** However, the second one doesn't look so simple: 
    然而，第二个看起来并不那么简单：
    assuming [0 =? (S n') = true], we must show [S n' = 0]!  
    The way forward is to observe that the assumption itself 
    is nonsensical: 
    前进的方法是观察这个假设本身是毫无意义的： *)

  - (* n = S n' *)
    simpl.

(**
    如果我们对这个假设使用 [discriminate] ，
    Coq 便会确认我们当前正在证明的目标不可行，并同时移除它，不再考虑。 *)

    intros H. discriminate H.
Qed.

```

*这种情况之前也出现过，不过是用 rewrite 来奇怪地解决了的*​

本例是逻辑学原理==*'爆炸原理'*==的一个实例，它断言矛盾的前提会推出任何东西， 甚至是假命题！

```coq
Theorem discriminate_ex1 : forall (n : nat),
  S n = O ->
  2 + 2 = 5.
Proof.
  intros n contra. discriminate contra. Qed.
```

> *这也与蕴含式的定义相同：*
>
> |p<br />|q|p->q|
> | :----| :--| :-----|
> |1|0|0|
> |0|1|1|
> |1|1|1|
> |0|0|1|
>
> [爆炸原理](https://zh.wikipedia.org/zh-cn/%E7%88%86%E7%82%B8%E5%8E%9F%E7%90%86)​
>
> ​**爆炸原理**​（principle of explosion, "from falsehood, anything (follows)"），是[经典逻辑](https://zh.wikipedia.org/wiki/%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91 "经典逻辑")中陈述从[矛盾](https://zh.wikipedia.org/wiki/%E7%9F%9B%E7%9B%BE "矛盾")中可以得出任何事物的规则。用更加形式化的术语，从形如 *P* ∧ ¬*P* 的[命题](https://zh.wikipedia.org/wiki/%E5%91%BD%E9%A2%98 "命题")可以推导出任何任意的 *Q* (ex contradictione quodlibet (ECQ))​[[1]](https://zh.wikipedia.org/zh-cn/%E7%88%86%E7%82%B8%E5%8E%9F%E7%90%86#cite_note-1)^^​。 “爆炸”指称接受一个单一的矛盾到一个系统中会导致整体定理的“爆炸”。
>
> $$
> \displaystyle (P\land \lnot P)\rightarrow Q
> $$
>
> ​#TODO#​ 除了矛盾平常的一目了然的不真实性之外，这是对在形式系统中不允许 *P* ∧ ¬*P* 为真的主要逻辑论证: 在其中任何任意的[公式](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%8F "公式")都是[定理](https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%90%86 "定理")的系统是[琐碎的](https://zh.wikipedia.org/wiki/%E7%91%A3%E7%A2%8E%E8%AB%96 "琐碎论")。所以爆炸原理证明了[无矛盾律](https://zh.wikipedia.org/wiki/%E6%97%A0%E7%9F%9B%E7%9B%BE%E5%BE%8B "无矛盾律")的正当性。

爆炸原理可能令你费解，那么请记住上述证明*'并不'*肯定其后件， 而是说明：*'如果'*荒谬的前件成立，*'那么'*就会得出荒谬的结论， 如此一来我们将生活在一个不一致的宇宙中，这里每个陈述都是正确的。<u>​ 下一章将进一步讨论爆炸原理</u>。

**构造子的单射性**能让我们论证 **∀** **(**n **m** **:** **nat**), **S** **n** **=** **S** **m** **→** **n** **=** **m**。 此蕴含式的逆形式是一个构造子和函数的更一般的实例， 在后面我们会发现它用起来很方便：

```coq
Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),
  x = y -> f x = f y.
Proof. intros A B f x y eq. rewrite eq.  reflexivity.  Qed.

Theorem eq_implies_succ_equal : forall (n m : nat),
    n = m -> S n = S m.
Proof. intros n m H. apply f_equal. apply H. Qed.
```

还有一个名为 `f_equal`​ 的策略，可以证明这样的定理。给定形如 [f a1 ... an = g b1 ... bn] 的目标，[f_equal] 策略会产生形如 [f = g]、[a1 = b1]、...、[an = bn] 的子目标。同时，[f_equal] 会自动解决任何足够简单（例如可以立即通过 [reflexivity] 证明）的子目标。

```coq
Theorem eq_implies_succ_equal' : forall (n m : nat),
    n = m -> S n = S m.
Proof. intros n m H. f_equal. apply H. Qed.
```

​#TODO#​ *但  f_equal 不是自己定义的 Theorem 吗，为什么可以直接用作策略？*

‍

### 对假设使用策略 apply in

默认情况下，大部分策略会作用于目标公式并保持上下文不变。然而， 大部分策略还有对应的变体来对上下文中的语句执行类似的操作。

‍

类似地，**apply** **L** **in** **H** 会针对上下文中的假设 **H** 匹配某些 （形如 **X** **→** **Y** 中的）条件语句 **L**。然而，与一般的 **apply** 不同 （它将匹配 **Y** 的目标改写为子目标 **X**），**apply** **L** **in** **H** 会针对 **X** 匹配 **H**，如果成功，就将其替换为 **Y**。

换言之，**apply** **L** **in** **H** 给了我们一种“==正向推理==”的方式：根据 **X** **→** **Y** 和一个匹配 **X** 的假设，它会产生一个匹配 **Y** 的假设。作为对比，**apply** **L** 是一种“==反向推理==”：它表示如果我们知道 **X** **→** **Y** 并且试图证明 **Y**， 那么证明 **X** 就足够了。

**正向推理**从*'给定'*的东西开始（即前提、已证明的定理）， 根据它们迭代地刻画结论直到抵达目标。**反向推理**从*'目标'*开始， 迭代地推理蕴含目标的东西，直到抵达前提或已证明的定理。

你在数学或计算机科学课上见过的非形式化证明可能倾向于正向推理。 <u>通常，Coq 习惯上倾向于使用反向推理</u>，但在某些情况下，正向推理更易于思考。

​#TODO#​ 此节有待加深理解

‍

### 变换归纳假设 generalize dependent

在 Coq 中进行归纳证明时，有时控制归纳假设的确切形式是十分重要的。 特别是，在调用 **induction** 策略前，我们有时需要用 **intros** 将假设从目标移到上下文中时要十分小心。例如，假设我们要证明 **double** 函数是单射的 -- 即，它将不同的参数映射到不同的结果：  
       **Theorem** **double_injective**: **∀** **n** **m**,  
         **double** **n** **=** **double** **m** **→** **n** **=** **m**.

此证明的开始方式有点微妙：如果我们以  
       **intros** **n**. **induction** **n**.

开始，那么一切都好（#TODO#​ 为什么？）。然而假如以  
       **intros** **n** **m**. **induction** **n**.

开始，就会卡在归纳情况中...

此时，归纳假设 **IHn'** *'不会'*给出 **n'** **=** **m'** -- 会有个额外的 **S** 阻碍 -- 因此该目标无法证明。

```coq
Theorem double_injective_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction n as [| n' IHn'].
  - (* n = O *) simpl. intros eq. destruct m as [| m'] eqn:E.
    + (* m = O *) reflexivity.
    + (* m = S m' *) discriminate eq.
  - (* n = S n' *) intros eq. destruct m as [| m'] eqn:E.
    + (* m = O *) discriminate eq.
    + (* m = S m' *) apply f_equal.

(** 此时，归纳假设 [IHn'] _'不会'_给出 [n' = m'] -- 会有个额外的 [S] 阻碍 --
    因此该目标无法证明。 *)

Abort.
```

要理解为什么它很奇怪，我们来考虑一个具体的（任意但确定的）**m** -- 比如说 **5**。该语句就会这样说：如果我们知道

* **Q** = “若 **double** **n** **=** **10** 则 **n** **=** **5**”

那么我们就能证明

* **R** = “若 **double** **(**S **n**) **=** **10** 则 **S** **n** **=** **5**”。

但是知道 **Q** 对于证明 **R** 来说并没有任何帮助！（如果我们试着根据 **Q** 证明 **R**，就会以“假设 **double** **(**S **n**) **=** **10**..”这样的句子开始， 不过之后我们就会卡住：知道 **double** **(**S **n**) 为 **10** 并不能告诉我们 **double** **n** 是否为 **10**。（实际上，它强烈地表示 **double** **n** *'不是'* **10**！） 因此 **Q** 是没有用的。）

​#TODO#​ 有待学习

在 **induction** 之前做一些 **intros** 来获得更一般归纳假设并不总是奏效。 有时需要对量化的变量做一下*'重排'*。例如，假设我们想要通过对 **m** 而非 **n** 进行归纳来证明 **double_injective**。

```coq
Theorem double_injective_take2_FAILED : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m. induction m as [| m' IHm'].
  - (* m = O *) simpl. intros eq. destruct n as [| n'] eqn:E.
    + (* n = O *) reflexivity.
    + (* n = S n' *) discriminate eq.
  - (* m = S m' *) intros eq. destruct n as [| n'] eqn:E.
    + (* n = O *) discriminate eq.
    + (* n = S n' *) apply f_equal.
        (* 和前面一样，又卡在这儿了。 *)
Abort.
```

问题在于，要对 **m** 进行归纳，我们首先必须对 **n** 归纳。 （而如果我们不引入任何东西就执行 **induction** **m**，Coq 就会自动为我们引入 **n**！）

我们可以对它做什么？一种可能就是改写该引理的陈述使得 **m** 在 **n** 之前量化。 这样是可行的，不过它不够好：我们不想调整该引理的陈述来适应具体的证明策略！ 我们更想以最清晰自然的方式陈述它。

我们可以先引入所有量化的变量，然后*'重新一般化（re-generalize）'* 其中的一个或几个，选择性地从上下文中挑出几个变量并将它们放回证明目标的开始处。 用 ==**generalize**==​==​ ​==​==**dependent**== （泛化依赖？）策略就能做到。

```coq
Theorem double_injective_take2 : forall n m,
     double n = double m ->
     n = m.
Proof.
  intros n m.
  (* [n] and [m] are both in the context *)
  generalize dependent n.
  (* 现在 [n] 回到了目标中，我们可以对 [m] 进行归纳并得到足够一般的归纳假设了。 *)
  induction m as [| m' IHm'].
  - (* m = O *) simpl. intros n eq. destruct n as [| n'] eqn:E.
    + (* n = O *) reflexivity.
    + (* n = S n' *) discriminate eq.
  - (* m = S m' *) intros n eq. destruct n as [| n'] eqn:E.
    + (* n = O *) discriminate eq.
    + (* n = S n' *) apply f_equal.
      apply IHm'. injection eq as goal. apply goal. Qed.
```

我们来看一下此定理的非形式化证明。注意我们保持 **n** 的量化状态并通过归纳证明的命题，对应于我们形式化证明中依赖的一般化。

​*'定理'*​：对于任何自然数 **n** 和 **m**，若 **double** **n** **=** **double** **m**，则 **n** **=** **m**。

​*'证明'*​：令 **m** 为一个 **nat**。我们通过对 **m** 进行归纳来证明，对于任何 **n**， 若 **double** **n** **=** **double** **m**，则 **n** **=** **m**。

* 首先，设 **m** **=** **0**，而 **n** 是一个数使得 **double** **n** **=** **double** **m**。 我们必须证明 **n** **=** **0**。  
  由于 **m** **=** **0**，根据 **double** 的定义，我们有 **double** **n** **=** **0**。此时对于 **n** 需要考虑两种情况。若 **n** **=** **0**，则得证，因为 **m** **=** **0** **=** **n**，正如所需。 否则，若对于某个 **n'** 有 **n** **=** **S** **n'**，我们就会导出矛盾：根据 **double** 的定义，我们可得出 **double** **n** **=** **S** **(**S **(**double **n'**))，但它与 **double** **n** **=** **0** 相矛盾。
* 其次，设 **m** **=** **S** **m'**，而 **n** 同样是一个数使得 **double** **n** **=** **double** **m**。 我们必须证明 **n** **=** **S** **m'**，根据归纳假设，对于任何数 **s**，若 **double** **s** **=** **double** **m'**，则 **s** **=** **m'**。  
  根据 **m** **=** **S** **m'** 的事实以及 **double** 的定义我们有 **double** **n** **=** **S** **(**S **(**double **m'**))。 此时对于 **n** 需要考虑两种情况。  
  若 **n** **=** **0**，则根据 **double** **n** **=** **0** 的定义会得出矛盾。  
  故存在 **n'** 使得 **n** **=** **S** **n'**。再次根据 **double** 之定义，可得 **S** **(**S **(**double **n'**)) **=** **S** **(**S **(**double **m'**))。再由构造子单射可知 **double** **n'** **=** **double** **m'**。以**n'** 代入归纳假设，推得 **n'** **=** **m'**，故显然 **S** **n'** **=** **S** **m'**， 其中 **S** **n'** **=** **n**，**S** **m'** **=** **m**，所以原命题得证。 ☐

‍

‍

### 展开定义 unfold

有时候我们需要手动展开一个由 Definition 定义引入的名称，以便我们可以操作它所表示的表达式。例如，

```coq
Definition square n := n * n.
Lemma square_mult : forall n m, square (n * m) = square n * square m.
Proof.
  intros n m.
  simpl.
  unfold square.     (* <== *)
  rewrite mult_assoc.
  assert (H : n * m * n = n * n * m).
    { rewrite mult_comm. apply mult_assoc. }
  rewrite H. rewrite mult_assoc. reflexivity.
Qed.
```

为此，我们可以手动用 ==**unfold**== 展开 **square** 的定义。

我们已经观察到，像 **simpl**、**reflexivity** 和 **apply** 这样的策略， 通常总会在需要时自动展开函数的定义。然而，这种自动展开有些保守。一种更直白的方式就是使用 `unfold`​ 明确地告诉 Coq 去展开

‍

### 对复合表达式使用 **destruct**

我们已经见过许多通过 **destruct** 进行情况分析来处理一些变量的值了。 有时我们需要根据某些*'表达式'*的结果的情况来进行推理。我们也可以用 **destruct** 来做这件事。

在前面的证明中展开 **sillyfun** 后，我们发现卡在 **if** **(**n **=?** **3)** **then** **...** **else** **...** 上了。但由于 **n** 要么等于 **3** 要么不等于，因此我们可以用 **destruct** **(**eqb **n** **3)** 来对这两种情况进行推理。*使用 destruct 拆开 if 分支*

通常，**destruct** 策略可用于对任何计算结果进行情况分析。如果 **e** 是某个表达式，其类型为归纳定义的类型 **T**，那么对于 **T** 的每个构造子 **c**，**destruct** **e** 都会生成一个子目标，其中（即目标和上下文中）所有的 **e** 都会被替换成 **c**。

‍

**destruct** 策略的 **eqn**: 部分是可选的。然而在用 **destruct** 结构复合表达式时，<u>**eqn**</u>​<u>: 记录的信息是十分关键的</u>： 如果我们丢弃它，那么 **destruct** 会擦除我们完成证明时所需的信息。 

...

问题在于 destruct 执行的替换非常残酷 - 在这种情况下，它丢弃了每一个 n =? 3 的出现，但我们需要保留一些对这个表达式的记忆，以及它是如何被 destruct 的，因为我们需要能够推理出，由于在案例分析的这个分支中 n =? 3 = true，所以必须有 n = 3，从而得出 n 是奇数。我们在这里想要做的是替换掉所有现有的 n =? 3 的出现，但同时在上下文中添加一个方程式，记录我们所处的情况。这恰恰是 eqn: 限定符所做的。

```coq
Theorem sillyfun1_odd : forall (n : nat),
     sillyfun1 n = true ->
     oddb n = true.
Proof.
  intros n eq. unfold sillyfun1 in eq.
  destruct (n =? 3) eqn:Heqe3.
  (* 现在我们的状态和前面卡住的地方一样了，除了上下文中包含了额外的相等关系假设，
     它就是我们继续推进所需要的。 *)
    - (* e3 = true *) apply eqb_true in Heqe3.
      rewrite -> Heqe3. reflexivity.
    - (* e3 = false *)
     (* 当我们到达正在推理的函数体中第二个相等关系测试时，我们可以再次使用
        [eqn:]，以便结束此证明。 *)
      destruct (n =? 5) eqn:Heqe5.
        + (* e5 = true *)
          apply eqb_true in Heqe5.
          rewrite -> Heqe5. reflexivity.
        + (* e5 = false *) discriminate eq.  Qed.
```

‍

### 复习

现在我们已经见过 Coq 中最基础的策略了。未来的章节中我们还会介绍更多， <u>之后我们会看到一些更加强大的</u>​<u>*'自动化'*</u>​<u>策略，它能让 Coq 帮我们处理底层的细节</u>。 

下面是我们已经见过的：

* **intros**：将前提/变量从证明目标移到上下文中
* **reflexivity**：（当目标形如 **e** **=** **e** 时）结束证明
* **apply**：用前提、引理或构造子证明目标
* **apply**... **in** **H**：将前提、引理或构造子应用到上下文中的假设上（正向推理）
* **apply**... **with**...：为无法被模式匹配确定的变量显式指定值
* **simpl**：化简目标中的计算
* **simpl** **in** **H**：化简前提中的计算
* **rewrite**：使用相等关系假设（或引理）来改写目标
* **rewrite** **...** **in** **H**：使用相等关系假设（或引理）来改写前提
* **symmetry**：将形如 **t**=**u** 的目标改为 **u**=**t**
* **symmetry** **in** **H**：将形如 **t**=**u** 的前提改为 **u**=**t**
* **unfold**：用目标中的右式替换定义的常量
* **unfold**... **in** **H**：用前提中的右式替换定义的常量
* **destruct**... **as**...：对归纳定义类型的值进行情况分析
* **destruct**... **eqn**:...：为添加到上下文中的等式指定名字， 记录情况分析的结果
* **induction**... **as**...: 对归纳定义类型的值进行归纳
* **injection**: reason by injectivity on equalities between values of inductively defined types （#ChatGPT#​​通过在归纳定义类型的值之间的等式上进行注射性推理）
* **discriminate**: reason by disjointness of constructors on equalities between values of inductively defined types （#ChatGPT#​ 通过归纳定义类型的值之间的等式上构造器的不交性进行推理）
* **assert** **(**H**:** **e**)（或 **assert** **(**e**)** **as** **H**）：引入“局部引理”**e** 并称之为 **H**
* **generalize** **dependent** **x**：将变量 **x**（以及任何依赖它的东西） 从上下文中移回目标公式内的前提中

‍

### 附加练习

​#TODO#​ 本章还剩余大量习题未完成

‍

```coq

Definition split_combine_statement : Prop
  (* （“[: Prop]” 表示我们在这里给出了一个逻辑命题。） *)
  (* 将本行替换成 ":= _你的_定义_ ." *). Admitted.

Theorem split_combine : split_combine_statement.
Proof.
(* 请在此处解答 *) Admitted.
```

‍

## Coq 中的逻辑系统    (Logic)

* [逻辑联结词](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab165)

  * [合取](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab166)
  * [析取](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab170)
  * [假命题与否定](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab173)
  * [真值](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab179)
  * [逻辑等价](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab180)
  * [广集与逻辑等价](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab183)
  * [存在量化](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab184)
* [使用命题编程](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab187)
* [对参数应用定理](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab192)
* [Coq vs. 集合论](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab193)

  * [函数的外延性](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab194)
  * [命题 vs. 布尔值](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab196)
  * [经典逻辑 vs. 构造逻辑](https://coq-zh.github.io/SF-zh/lf-current/Logic.html#lab202)

我们已经见过很多对事实的断言（即​*'命题'*​） 以及如何用证据展示其正确性（即​*'证明'*​）的例子了。特别是， 我们证明了大量的<u>*'相等性命题'*</u>​<u>（</u>​<u>**e**</u>​<u>~1~</u>​<u>​ ​</u>​<u>**=**</u>​<u>​ ​</u>​<u>**e**</u>​<u>~2~</u>​<u>）、蕴含式（</u>​<u>**P**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>）和量化命题 （</u>​<u>**∀**</u>​<u>​ ​</u>​<u>**x**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**x**</u>​<u>）</u>。在本章中，我们将会看到如何用 Coq 解决类似形式的逻辑推理。

在深入细节之前，我们先来探讨一下 Coq 中数学表达式的地位。 回忆一下，Coq 是一门拥有*'类型'*的语言，也就是说，一切有意义的 表达式都具有一个相应的类型。逻辑表达也不例外，我们试图在 Coq 中证明的一切语句都有名为 **Prop** 的类型，即*'命题类型'*。

```coq
Check 3 = 3 : Prop.
Check forall n m : nat, n + m = m + n : Prop.
Check 3 = 2 : Prop. (* 简单来说，'是'一个命题与该命题'可以证明'是两回事。*)
Check forall n : nat, n = 2 : Prop.
```

注意：*'所有'*语法形式良好的命题，无论是否为真，其类型均为 **Prop**。

‍

除了拥有类型之外，命题还是*'一等的（First-Class）'*实体， 即在 Coq 的世界中，我们可以像操作其它实体那样操作命题。

到目前为止，我们已经知道命题可以出现在 **Theorem**（还有 **Lemma** 以及 **Example**）的声明中了。

不过命题还可以用在其它地方。例如，我们可以用 **Definition** 为命题取名，就像为其它表达式取名一样。

```coq
Definition plus_claim : Prop := 2 + 2 = 4.
Check plus_claim : Prop.
```

之后我们可以在任何需要此命题的地方使用它们名字——例如，作为一个 **Theorem** 声明中的断言：

```coq
Theorem plus_claim_is_true :
  plus_claim.
Proof. reflexivity.  Qed.
```

我们也可以写出*'参数化'*的命题 -- 也就是一个接受某些类型的参数， 然后返回一个命题的函数。

例如，以下函数接受某个数字，返回一个命题断言该数字等于 3： *也就是返回 Prop 类型的函数*

```coq
Definition is_three (n : nat) : Prop :=
  n = 3.
Check is_three : nat -> Prop.
```

在 Coq 中，返回命题的函数可以说是定义了其参数的*'性质'*。 例如，以下（多态的）性质定义了常见的 *'单射函数'* 的概念。

```coq
Definition injective {A B} (f : A -> B) :=
  forall x y : A, f x = f y -> x = y.

Lemma succ_inj : injective S.
Proof.
  intros n m H. injection H as H1. apply H1.
Qed.
```

相等关系运算符 **=** 也是一个返回 **Prop** 的函数。

表达式 **n** **=** **m** 只是 **eq** **n** **m** 的语法糖（它使用 **Notation** 机制定义在 Coq 标准库中）。由于 **eq** 可被用于任何类型的元素，因此它也是多态的：

```coq
Check @eq : forall A : Type, A -> A -> Prop.
```

（注意我们写的是 **@**eq 而非 **eq**：**eq** 的类型参数 **A** 是隐式声明的，因此我们需要关掉隐式参数的类型推断以便看到 **eq** 的完整类型。）

‍

> 参考eq的标准定义 #TODO#​
>
> ```coq
> Inductive eq (A:Type) (x:A) : A -> Prop :=
>     eq_refl : x = x :>A
>
> where "x = y :> A" := (@eq A x y) : type_scope.
>
> Arguments eq {A} x _.
> Arguments eq_refl {A x} , [A] x.
>
> Arguments eq_ind [A] x P _ y _ : rename.
> Arguments eq_rec [A] x P _ y _ : rename.
> Arguments eq_rect [A] x P _ y _ : rename.
>
> Notation "x = y" := (eq x y) : type_scope.
> Notation "x <> y :> T" := (~ x = y :>T) : type_scope.
> Notation "x <> y" := (~ (x = y)) : type_scope.
> ```

‍

### 逻辑联结词

#### 合取

命题 **A** 与 **B** 的*'*​==*合取*==​*'*（即*'逻辑与'*）写作 **A** **∧** **B**，表示一个 **A** 与 **B** 均为真的断言。

```coq
Example and_example : 3 + 4 = 7 /\ 2 * 2 = 4.
```

证明合取的命题通常使用 **==split==**​==​ 策略==。它会分别为语句的两部分生成两个子目标：

对于任意命题 A 和 B，如果我们假设 A 为真且 B 为真， 那么就能得出 A ∧ B 也为真的结论。

```coq
Lemma and_intro : forall A B : Prop, A -> B -> A /\ B.
Proof.
  intros A B HA HB. split.
  - apply HA.
  - apply HB.
Qed.
```

由于按照前提对某个目标应用定理会产生与该定理的前提一样多的子目标。 因此我们可以应用 **and_intro** 来达到和 **split** 一样的效果。

```coq
Example and_example' : 3 + 4 = 7 /\ 2 * 2 = 4.
Proof.
  apply and_intro.
  - (* 3 + 4 = 7 *) reflexivity.
  - (* 2 + 2 = 4 *) reflexivity.
Qed.
```

‍

```coq
(** **** 练习：2 星, standard (and_exercise)  *)
Example and_exercise :
  forall n m : nat, n + m = 0 -> n = 0 /\ m = 0.
Admitted.

(* TODO 
Proof.
  (* 请在此处解答 *)
  intros n m H. apply and_intro. 
  - induction n.
    + reflexivity.
    + inversion H.
  - induction m.
    + reflexivity.
    + rewrite plus_comm in H. inversion H.
Qed.  
*)
```

以上就是证明合取语句的方法。要反过来使用，即*'使用'*合取前提来帮助证明时， 我们会采用 **destruct** 策略。

如果当前证明上下文中存在形如 **A** **∧** **B** 的前提 **H**，那么 **destruct** **H** **as** **[**HA **HB**] 将会从上下文中移除 **H** 并增加 **HA** 和 **HB** 两个新的前提，前者断言 **A** 为真，而后者断言 **B** 为真。

```coq
Lemma and_example2 :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  (* 课上已完成 *)
  intros n m H.
  destruct H as [Hn Hm] eqn:HE. (* TODO 这个 eqn:HE 是什么意思？ *)
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

和往常一样，我们也可以在引入 **H** 的同时对其进行解构， 而不必先引入然后再解构：

```coq
Lemma and_example2' :
  forall n m : nat, n = 0 /\ m = 0 -> n + m = 0.
Proof.
  intros n m [Hn Hm].
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

*为什么我们要麻烦地将 ​*​***n***​*​ ​*​***=***​*​ ​*​***0***​*​ 和 ​*​***m***​*​ ​*​***=***​*​ ​*​***0***​*​ 这两个前提放一条合取语句中呢？ 完全可以用两条独立的前提来陈述此定理啊：*

```coq
Lemma and_example2'' :
  forall n m : nat, n = 0 -> m = 0 -> n + m = 0.
Proof.
  intros n m Hn Hm.
  rewrite Hn. rewrite Hm.
  reflexivity.
Qed.
```

就此定理而言，两种方式都可以。不过理解如何证明合取前提非常重要， 因为合取语句通常会在证明的中间步骤中出现，特别是在做大型开发的时候。 下面是个简单的例子：

```coq
Lemma and_example3 :
  forall n m : nat, n + m = 0 -> n * m = 0.
Proof.
  (* 课上已完成 *)
  intros n m H.
  assert (H' : n = 0 /\ m = 0).
  { apply and_exercise. apply H. }
  destruct H' as [Hn Hm] eqn:HE.
  rewrite Hn. reflexivity.
Qed.
```

另一种经常遇到合取语句的场景是，我们已经知道了 **A** **∧** **B**， 但在某些上下文中只需要 **A** 或者 **B**。此时我们可以用 **destruct** 进行解构（或许是作为 **intros** 的一部分）并用下划线模式 **_** 来丢弃不需要的合取分式。

```coq
Lemma proj1 : forall P Q : Prop,
  P /\ Q -> P.
Proof.
  intros P Q HPQ.
  destruct HPQ as [HP _].
  apply HP.  Qed.
```

最后，我们有时需要重新排列合取语句的顺序，或者对多部分的合取语句进行分组。 此时使用下面的交换律和结合律会很方便。

```coq
Theorem and_commut : forall P Q : Prop,
  P /\ Q -> Q /\ P.
Proof.
  intros P Q [HP HQ].
  split.
    - (* left *) apply HQ.
    - (* right *) apply HP.  Qed.
```

‍

顺便一提，中缀记法 **∧** 只是 **and** **A** **B** 的语法糖而已； **and** 是 Coq 中将两个命题合并成一个命题的运算符。

```coq
Check and : Prop -> Prop -> Prop.
```

#### 析取

另一个重要的联结词是​*'*​==*析取*==​*'*​，即两个命题的​*'逻辑或'*​：若 **A** 或 **B** 二者之一为真，则 **A** **∨** **B** 为真。（这种中缀记法表示 **or** **A** **B**，其中 **or** **:** **Prop** **→** **Prop** **→** **Prop**。）

为了在证明中使用析取前提，我们需要分类讨论（它与 **nat** 之类的数据类型一样，都可以显式地通过 **destruct** 或隐式地通过 **intros** 模式来拆分：

```coq
Lemma eq_mult_0 :
  forall n m : nat, n = 0 \/ m = 0 -> n * m = 0.
Proof.
  (* [Hn | Hm] 会隐式地对 [n = 0 \/ m = 0] 进行分类讨论 *)
  intros n m [Hn | Hm].
  - (* 在这里 [n = 0] *)
    rewrite Hn. reflexivity.
  - (* 在这里 [m = 0] *)
    rewrite Hm. rewrite <- mult_n_O.
    reflexivity.
Qed.
```

相应地，要证明某个析取命题成立，只需证明其任意一边的命题成立就够了。 我们可以用==​ ​==​==**left**==​==​ 和 ​==​==**right**==​==​ 策略==来选取命题。顾名思义，**left** 会选取待析取证命题的左边，而 **right** 则会选取它的右边。 下面是一种平凡的用法...

```coq
Lemma or_intro_l : forall A B : Prop, A -> A \/ B.
Proof.
  intros A B HA.
  left.
  apply HA.
Qed.

(** ...而这个更有趣的例子则同时需要 [left] 和 [right]： *)

Lemma zero_or_succ :
  forall n : nat, n = 0 \/ n = S (pred n).
Proof.
  (* 课上已完成 *)
  intros [|n'].
  - left. reflexivity.
  - right. reflexivity.
Qed.
```

‍

#### 假命题与否定

目前为止，我们主要都在证明某些东西是*'真'*的：加法满足结合律， 列表的连接满足结合律，等等。当然，我们也关心*'否定'*的结果， 即证明某些给定的命题*'不是'*真的。在 Coq 中，这样的否定语句使用逻辑否定运算符 **¬** 来表达。

为了理解否定背后的原理，我们需要回想一下[Tactics](https://coq-zh.github.io/SF-zh/lf-current/Tactics.html)一章中的​*'爆炸原理'*​。<u>​ 爆炸原理断言，当我们假设了矛盾存在时，就能推出任何命题。 遵循这一直觉，我们可以可以将 ​</u>​<u>**¬**</u>​<u>​ ​</u>​<u>**P**</u>​<u>（即非 ​</u>​<u>**P**</u>​<u>）定义为 ​</u>​<u>**∀**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>, ​</u>​<u>**P**</u>​<u>​ ​</u>​<u>**→**</u>​<u>​ ​</u>​<u>**Q**</u>​<u>。</u>

不过 Coq 选择了稍有些不同（但等价）的做法，它将 **¬** **P** 定义为 **P** **→** **False**，而 **False** 是在标准库中特别定义的矛盾性命题。

```coq
Definition not (P:Prop) := P -> False.

Notation "~ x" := (not x) : type_scope.

Check not : Prop -> Prop.
```

由于 **False** 是个矛盾性命题，因此爆炸原理对它也适用。如果我们让 **False** 进入到了证明的上下文中，可以对它使用 **destruct** 来完成任何待证目标。

```coq
Theorem ex_falso_quodlibet : forall (P:Prop),
  False -> P.
Proof.
  (* 课上已完成 *)
  intros P contra.
  destruct contra.  Qed.
(* TODO: 具体细节的理解？ *)
```

拉丁文 *'ex falso quodlibet'* 的字面意思是“从谬误出发， 你能够证明任何你想要的”，这也是爆炸原理的另一个广为人知的名字。

‍

‍

‍

‍

‍

‍

‍

‍

‍

## 归纳定义的命题    (IndProp)

‍

## 全映射与偏映射    (Maps)

‍

## 柯里-霍华德对应    (ProofObjects)

‍

## 归纳法则    (IndPrinciples)

‍

## 关系的性质    (Rel)

‍

## 简单的指令式程序    (Imp)

‍

## 用 Coq 实现词法分析和语法分析    (ImpParser)

‍

## Imp 的求值函数    (ImpCEvalFun)

‍

## 从 Coq 中提取 ML    (Extraction)

‍

## 更多的自动化    (Auto)

‍

## More Automation    (AltAuto)

‍

## 后记    (Postscript)

‍

‍

[^1]: ### 形式化证明 vs. 非形式化证明


[^2]: #### 用函数构造函数


[^3]: 突然发现多输入函数的类型的形式是连蕴含，而且这个不设计输入或返回一个函数，为什么？柯里化？好像确实是自带柯里化的诶。 解惑见 用...
